// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sql_store.dart';

// ignore_for_file: type=lint
class $AttendanceRegisterTable extends AttendanceRegister
    with TableInfo<$AttendanceRegisterTable, AttendanceRegisterData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AttendanceRegisterTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _registerNumberMeta =
      const VerificationMeta('registerNumber');
  @override
  late final GeneratedColumn<String> registerNumber = GeneratedColumn<String>(
      'register_number', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _localityCodeMeta =
      const VerificationMeta('localityCode');
  @override
  late final GeneratedColumn<String> localityCode = GeneratedColumn<String>(
      'locality_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _serviceCodeMeta =
      const VerificationMeta('serviceCode');
  @override
  late final GeneratedColumn<String> serviceCode = GeneratedColumn<String>(
      'service_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _startDateMeta =
      const VerificationMeta('startDate');
  @override
  late final GeneratedColumn<int> startDate = GeneratedColumn<int>(
      'start_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _endDateMeta =
      const VerificationMeta('endDate');
  @override
  late final GeneratedColumn<int> endDate = GeneratedColumn<int>(
      'end_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        registerNumber,
        name,
        referenceId,
        localityCode,
        serviceCode,
        status,
        startDate,
        endDate,
        additionalFields,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'attendance_register';
  @override
  VerificationContext validateIntegrity(
      Insertable<AttendanceRegisterData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('register_number')) {
      context.handle(
          _registerNumberMeta,
          registerNumber.isAcceptableOrUnknown(
              data['register_number']!, _registerNumberMeta));
    } else if (isInserting) {
      context.missing(_registerNumberMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    } else if (isInserting) {
      context.missing(_referenceIdMeta);
    }
    if (data.containsKey('locality_code')) {
      context.handle(
          _localityCodeMeta,
          localityCode.isAcceptableOrUnknown(
              data['locality_code']!, _localityCodeMeta));
    } else if (isInserting) {
      context.missing(_localityCodeMeta);
    }
    if (data.containsKey('service_code')) {
      context.handle(
          _serviceCodeMeta,
          serviceCode.isAcceptableOrUnknown(
              data['service_code']!, _serviceCodeMeta));
    } else if (isInserting) {
      context.missing(_serviceCodeMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  AttendanceRegisterData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AttendanceRegisterData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      registerNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}register_number'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id'])!,
      localityCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}locality_code'])!,
      serviceCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}service_code'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      startDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}start_date']),
      endDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}end_date']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
    );
  }

  @override
  $AttendanceRegisterTable createAlias(String alias) {
    return $AttendanceRegisterTable(attachedDatabase, alias);
  }
}

class AttendanceRegisterData extends DataClass
    implements Insertable<AttendanceRegisterData> {
  final String? id;
  final String tenantId;
  final String registerNumber;
  final String name;
  final String referenceId;
  final String localityCode;
  final String serviceCode;
  final String status;
  final int? startDate;
  final int? endDate;
  final String? additionalFields;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool? isDeleted;
  final int? rowVersion;
  const AttendanceRegisterData(
      {this.id,
      required this.tenantId,
      required this.registerNumber,
      required this.name,
      required this.referenceId,
      required this.localityCode,
      required this.serviceCode,
      required this.status,
      this.startDate,
      this.endDate,
      this.additionalFields,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.isDeleted,
      this.rowVersion});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    map['tenant_id'] = Variable<String>(tenantId);
    map['register_number'] = Variable<String>(registerNumber);
    map['name'] = Variable<String>(name);
    map['reference_id'] = Variable<String>(referenceId);
    map['locality_code'] = Variable<String>(localityCode);
    map['service_code'] = Variable<String>(serviceCode);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || startDate != null) {
      map['start_date'] = Variable<int>(startDate);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<int>(endDate);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    return map;
  }

  AttendanceRegisterCompanion toCompanion(bool nullToAbsent) {
    return AttendanceRegisterCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: Value(tenantId),
      registerNumber: Value(registerNumber),
      name: Value(name),
      referenceId: Value(referenceId),
      localityCode: Value(localityCode),
      serviceCode: Value(serviceCode),
      status: Value(status),
      startDate: startDate == null && nullToAbsent
          ? const Value.absent()
          : Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
    );
  }

  factory AttendanceRegisterData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AttendanceRegisterData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String>(json['tenantId']),
      registerNumber: serializer.fromJson<String>(json['registerNumber']),
      name: serializer.fromJson<String>(json['name']),
      referenceId: serializer.fromJson<String>(json['referenceId']),
      localityCode: serializer.fromJson<String>(json['localityCode']),
      serviceCode: serializer.fromJson<String>(json['serviceCode']),
      status: serializer.fromJson<String>(json['status']),
      startDate: serializer.fromJson<int?>(json['startDate']),
      endDate: serializer.fromJson<int?>(json['endDate']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String>(tenantId),
      'registerNumber': serializer.toJson<String>(registerNumber),
      'name': serializer.toJson<String>(name),
      'referenceId': serializer.toJson<String>(referenceId),
      'localityCode': serializer.toJson<String>(localityCode),
      'serviceCode': serializer.toJson<String>(serviceCode),
      'status': serializer.toJson<String>(status),
      'startDate': serializer.toJson<int?>(startDate),
      'endDate': serializer.toJson<int?>(endDate),
      'additionalFields': serializer.toJson<String?>(additionalFields),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
    };
  }

  AttendanceRegisterData copyWith(
          {Value<String?> id = const Value.absent(),
          String? tenantId,
          String? registerNumber,
          String? name,
          String? referenceId,
          String? localityCode,
          String? serviceCode,
          String? status,
          Value<int?> startDate = const Value.absent(),
          Value<int?> endDate = const Value.absent(),
          Value<String?> additionalFields = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent()}) =>
      AttendanceRegisterData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId ?? this.tenantId,
        registerNumber: registerNumber ?? this.registerNumber,
        name: name ?? this.name,
        referenceId: referenceId ?? this.referenceId,
        localityCode: localityCode ?? this.localityCode,
        serviceCode: serviceCode ?? this.serviceCode,
        status: status ?? this.status,
        startDate: startDate.present ? startDate.value : this.startDate,
        endDate: endDate.present ? endDate.value : this.endDate,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
      );
  @override
  String toString() {
    return (StringBuffer('AttendanceRegisterData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerNumber: $registerNumber, ')
          ..write('name: $name, ')
          ..write('referenceId: $referenceId, ')
          ..write('localityCode: $localityCode, ')
          ..write('serviceCode: $serviceCode, ')
          ..write('status: $status, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        tenantId,
        registerNumber,
        name,
        referenceId,
        localityCode,
        serviceCode,
        status,
        startDate,
        endDate,
        additionalFields,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AttendanceRegisterData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.registerNumber == this.registerNumber &&
          other.name == this.name &&
          other.referenceId == this.referenceId &&
          other.localityCode == this.localityCode &&
          other.serviceCode == this.serviceCode &&
          other.status == this.status &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.additionalFields == this.additionalFields &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion);
}

class AttendanceRegisterCompanion
    extends UpdateCompanion<AttendanceRegisterData> {
  final Value<String?> id;
  final Value<String> tenantId;
  final Value<String> registerNumber;
  final Value<String> name;
  final Value<String> referenceId;
  final Value<String> localityCode;
  final Value<String> serviceCode;
  final Value<String> status;
  final Value<int?> startDate;
  final Value<int?> endDate;
  final Value<String?> additionalFields;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int> rowid;
  const AttendanceRegisterCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.registerNumber = const Value.absent(),
    this.name = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.localityCode = const Value.absent(),
    this.serviceCode = const Value.absent(),
    this.status = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AttendanceRegisterCompanion.insert({
    this.id = const Value.absent(),
    required String tenantId,
    required String registerNumber,
    required String name,
    required String referenceId,
    required String localityCode,
    required String serviceCode,
    required String status,
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : tenantId = Value(tenantId),
        registerNumber = Value(registerNumber),
        name = Value(name),
        referenceId = Value(referenceId),
        localityCode = Value(localityCode),
        serviceCode = Value(serviceCode),
        status = Value(status);
  static Insertable<AttendanceRegisterData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? registerNumber,
    Expression<String>? name,
    Expression<String>? referenceId,
    Expression<String>? localityCode,
    Expression<String>? serviceCode,
    Expression<String>? status,
    Expression<int>? startDate,
    Expression<int>? endDate,
    Expression<String>? additionalFields,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (registerNumber != null) 'register_number': registerNumber,
      if (name != null) 'name': name,
      if (referenceId != null) 'reference_id': referenceId,
      if (localityCode != null) 'locality_code': localityCode,
      if (serviceCode != null) 'service_code': serviceCode,
      if (status != null) 'status': status,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AttendanceRegisterCompanion copyWith(
      {Value<String?>? id,
      Value<String>? tenantId,
      Value<String>? registerNumber,
      Value<String>? name,
      Value<String>? referenceId,
      Value<String>? localityCode,
      Value<String>? serviceCode,
      Value<String>? status,
      Value<int?>? startDate,
      Value<int?>? endDate,
      Value<String?>? additionalFields,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int>? rowid}) {
    return AttendanceRegisterCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      registerNumber: registerNumber ?? this.registerNumber,
      name: name ?? this.name,
      referenceId: referenceId ?? this.referenceId,
      localityCode: localityCode ?? this.localityCode,
      serviceCode: serviceCode ?? this.serviceCode,
      status: status ?? this.status,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      additionalFields: additionalFields ?? this.additionalFields,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (registerNumber.present) {
      map['register_number'] = Variable<String>(registerNumber.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (localityCode.present) {
      map['locality_code'] = Variable<String>(localityCode.value);
    }
    if (serviceCode.present) {
      map['service_code'] = Variable<String>(serviceCode.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<int>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<int>(endDate.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AttendanceRegisterCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerNumber: $registerNumber, ')
          ..write('name: $name, ')
          ..write('referenceId: $referenceId, ')
          ..write('localityCode: $localityCode, ')
          ..write('serviceCode: $serviceCode, ')
          ..write('status: $status, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AttendanceTable extends Attendance
    with TableInfo<$AttendanceTable, AttendanceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AttendanceTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _registerIdMeta =
      const VerificationMeta('registerId');
  @override
  late final GeneratedColumn<String> registerId = GeneratedColumn<String>(
      'register_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _individualIdMeta =
      const VerificationMeta('individualId');
  @override
  late final GeneratedColumn<String> individualId = GeneratedColumn<String>(
      'individual_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _timeMeta = const VerificationMeta('time');
  @override
  late final GeneratedColumn<int> time = GeneratedColumn<int>(
      'time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _uploadToServerMeta =
      const VerificationMeta('uploadToServer');
  @override
  late final GeneratedColumn<bool> uploadToServer = GeneratedColumn<bool>(
      'upload_to_server', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("upload_to_server" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        clientReferenceId,
        tenantId,
        registerId,
        individualId,
        time,
        status,
        type,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditCreatedBy,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields,
        uploadToServer
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'attendance';
  @override
  VerificationContext validateIntegrity(Insertable<AttendanceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('register_id')) {
      context.handle(
          _registerIdMeta,
          registerId.isAcceptableOrUnknown(
              data['register_id']!, _registerIdMeta));
    } else if (isInserting) {
      context.missing(_registerIdMeta);
    }
    if (data.containsKey('individual_id')) {
      context.handle(
          _individualIdMeta,
          individualId.isAcceptableOrUnknown(
              data['individual_id']!, _individualIdMeta));
    } else if (isInserting) {
      context.missing(_individualIdMeta);
    }
    if (data.containsKey('time')) {
      context.handle(
          _timeMeta, time.isAcceptableOrUnknown(data['time']!, _timeMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    if (data.containsKey('upload_to_server')) {
      context.handle(
          _uploadToServerMeta,
          uploadToServer.isAcceptableOrUnknown(
              data['upload_to_server']!, _uploadToServerMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey =>
      {registerId, individualId, tenantId, type, clientReferenceId};
  @override
  AttendanceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AttendanceData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      registerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}register_id'])!,
      individualId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}individual_id'])!,
      time: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}time']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
      uploadToServer: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}upload_to_server']),
    );
  }

  @override
  $AttendanceTable createAlias(String alias) {
    return $AttendanceTable(attachedDatabase, alias);
  }
}

class AttendanceData extends DataClass implements Insertable<AttendanceData> {
  final String? id;
  final String? clientReferenceId;
  final String tenantId;
  final String registerId;
  final String individualId;
  final int? time;
  final String? status;
  final String? type;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditCreatedBy;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  final bool? uploadToServer;
  const AttendanceData(
      {this.id,
      this.clientReferenceId,
      required this.tenantId,
      required this.registerId,
      required this.individualId,
      this.time,
      this.status,
      this.type,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditCreatedBy,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields,
      this.uploadToServer});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || clientReferenceId != null) {
      map['client_reference_id'] = Variable<String>(clientReferenceId);
    }
    map['tenant_id'] = Variable<String>(tenantId);
    map['register_id'] = Variable<String>(registerId);
    map['individual_id'] = Variable<String>(individualId);
    if (!nullToAbsent || time != null) {
      map['time'] = Variable<int>(time);
    }
    if (!nullToAbsent || status != null) {
      map['status'] = Variable<String>(status);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    if (!nullToAbsent || uploadToServer != null) {
      map['upload_to_server'] = Variable<bool>(uploadToServer);
    }
    return map;
  }

  AttendanceCompanion toCompanion(bool nullToAbsent) {
    return AttendanceCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      clientReferenceId: clientReferenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(clientReferenceId),
      tenantId: Value(tenantId),
      registerId: Value(registerId),
      individualId: Value(individualId),
      time: time == null && nullToAbsent ? const Value.absent() : Value(time),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
      uploadToServer: uploadToServer == null && nullToAbsent
          ? const Value.absent()
          : Value(uploadToServer),
    );
  }

  factory AttendanceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AttendanceData(
      id: serializer.fromJson<String?>(json['id']),
      clientReferenceId:
          serializer.fromJson<String?>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String>(json['tenantId']),
      registerId: serializer.fromJson<String>(json['registerId']),
      individualId: serializer.fromJson<String>(json['individualId']),
      time: serializer.fromJson<int?>(json['time']),
      status: serializer.fromJson<String?>(json['status']),
      type: serializer.fromJson<String?>(json['type']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
      uploadToServer: serializer.fromJson<bool?>(json['uploadToServer']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'clientReferenceId': serializer.toJson<String?>(clientReferenceId),
      'tenantId': serializer.toJson<String>(tenantId),
      'registerId': serializer.toJson<String>(registerId),
      'individualId': serializer.toJson<String>(individualId),
      'time': serializer.toJson<int?>(time),
      'status': serializer.toJson<String?>(status),
      'type': serializer.toJson<String?>(type),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
      'uploadToServer': serializer.toJson<bool?>(uploadToServer),
    };
  }

  AttendanceData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> clientReferenceId = const Value.absent(),
          String? tenantId,
          String? registerId,
          String? individualId,
          Value<int?> time = const Value.absent(),
          Value<String?> status = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent(),
          Value<bool?> uploadToServer = const Value.absent()}) =>
      AttendanceData(
        id: id.present ? id.value : this.id,
        clientReferenceId: clientReferenceId.present
            ? clientReferenceId.value
            : this.clientReferenceId,
        tenantId: tenantId ?? this.tenantId,
        registerId: registerId ?? this.registerId,
        individualId: individualId ?? this.individualId,
        time: time.present ? time.value : this.time,
        status: status.present ? status.value : this.status,
        type: type.present ? type.value : this.type,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
        uploadToServer:
            uploadToServer.present ? uploadToServer.value : this.uploadToServer,
      );
  @override
  String toString() {
    return (StringBuffer('AttendanceData(')
          ..write('id: $id, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerId: $registerId, ')
          ..write('individualId: $individualId, ')
          ..write('time: $time, ')
          ..write('status: $status, ')
          ..write('type: $type, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('uploadToServer: $uploadToServer')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        clientReferenceId,
        tenantId,
        registerId,
        individualId,
        time,
        status,
        type,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditCreatedBy,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields,
        uploadToServer
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AttendanceData &&
          other.id == this.id &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.registerId == this.registerId &&
          other.individualId == this.individualId &&
          other.time == this.time &&
          other.status == this.status &&
          other.type == this.type &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields &&
          other.uploadToServer == this.uploadToServer);
}

class AttendanceCompanion extends UpdateCompanion<AttendanceData> {
  final Value<String?> id;
  final Value<String?> clientReferenceId;
  final Value<String> tenantId;
  final Value<String> registerId;
  final Value<String> individualId;
  final Value<int?> time;
  final Value<String?> status;
  final Value<String?> type;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditCreatedBy;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<bool?> uploadToServer;
  final Value<int> rowid;
  const AttendanceCompanion({
    this.id = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.registerId = const Value.absent(),
    this.individualId = const Value.absent(),
    this.time = const Value.absent(),
    this.status = const Value.absent(),
    this.type = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.uploadToServer = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AttendanceCompanion.insert({
    this.id = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    required String tenantId,
    required String registerId,
    required String individualId,
    this.time = const Value.absent(),
    this.status = const Value.absent(),
    this.type = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.uploadToServer = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : tenantId = Value(tenantId),
        registerId = Value(registerId),
        individualId = Value(individualId);
  static Insertable<AttendanceData> custom({
    Expression<String>? id,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<String>? registerId,
    Expression<String>? individualId,
    Expression<int>? time,
    Expression<String>? status,
    Expression<String>? type,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditCreatedBy,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<bool>? uploadToServer,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (registerId != null) 'register_id': registerId,
      if (individualId != null) 'individual_id': individualId,
      if (time != null) 'time': time,
      if (status != null) 'status': status,
      if (type != null) 'type': type,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (uploadToServer != null) 'upload_to_server': uploadToServer,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AttendanceCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? clientReferenceId,
      Value<String>? tenantId,
      Value<String>? registerId,
      Value<String>? individualId,
      Value<int?>? time,
      Value<String?>? status,
      Value<String?>? type,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditCreatedBy,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<bool?>? uploadToServer,
      Value<int>? rowid}) {
    return AttendanceCompanion(
      id: id ?? this.id,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      registerId: registerId ?? this.registerId,
      individualId: individualId ?? this.individualId,
      time: time ?? this.time,
      status: status ?? this.status,
      type: type ?? this.type,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      uploadToServer: uploadToServer ?? this.uploadToServer,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (registerId.present) {
      map['register_id'] = Variable<String>(registerId.value);
    }
    if (individualId.present) {
      map['individual_id'] = Variable<String>(individualId.value);
    }
    if (time.present) {
      map['time'] = Variable<int>(time.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (uploadToServer.present) {
      map['upload_to_server'] = Variable<bool>(uploadToServer.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AttendanceCompanion(')
          ..write('id: $id, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerId: $registerId, ')
          ..write('individualId: $individualId, ')
          ..write('time: $time, ')
          ..write('status: $status, ')
          ..write('type: $type, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('uploadToServer: $uploadToServer, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AttendeeTable extends Attendee
    with TableInfo<$AttendeeTable, AttendeeData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AttendeeTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _registerIdMeta =
      const VerificationMeta('registerId');
  @override
  late final GeneratedColumn<String> registerId = GeneratedColumn<String>(
      'register_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _individualIdMeta =
      const VerificationMeta('individualId');
  @override
  late final GeneratedColumn<String> individualId = GeneratedColumn<String>(
      'individual_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<int> status = GeneratedColumn<int>(
      'status', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _enrollmentDateMeta =
      const VerificationMeta('enrollmentDate');
  @override
  late final GeneratedColumn<int> enrollmentDate = GeneratedColumn<int>(
      'enrollment_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _denrollmentDateMeta =
      const VerificationMeta('denrollmentDate');
  @override
  late final GeneratedColumn<int> denrollmentDate = GeneratedColumn<int>(
      'denrollment_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tagMeta = const VerificationMeta('tag');
  @override
  late final GeneratedColumn<String> tag = GeneratedColumn<String>(
      'tag', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        registerId,
        individualId,
        status,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditCreatedBy,
        auditModifiedBy,
        auditModifiedTime,
        enrollmentDate,
        denrollmentDate,
        isDeleted,
        rowVersion,
        additionalFields,
        tag
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'attendee';
  @override
  VerificationContext validateIntegrity(Insertable<AttendeeData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('register_id')) {
      context.handle(
          _registerIdMeta,
          registerId.isAcceptableOrUnknown(
              data['register_id']!, _registerIdMeta));
    } else if (isInserting) {
      context.missing(_registerIdMeta);
    }
    if (data.containsKey('individual_id')) {
      context.handle(
          _individualIdMeta,
          individualId.isAcceptableOrUnknown(
              data['individual_id']!, _individualIdMeta));
    } else if (isInserting) {
      context.missing(_individualIdMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('enrollment_date')) {
      context.handle(
          _enrollmentDateMeta,
          enrollmentDate.isAcceptableOrUnknown(
              data['enrollment_date']!, _enrollmentDateMeta));
    }
    if (data.containsKey('denrollment_date')) {
      context.handle(
          _denrollmentDateMeta,
          denrollmentDate.isAcceptableOrUnknown(
              data['denrollment_date']!, _denrollmentDateMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    if (data.containsKey('tag')) {
      context.handle(
          _tagMeta, tag.isAcceptableOrUnknown(data['tag']!, _tagMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, registerId};
  @override
  AttendeeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AttendeeData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      registerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}register_id'])!,
      individualId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}individual_id'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}status']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      enrollmentDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}enrollment_date']),
      denrollmentDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}denrollment_date']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
      tag: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tag']),
    );
  }

  @override
  $AttendeeTable createAlias(String alias) {
    return $AttendeeTable(attachedDatabase, alias);
  }
}

class AttendeeData extends DataClass implements Insertable<AttendeeData> {
  final String? id;
  final String tenantId;
  final String registerId;
  final String individualId;
  final int? status;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditCreatedBy;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final int? enrollmentDate;
  final int? denrollmentDate;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  final String? tag;
  const AttendeeData(
      {this.id,
      required this.tenantId,
      required this.registerId,
      required this.individualId,
      this.status,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditCreatedBy,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.enrollmentDate,
      this.denrollmentDate,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields,
      this.tag});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    map['tenant_id'] = Variable<String>(tenantId);
    map['register_id'] = Variable<String>(registerId);
    map['individual_id'] = Variable<String>(individualId);
    if (!nullToAbsent || status != null) {
      map['status'] = Variable<int>(status);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || enrollmentDate != null) {
      map['enrollment_date'] = Variable<int>(enrollmentDate);
    }
    if (!nullToAbsent || denrollmentDate != null) {
      map['denrollment_date'] = Variable<int>(denrollmentDate);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    if (!nullToAbsent || tag != null) {
      map['tag'] = Variable<String>(tag);
    }
    return map;
  }

  AttendeeCompanion toCompanion(bool nullToAbsent) {
    return AttendeeCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: Value(tenantId),
      registerId: Value(registerId),
      individualId: Value(individualId),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      enrollmentDate: enrollmentDate == null && nullToAbsent
          ? const Value.absent()
          : Value(enrollmentDate),
      denrollmentDate: denrollmentDate == null && nullToAbsent
          ? const Value.absent()
          : Value(denrollmentDate),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
      tag: tag == null && nullToAbsent ? const Value.absent() : Value(tag),
    );
  }

  factory AttendeeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AttendeeData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String>(json['tenantId']),
      registerId: serializer.fromJson<String>(json['registerId']),
      individualId: serializer.fromJson<String>(json['individualId']),
      status: serializer.fromJson<int?>(json['status']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      enrollmentDate: serializer.fromJson<int?>(json['enrollmentDate']),
      denrollmentDate: serializer.fromJson<int?>(json['denrollmentDate']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
      tag: serializer.fromJson<String?>(json['tag']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String>(tenantId),
      'registerId': serializer.toJson<String>(registerId),
      'individualId': serializer.toJson<String>(individualId),
      'status': serializer.toJson<int?>(status),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'enrollmentDate': serializer.toJson<int?>(enrollmentDate),
      'denrollmentDate': serializer.toJson<int?>(denrollmentDate),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
      'tag': serializer.toJson<String?>(tag),
    };
  }

  AttendeeData copyWith(
          {Value<String?> id = const Value.absent(),
          String? tenantId,
          String? registerId,
          String? individualId,
          Value<int?> status = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<int?> enrollmentDate = const Value.absent(),
          Value<int?> denrollmentDate = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent(),
          Value<String?> tag = const Value.absent()}) =>
      AttendeeData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId ?? this.tenantId,
        registerId: registerId ?? this.registerId,
        individualId: individualId ?? this.individualId,
        status: status.present ? status.value : this.status,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        enrollmentDate:
            enrollmentDate.present ? enrollmentDate.value : this.enrollmentDate,
        denrollmentDate: denrollmentDate.present
            ? denrollmentDate.value
            : this.denrollmentDate,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
        tag: tag.present ? tag.value : this.tag,
      );
  @override
  String toString() {
    return (StringBuffer('AttendeeData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerId: $registerId, ')
          ..write('individualId: $individualId, ')
          ..write('status: $status, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('enrollmentDate: $enrollmentDate, ')
          ..write('denrollmentDate: $denrollmentDate, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('tag: $tag')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      tenantId,
      registerId,
      individualId,
      status,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditCreatedBy,
      auditModifiedBy,
      auditModifiedTime,
      enrollmentDate,
      denrollmentDate,
      isDeleted,
      rowVersion,
      additionalFields,
      tag);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AttendeeData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.registerId == this.registerId &&
          other.individualId == this.individualId &&
          other.status == this.status &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.enrollmentDate == this.enrollmentDate &&
          other.denrollmentDate == this.denrollmentDate &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields &&
          other.tag == this.tag);
}

class AttendeeCompanion extends UpdateCompanion<AttendeeData> {
  final Value<String?> id;
  final Value<String> tenantId;
  final Value<String> registerId;
  final Value<String> individualId;
  final Value<int?> status;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditCreatedBy;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<int?> enrollmentDate;
  final Value<int?> denrollmentDate;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<String?> tag;
  final Value<int> rowid;
  const AttendeeCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.registerId = const Value.absent(),
    this.individualId = const Value.absent(),
    this.status = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.enrollmentDate = const Value.absent(),
    this.denrollmentDate = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.tag = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AttendeeCompanion.insert({
    this.id = const Value.absent(),
    required String tenantId,
    required String registerId,
    required String individualId,
    this.status = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.enrollmentDate = const Value.absent(),
    this.denrollmentDate = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.tag = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : tenantId = Value(tenantId),
        registerId = Value(registerId),
        individualId = Value(individualId);
  static Insertable<AttendeeData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? registerId,
    Expression<String>? individualId,
    Expression<int>? status,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditCreatedBy,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<int>? enrollmentDate,
    Expression<int>? denrollmentDate,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<String>? tag,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (registerId != null) 'register_id': registerId,
      if (individualId != null) 'individual_id': individualId,
      if (status != null) 'status': status,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (enrollmentDate != null) 'enrollment_date': enrollmentDate,
      if (denrollmentDate != null) 'denrollment_date': denrollmentDate,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (tag != null) 'tag': tag,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AttendeeCompanion copyWith(
      {Value<String?>? id,
      Value<String>? tenantId,
      Value<String>? registerId,
      Value<String>? individualId,
      Value<int?>? status,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditCreatedBy,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<int?>? enrollmentDate,
      Value<int?>? denrollmentDate,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<String?>? tag,
      Value<int>? rowid}) {
    return AttendeeCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      registerId: registerId ?? this.registerId,
      individualId: individualId ?? this.individualId,
      status: status ?? this.status,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      enrollmentDate: enrollmentDate ?? this.enrollmentDate,
      denrollmentDate: denrollmentDate ?? this.denrollmentDate,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      tag: tag ?? this.tag,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (registerId.present) {
      map['register_id'] = Variable<String>(registerId.value);
    }
    if (individualId.present) {
      map['individual_id'] = Variable<String>(individualId.value);
    }
    if (status.present) {
      map['status'] = Variable<int>(status.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (enrollmentDate.present) {
      map['enrollment_date'] = Variable<int>(enrollmentDate.value);
    }
    if (denrollmentDate.present) {
      map['denrollment_date'] = Variable<int>(denrollmentDate.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (tag.present) {
      map['tag'] = Variable<String>(tag.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AttendeeCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerId: $registerId, ')
          ..write('individualId: $individualId, ')
          ..write('status: $status, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('enrollmentDate: $enrollmentDate, ')
          ..write('denrollmentDate: $denrollmentDate, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('tag: $tag, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AddressTable extends Address with TableInfo<$AddressTable, Addres> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AddressTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _relatedClientReferenceIdMeta =
      const VerificationMeta('relatedClientReferenceId');
  @override
  late final GeneratedColumn<String> relatedClientReferenceId =
      GeneratedColumn<String>('related_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _doorNoMeta = const VerificationMeta('doorNo');
  @override
  late final GeneratedColumn<String> doorNo = GeneratedColumn<String>(
      'door_no', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
      'latitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
      'longitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _locationAccuracyMeta =
      const VerificationMeta('locationAccuracy');
  @override
  late final GeneratedColumn<double> locationAccuracy = GeneratedColumn<double>(
      'location_accuracy', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _addressLine1Meta =
      const VerificationMeta('addressLine1');
  @override
  late final GeneratedColumn<String> addressLine1 = GeneratedColumn<String>(
      'address_line1', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _addressLine2Meta =
      const VerificationMeta('addressLine2');
  @override
  late final GeneratedColumn<String> addressLine2 = GeneratedColumn<String>(
      'address_line2', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _landmarkMeta =
      const VerificationMeta('landmark');
  @override
  late final GeneratedColumn<String> landmark = GeneratedColumn<String>(
      'landmark', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _cityMeta = const VerificationMeta('city');
  @override
  late final GeneratedColumn<String> city = GeneratedColumn<String>(
      'city', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _pincodeMeta =
      const VerificationMeta('pincode');
  @override
  late final GeneratedColumn<String> pincode = GeneratedColumn<String>(
      'pincode', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _buildingNameMeta =
      const VerificationMeta('buildingName');
  @override
  late final GeneratedColumn<String> buildingName = GeneratedColumn<String>(
      'building_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _streetMeta = const VerificationMeta('street');
  @override
  late final GeneratedColumn<String> street = GeneratedColumn<String>(
      'street', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _boundaryTypeMeta =
      const VerificationMeta('boundaryType');
  @override
  late final GeneratedColumn<String> boundaryType = GeneratedColumn<String>(
      'boundary_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _boundaryMeta =
      const VerificationMeta('boundary');
  @override
  late final GeneratedColumn<String> boundary = GeneratedColumn<String>(
      'boundary', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _localityBoundaryCodeMeta =
      const VerificationMeta('localityBoundaryCode');
  @override
  late final GeneratedColumn<String> localityBoundaryCode =
      GeneratedColumn<String>('locality_boundary_code', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _localityBoundaryNameMeta =
      const VerificationMeta('localityBoundaryName');
  @override
  late final GeneratedColumn<String> localityBoundaryName =
      GeneratedColumn<String>('locality_boundary_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumnWithTypeConverter<AddressType?, int> type =
      GeneratedColumn<int>('type', aliasedName, true,
              type: DriftSqlType.int, requiredDuringInsert: false)
          .withConverter<AddressType?>($AddressTable.$convertertypen);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        relatedClientReferenceId,
        doorNo,
        latitude,
        longitude,
        locationAccuracy,
        addressLine1,
        addressLine2,
        landmark,
        city,
        pincode,
        buildingName,
        street,
        boundaryType,
        boundary,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        localityBoundaryCode,
        localityBoundaryName,
        tenantId,
        isDeleted,
        rowVersion,
        type,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'address';
  @override
  VerificationContext validateIntegrity(Insertable<Addres> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('related_client_reference_id')) {
      context.handle(
          _relatedClientReferenceIdMeta,
          relatedClientReferenceId.isAcceptableOrUnknown(
              data['related_client_reference_id']!,
              _relatedClientReferenceIdMeta));
    }
    if (data.containsKey('door_no')) {
      context.handle(_doorNoMeta,
          doorNo.isAcceptableOrUnknown(data['door_no']!, _doorNoMeta));
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    }
    if (data.containsKey('location_accuracy')) {
      context.handle(
          _locationAccuracyMeta,
          locationAccuracy.isAcceptableOrUnknown(
              data['location_accuracy']!, _locationAccuracyMeta));
    }
    if (data.containsKey('address_line1')) {
      context.handle(
          _addressLine1Meta,
          addressLine1.isAcceptableOrUnknown(
              data['address_line1']!, _addressLine1Meta));
    }
    if (data.containsKey('address_line2')) {
      context.handle(
          _addressLine2Meta,
          addressLine2.isAcceptableOrUnknown(
              data['address_line2']!, _addressLine2Meta));
    }
    if (data.containsKey('landmark')) {
      context.handle(_landmarkMeta,
          landmark.isAcceptableOrUnknown(data['landmark']!, _landmarkMeta));
    }
    if (data.containsKey('city')) {
      context.handle(
          _cityMeta, city.isAcceptableOrUnknown(data['city']!, _cityMeta));
    }
    if (data.containsKey('pincode')) {
      context.handle(_pincodeMeta,
          pincode.isAcceptableOrUnknown(data['pincode']!, _pincodeMeta));
    }
    if (data.containsKey('building_name')) {
      context.handle(
          _buildingNameMeta,
          buildingName.isAcceptableOrUnknown(
              data['building_name']!, _buildingNameMeta));
    }
    if (data.containsKey('street')) {
      context.handle(_streetMeta,
          street.isAcceptableOrUnknown(data['street']!, _streetMeta));
    }
    if (data.containsKey('boundary_type')) {
      context.handle(
          _boundaryTypeMeta,
          boundaryType.isAcceptableOrUnknown(
              data['boundary_type']!, _boundaryTypeMeta));
    }
    if (data.containsKey('boundary')) {
      context.handle(_boundaryMeta,
          boundary.isAcceptableOrUnknown(data['boundary']!, _boundaryMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('locality_boundary_code')) {
      context.handle(
          _localityBoundaryCodeMeta,
          localityBoundaryCode.isAcceptableOrUnknown(
              data['locality_boundary_code']!, _localityBoundaryCodeMeta));
    }
    if (data.containsKey('locality_boundary_name')) {
      context.handle(
          _localityBoundaryNameMeta,
          localityBoundaryName.isAcceptableOrUnknown(
              data['locality_boundary_name']!, _localityBoundaryNameMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    context.handle(_typeMeta, const VerificationResult.success());
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey =>
      {relatedClientReferenceId, auditCreatedBy};
  @override
  Addres map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Addres(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      relatedClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}related_client_reference_id']),
      doorNo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}door_no']),
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}latitude']),
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}longitude']),
      locationAccuracy: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}location_accuracy']),
      addressLine1: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address_line1']),
      addressLine2: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address_line2']),
      landmark: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}landmark']),
      city: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}city']),
      pincode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}pincode']),
      buildingName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}building_name']),
      street: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}street']),
      boundaryType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}boundary_type']),
      boundary: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}boundary']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      localityBoundaryCode: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}locality_boundary_code']),
      localityBoundaryName: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}locality_boundary_name']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      type: $AddressTable.$convertertypen.fromSql(attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}type'])),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $AddressTable createAlias(String alias) {
    return $AddressTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<AddressType, int, int> $convertertype =
      const EnumIndexConverter<AddressType>(AddressType.values);
  static JsonTypeConverter2<AddressType?, int?, int?> $convertertypen =
      JsonTypeConverter2.asNullable($convertertype);
}

class Addres extends DataClass implements Insertable<Addres> {
  final String? id;
  final String? relatedClientReferenceId;
  final String? doorNo;
  final double? latitude;
  final double? longitude;
  final double? locationAccuracy;
  final String? addressLine1;
  final String? addressLine2;
  final String? landmark;
  final String? city;
  final String? pincode;
  final String? buildingName;
  final String? street;
  final String? boundaryType;
  final String? boundary;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? localityBoundaryCode;
  final String? localityBoundaryName;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final AddressType? type;
  final String? additionalFields;
  const Addres(
      {this.id,
      this.relatedClientReferenceId,
      this.doorNo,
      this.latitude,
      this.longitude,
      this.locationAccuracy,
      this.addressLine1,
      this.addressLine2,
      this.landmark,
      this.city,
      this.pincode,
      this.buildingName,
      this.street,
      this.boundaryType,
      this.boundary,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.localityBoundaryCode,
      this.localityBoundaryName,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.type,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || relatedClientReferenceId != null) {
      map['related_client_reference_id'] =
          Variable<String>(relatedClientReferenceId);
    }
    if (!nullToAbsent || doorNo != null) {
      map['door_no'] = Variable<String>(doorNo);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || locationAccuracy != null) {
      map['location_accuracy'] = Variable<double>(locationAccuracy);
    }
    if (!nullToAbsent || addressLine1 != null) {
      map['address_line1'] = Variable<String>(addressLine1);
    }
    if (!nullToAbsent || addressLine2 != null) {
      map['address_line2'] = Variable<String>(addressLine2);
    }
    if (!nullToAbsent || landmark != null) {
      map['landmark'] = Variable<String>(landmark);
    }
    if (!nullToAbsent || city != null) {
      map['city'] = Variable<String>(city);
    }
    if (!nullToAbsent || pincode != null) {
      map['pincode'] = Variable<String>(pincode);
    }
    if (!nullToAbsent || buildingName != null) {
      map['building_name'] = Variable<String>(buildingName);
    }
    if (!nullToAbsent || street != null) {
      map['street'] = Variable<String>(street);
    }
    if (!nullToAbsent || boundaryType != null) {
      map['boundary_type'] = Variable<String>(boundaryType);
    }
    if (!nullToAbsent || boundary != null) {
      map['boundary'] = Variable<String>(boundary);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || localityBoundaryCode != null) {
      map['locality_boundary_code'] = Variable<String>(localityBoundaryCode);
    }
    if (!nullToAbsent || localityBoundaryName != null) {
      map['locality_boundary_name'] = Variable<String>(localityBoundaryName);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<int>($AddressTable.$convertertypen.toSql(type));
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  AddressCompanion toCompanion(bool nullToAbsent) {
    return AddressCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      relatedClientReferenceId: relatedClientReferenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(relatedClientReferenceId),
      doorNo:
          doorNo == null && nullToAbsent ? const Value.absent() : Value(doorNo),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      locationAccuracy: locationAccuracy == null && nullToAbsent
          ? const Value.absent()
          : Value(locationAccuracy),
      addressLine1: addressLine1 == null && nullToAbsent
          ? const Value.absent()
          : Value(addressLine1),
      addressLine2: addressLine2 == null && nullToAbsent
          ? const Value.absent()
          : Value(addressLine2),
      landmark: landmark == null && nullToAbsent
          ? const Value.absent()
          : Value(landmark),
      city: city == null && nullToAbsent ? const Value.absent() : Value(city),
      pincode: pincode == null && nullToAbsent
          ? const Value.absent()
          : Value(pincode),
      buildingName: buildingName == null && nullToAbsent
          ? const Value.absent()
          : Value(buildingName),
      street:
          street == null && nullToAbsent ? const Value.absent() : Value(street),
      boundaryType: boundaryType == null && nullToAbsent
          ? const Value.absent()
          : Value(boundaryType),
      boundary: boundary == null && nullToAbsent
          ? const Value.absent()
          : Value(boundary),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      localityBoundaryCode: localityBoundaryCode == null && nullToAbsent
          ? const Value.absent()
          : Value(localityBoundaryCode),
      localityBoundaryName: localityBoundaryName == null && nullToAbsent
          ? const Value.absent()
          : Value(localityBoundaryName),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory Addres.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Addres(
      id: serializer.fromJson<String?>(json['id']),
      relatedClientReferenceId:
          serializer.fromJson<String?>(json['relatedClientReferenceId']),
      doorNo: serializer.fromJson<String?>(json['doorNo']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      locationAccuracy: serializer.fromJson<double?>(json['locationAccuracy']),
      addressLine1: serializer.fromJson<String?>(json['addressLine1']),
      addressLine2: serializer.fromJson<String?>(json['addressLine2']),
      landmark: serializer.fromJson<String?>(json['landmark']),
      city: serializer.fromJson<String?>(json['city']),
      pincode: serializer.fromJson<String?>(json['pincode']),
      buildingName: serializer.fromJson<String?>(json['buildingName']),
      street: serializer.fromJson<String?>(json['street']),
      boundaryType: serializer.fromJson<String?>(json['boundaryType']),
      boundary: serializer.fromJson<String?>(json['boundary']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      localityBoundaryCode:
          serializer.fromJson<String?>(json['localityBoundaryCode']),
      localityBoundaryName:
          serializer.fromJson<String?>(json['localityBoundaryName']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      type: $AddressTable.$convertertypen
          .fromJson(serializer.fromJson<int?>(json['type'])),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'relatedClientReferenceId':
          serializer.toJson<String?>(relatedClientReferenceId),
      'doorNo': serializer.toJson<String?>(doorNo),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'locationAccuracy': serializer.toJson<double?>(locationAccuracy),
      'addressLine1': serializer.toJson<String?>(addressLine1),
      'addressLine2': serializer.toJson<String?>(addressLine2),
      'landmark': serializer.toJson<String?>(landmark),
      'city': serializer.toJson<String?>(city),
      'pincode': serializer.toJson<String?>(pincode),
      'buildingName': serializer.toJson<String?>(buildingName),
      'street': serializer.toJson<String?>(street),
      'boundaryType': serializer.toJson<String?>(boundaryType),
      'boundary': serializer.toJson<String?>(boundary),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'localityBoundaryCode': serializer.toJson<String?>(localityBoundaryCode),
      'localityBoundaryName': serializer.toJson<String?>(localityBoundaryName),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'type':
          serializer.toJson<int?>($AddressTable.$convertertypen.toJson(type)),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  Addres copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> relatedClientReferenceId = const Value.absent(),
          Value<String?> doorNo = const Value.absent(),
          Value<double?> latitude = const Value.absent(),
          Value<double?> longitude = const Value.absent(),
          Value<double?> locationAccuracy = const Value.absent(),
          Value<String?> addressLine1 = const Value.absent(),
          Value<String?> addressLine2 = const Value.absent(),
          Value<String?> landmark = const Value.absent(),
          Value<String?> city = const Value.absent(),
          Value<String?> pincode = const Value.absent(),
          Value<String?> buildingName = const Value.absent(),
          Value<String?> street = const Value.absent(),
          Value<String?> boundaryType = const Value.absent(),
          Value<String?> boundary = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> localityBoundaryCode = const Value.absent(),
          Value<String?> localityBoundaryName = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<AddressType?> type = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      Addres(
        id: id.present ? id.value : this.id,
        relatedClientReferenceId: relatedClientReferenceId.present
            ? relatedClientReferenceId.value
            : this.relatedClientReferenceId,
        doorNo: doorNo.present ? doorNo.value : this.doorNo,
        latitude: latitude.present ? latitude.value : this.latitude,
        longitude: longitude.present ? longitude.value : this.longitude,
        locationAccuracy: locationAccuracy.present
            ? locationAccuracy.value
            : this.locationAccuracy,
        addressLine1:
            addressLine1.present ? addressLine1.value : this.addressLine1,
        addressLine2:
            addressLine2.present ? addressLine2.value : this.addressLine2,
        landmark: landmark.present ? landmark.value : this.landmark,
        city: city.present ? city.value : this.city,
        pincode: pincode.present ? pincode.value : this.pincode,
        buildingName:
            buildingName.present ? buildingName.value : this.buildingName,
        street: street.present ? street.value : this.street,
        boundaryType:
            boundaryType.present ? boundaryType.value : this.boundaryType,
        boundary: boundary.present ? boundary.value : this.boundary,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        localityBoundaryCode: localityBoundaryCode.present
            ? localityBoundaryCode.value
            : this.localityBoundaryCode,
        localityBoundaryName: localityBoundaryName.present
            ? localityBoundaryName.value
            : this.localityBoundaryName,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        type: type.present ? type.value : this.type,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('Addres(')
          ..write('id: $id, ')
          ..write('relatedClientReferenceId: $relatedClientReferenceId, ')
          ..write('doorNo: $doorNo, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('locationAccuracy: $locationAccuracy, ')
          ..write('addressLine1: $addressLine1, ')
          ..write('addressLine2: $addressLine2, ')
          ..write('landmark: $landmark, ')
          ..write('city: $city, ')
          ..write('pincode: $pincode, ')
          ..write('buildingName: $buildingName, ')
          ..write('street: $street, ')
          ..write('boundaryType: $boundaryType, ')
          ..write('boundary: $boundary, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('localityBoundaryCode: $localityBoundaryCode, ')
          ..write('localityBoundaryName: $localityBoundaryName, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('type: $type, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        relatedClientReferenceId,
        doorNo,
        latitude,
        longitude,
        locationAccuracy,
        addressLine1,
        addressLine2,
        landmark,
        city,
        pincode,
        buildingName,
        street,
        boundaryType,
        boundary,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        localityBoundaryCode,
        localityBoundaryName,
        tenantId,
        isDeleted,
        rowVersion,
        type,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Addres &&
          other.id == this.id &&
          other.relatedClientReferenceId == this.relatedClientReferenceId &&
          other.doorNo == this.doorNo &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.locationAccuracy == this.locationAccuracy &&
          other.addressLine1 == this.addressLine1 &&
          other.addressLine2 == this.addressLine2 &&
          other.landmark == this.landmark &&
          other.city == this.city &&
          other.pincode == this.pincode &&
          other.buildingName == this.buildingName &&
          other.street == this.street &&
          other.boundaryType == this.boundaryType &&
          other.boundary == this.boundary &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.localityBoundaryCode == this.localityBoundaryCode &&
          other.localityBoundaryName == this.localityBoundaryName &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.type == this.type &&
          other.additionalFields == this.additionalFields);
}

class AddressCompanion extends UpdateCompanion<Addres> {
  final Value<String?> id;
  final Value<String?> relatedClientReferenceId;
  final Value<String?> doorNo;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<double?> locationAccuracy;
  final Value<String?> addressLine1;
  final Value<String?> addressLine2;
  final Value<String?> landmark;
  final Value<String?> city;
  final Value<String?> pincode;
  final Value<String?> buildingName;
  final Value<String?> street;
  final Value<String?> boundaryType;
  final Value<String?> boundary;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> localityBoundaryCode;
  final Value<String?> localityBoundaryName;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<AddressType?> type;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const AddressCompanion({
    this.id = const Value.absent(),
    this.relatedClientReferenceId = const Value.absent(),
    this.doorNo = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.locationAccuracy = const Value.absent(),
    this.addressLine1 = const Value.absent(),
    this.addressLine2 = const Value.absent(),
    this.landmark = const Value.absent(),
    this.city = const Value.absent(),
    this.pincode = const Value.absent(),
    this.buildingName = const Value.absent(),
    this.street = const Value.absent(),
    this.boundaryType = const Value.absent(),
    this.boundary = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.localityBoundaryCode = const Value.absent(),
    this.localityBoundaryName = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.type = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AddressCompanion.insert({
    this.id = const Value.absent(),
    this.relatedClientReferenceId = const Value.absent(),
    this.doorNo = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.locationAccuracy = const Value.absent(),
    this.addressLine1 = const Value.absent(),
    this.addressLine2 = const Value.absent(),
    this.landmark = const Value.absent(),
    this.city = const Value.absent(),
    this.pincode = const Value.absent(),
    this.buildingName = const Value.absent(),
    this.street = const Value.absent(),
    this.boundaryType = const Value.absent(),
    this.boundary = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.localityBoundaryCode = const Value.absent(),
    this.localityBoundaryName = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.type = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<Addres> custom({
    Expression<String>? id,
    Expression<String>? relatedClientReferenceId,
    Expression<String>? doorNo,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<double>? locationAccuracy,
    Expression<String>? addressLine1,
    Expression<String>? addressLine2,
    Expression<String>? landmark,
    Expression<String>? city,
    Expression<String>? pincode,
    Expression<String>? buildingName,
    Expression<String>? street,
    Expression<String>? boundaryType,
    Expression<String>? boundary,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? localityBoundaryCode,
    Expression<String>? localityBoundaryName,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? type,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (relatedClientReferenceId != null)
        'related_client_reference_id': relatedClientReferenceId,
      if (doorNo != null) 'door_no': doorNo,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (locationAccuracy != null) 'location_accuracy': locationAccuracy,
      if (addressLine1 != null) 'address_line1': addressLine1,
      if (addressLine2 != null) 'address_line2': addressLine2,
      if (landmark != null) 'landmark': landmark,
      if (city != null) 'city': city,
      if (pincode != null) 'pincode': pincode,
      if (buildingName != null) 'building_name': buildingName,
      if (street != null) 'street': street,
      if (boundaryType != null) 'boundary_type': boundaryType,
      if (boundary != null) 'boundary': boundary,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (localityBoundaryCode != null)
        'locality_boundary_code': localityBoundaryCode,
      if (localityBoundaryName != null)
        'locality_boundary_name': localityBoundaryName,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (type != null) 'type': type,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AddressCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? relatedClientReferenceId,
      Value<String?>? doorNo,
      Value<double?>? latitude,
      Value<double?>? longitude,
      Value<double?>? locationAccuracy,
      Value<String?>? addressLine1,
      Value<String?>? addressLine2,
      Value<String?>? landmark,
      Value<String?>? city,
      Value<String?>? pincode,
      Value<String?>? buildingName,
      Value<String?>? street,
      Value<String?>? boundaryType,
      Value<String?>? boundary,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? localityBoundaryCode,
      Value<String?>? localityBoundaryName,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<AddressType?>? type,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return AddressCompanion(
      id: id ?? this.id,
      relatedClientReferenceId:
          relatedClientReferenceId ?? this.relatedClientReferenceId,
      doorNo: doorNo ?? this.doorNo,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      locationAccuracy: locationAccuracy ?? this.locationAccuracy,
      addressLine1: addressLine1 ?? this.addressLine1,
      addressLine2: addressLine2 ?? this.addressLine2,
      landmark: landmark ?? this.landmark,
      city: city ?? this.city,
      pincode: pincode ?? this.pincode,
      buildingName: buildingName ?? this.buildingName,
      street: street ?? this.street,
      boundaryType: boundaryType ?? this.boundaryType,
      boundary: boundary ?? this.boundary,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      localityBoundaryCode: localityBoundaryCode ?? this.localityBoundaryCode,
      localityBoundaryName: localityBoundaryName ?? this.localityBoundaryName,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      type: type ?? this.type,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (relatedClientReferenceId.present) {
      map['related_client_reference_id'] =
          Variable<String>(relatedClientReferenceId.value);
    }
    if (doorNo.present) {
      map['door_no'] = Variable<String>(doorNo.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (locationAccuracy.present) {
      map['location_accuracy'] = Variable<double>(locationAccuracy.value);
    }
    if (addressLine1.present) {
      map['address_line1'] = Variable<String>(addressLine1.value);
    }
    if (addressLine2.present) {
      map['address_line2'] = Variable<String>(addressLine2.value);
    }
    if (landmark.present) {
      map['landmark'] = Variable<String>(landmark.value);
    }
    if (city.present) {
      map['city'] = Variable<String>(city.value);
    }
    if (pincode.present) {
      map['pincode'] = Variable<String>(pincode.value);
    }
    if (buildingName.present) {
      map['building_name'] = Variable<String>(buildingName.value);
    }
    if (street.present) {
      map['street'] = Variable<String>(street.value);
    }
    if (boundaryType.present) {
      map['boundary_type'] = Variable<String>(boundaryType.value);
    }
    if (boundary.present) {
      map['boundary'] = Variable<String>(boundary.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (localityBoundaryCode.present) {
      map['locality_boundary_code'] =
          Variable<String>(localityBoundaryCode.value);
    }
    if (localityBoundaryName.present) {
      map['locality_boundary_name'] =
          Variable<String>(localityBoundaryName.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (type.present) {
      map['type'] =
          Variable<int>($AddressTable.$convertertypen.toSql(type.value));
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AddressCompanion(')
          ..write('id: $id, ')
          ..write('relatedClientReferenceId: $relatedClientReferenceId, ')
          ..write('doorNo: $doorNo, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('locationAccuracy: $locationAccuracy, ')
          ..write('addressLine1: $addressLine1, ')
          ..write('addressLine2: $addressLine2, ')
          ..write('landmark: $landmark, ')
          ..write('city: $city, ')
          ..write('pincode: $pincode, ')
          ..write('buildingName: $buildingName, ')
          ..write('street: $street, ')
          ..write('boundaryType: $boundaryType, ')
          ..write('boundary: $boundary, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('localityBoundaryCode: $localityBoundaryCode, ')
          ..write('localityBoundaryName: $localityBoundaryName, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('type: $type, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $NameTable extends Name with TableInfo<$NameTable, NameData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $NameTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _individualClientReferenceIdMeta =
      const VerificationMeta('individualClientReferenceId');
  @override
  late final GeneratedColumn<String> individualClientReferenceId =
      GeneratedColumn<String>(
          'individual_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _givenNameMeta =
      const VerificationMeta('givenName');
  @override
  late final GeneratedColumn<String> givenName = GeneratedColumn<String>(
      'given_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _familyNameMeta =
      const VerificationMeta('familyName');
  @override
  late final GeneratedColumn<String> familyName = GeneratedColumn<String>(
      'family_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _otherNamesMeta =
      const VerificationMeta('otherNames');
  @override
  late final GeneratedColumn<String> otherNames = GeneratedColumn<String>(
      'other_names', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        individualClientReferenceId,
        givenName,
        familyName,
        otherNames,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'name';
  @override
  VerificationContext validateIntegrity(Insertable<NameData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('individual_client_reference_id')) {
      context.handle(
          _individualClientReferenceIdMeta,
          individualClientReferenceId.isAcceptableOrUnknown(
              data['individual_client_reference_id']!,
              _individualClientReferenceIdMeta));
    }
    if (data.containsKey('given_name')) {
      context.handle(_givenNameMeta,
          givenName.isAcceptableOrUnknown(data['given_name']!, _givenNameMeta));
    }
    if (data.containsKey('family_name')) {
      context.handle(
          _familyNameMeta,
          familyName.isAcceptableOrUnknown(
              data['family_name']!, _familyNameMeta));
    }
    if (data.containsKey('other_names')) {
      context.handle(
          _otherNamesMeta,
          otherNames.isAcceptableOrUnknown(
              data['other_names']!, _otherNamesMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey =>
      {individualClientReferenceId, auditCreatedBy};
  @override
  NameData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return NameData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      individualClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}individual_client_reference_id']),
      givenName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}given_name']),
      familyName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}family_name']),
      otherNames: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}other_names']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $NameTable createAlias(String alias) {
    return $NameTable(attachedDatabase, alias);
  }
}

class NameData extends DataClass implements Insertable<NameData> {
  final String? id;
  final String? individualClientReferenceId;
  final String? givenName;
  final String? familyName;
  final String? otherNames;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const NameData(
      {this.id,
      this.individualClientReferenceId,
      this.givenName,
      this.familyName,
      this.otherNames,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || individualClientReferenceId != null) {
      map['individual_client_reference_id'] =
          Variable<String>(individualClientReferenceId);
    }
    if (!nullToAbsent || givenName != null) {
      map['given_name'] = Variable<String>(givenName);
    }
    if (!nullToAbsent || familyName != null) {
      map['family_name'] = Variable<String>(familyName);
    }
    if (!nullToAbsent || otherNames != null) {
      map['other_names'] = Variable<String>(otherNames);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  NameCompanion toCompanion(bool nullToAbsent) {
    return NameCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      individualClientReferenceId:
          individualClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(individualClientReferenceId),
      givenName: givenName == null && nullToAbsent
          ? const Value.absent()
          : Value(givenName),
      familyName: familyName == null && nullToAbsent
          ? const Value.absent()
          : Value(familyName),
      otherNames: otherNames == null && nullToAbsent
          ? const Value.absent()
          : Value(otherNames),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory NameData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return NameData(
      id: serializer.fromJson<String?>(json['id']),
      individualClientReferenceId:
          serializer.fromJson<String?>(json['individualClientReferenceId']),
      givenName: serializer.fromJson<String?>(json['givenName']),
      familyName: serializer.fromJson<String?>(json['familyName']),
      otherNames: serializer.fromJson<String?>(json['otherNames']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'individualClientReferenceId':
          serializer.toJson<String?>(individualClientReferenceId),
      'givenName': serializer.toJson<String?>(givenName),
      'familyName': serializer.toJson<String?>(familyName),
      'otherNames': serializer.toJson<String?>(otherNames),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  NameData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> individualClientReferenceId = const Value.absent(),
          Value<String?> givenName = const Value.absent(),
          Value<String?> familyName = const Value.absent(),
          Value<String?> otherNames = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      NameData(
        id: id.present ? id.value : this.id,
        individualClientReferenceId: individualClientReferenceId.present
            ? individualClientReferenceId.value
            : this.individualClientReferenceId,
        givenName: givenName.present ? givenName.value : this.givenName,
        familyName: familyName.present ? familyName.value : this.familyName,
        otherNames: otherNames.present ? otherNames.value : this.otherNames,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('NameData(')
          ..write('id: $id, ')
          ..write('individualClientReferenceId: $individualClientReferenceId, ')
          ..write('givenName: $givenName, ')
          ..write('familyName: $familyName, ')
          ..write('otherNames: $otherNames, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      individualClientReferenceId,
      givenName,
      familyName,
      otherNames,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is NameData &&
          other.id == this.id &&
          other.individualClientReferenceId ==
              this.individualClientReferenceId &&
          other.givenName == this.givenName &&
          other.familyName == this.familyName &&
          other.otherNames == this.otherNames &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class NameCompanion extends UpdateCompanion<NameData> {
  final Value<String?> id;
  final Value<String?> individualClientReferenceId;
  final Value<String?> givenName;
  final Value<String?> familyName;
  final Value<String?> otherNames;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const NameCompanion({
    this.id = const Value.absent(),
    this.individualClientReferenceId = const Value.absent(),
    this.givenName = const Value.absent(),
    this.familyName = const Value.absent(),
    this.otherNames = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  NameCompanion.insert({
    this.id = const Value.absent(),
    this.individualClientReferenceId = const Value.absent(),
    this.givenName = const Value.absent(),
    this.familyName = const Value.absent(),
    this.otherNames = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<NameData> custom({
    Expression<String>? id,
    Expression<String>? individualClientReferenceId,
    Expression<String>? givenName,
    Expression<String>? familyName,
    Expression<String>? otherNames,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (individualClientReferenceId != null)
        'individual_client_reference_id': individualClientReferenceId,
      if (givenName != null) 'given_name': givenName,
      if (familyName != null) 'family_name': familyName,
      if (otherNames != null) 'other_names': otherNames,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  NameCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? individualClientReferenceId,
      Value<String?>? givenName,
      Value<String?>? familyName,
      Value<String?>? otherNames,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return NameCompanion(
      id: id ?? this.id,
      individualClientReferenceId:
          individualClientReferenceId ?? this.individualClientReferenceId,
      givenName: givenName ?? this.givenName,
      familyName: familyName ?? this.familyName,
      otherNames: otherNames ?? this.otherNames,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (individualClientReferenceId.present) {
      map['individual_client_reference_id'] =
          Variable<String>(individualClientReferenceId.value);
    }
    if (givenName.present) {
      map['given_name'] = Variable<String>(givenName.value);
    }
    if (familyName.present) {
      map['family_name'] = Variable<String>(familyName.value);
    }
    if (otherNames.present) {
      map['other_names'] = Variable<String>(otherNames.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NameCompanion(')
          ..write('id: $id, ')
          ..write('individualClientReferenceId: $individualClientReferenceId, ')
          ..write('givenName: $givenName, ')
          ..write('familyName: $familyName, ')
          ..write('otherNames: $otherNames, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BoundaryTable extends Boundary
    with TableInfo<$BoundaryTable, BoundaryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BoundaryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _labelMeta = const VerificationMeta('label');
  @override
  late final GeneratedColumn<String> label = GeneratedColumn<String>(
      'label', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<String> latitude = GeneratedColumn<String>(
      'latitude', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<String> longitude = GeneratedColumn<String>(
      'longitude', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _materializedPathMeta =
      const VerificationMeta('materializedPath');
  @override
  late final GeneratedColumn<String> materializedPath = GeneratedColumn<String>(
      'materialized_path', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _boundaryNumMeta =
      const VerificationMeta('boundaryNum');
  @override
  late final GeneratedColumn<int> boundaryNum = GeneratedColumn<int>(
      'boundary_num', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        code,
        name,
        label,
        latitude,
        longitude,
        materializedPath,
        auditCreatedBy,
        boundaryNum,
        auditCreatedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'boundary';
  @override
  VerificationContext validateIntegrity(Insertable<BoundaryData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('label')) {
      context.handle(
          _labelMeta, label.isAcceptableOrUnknown(data['label']!, _labelMeta));
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    }
    if (data.containsKey('materialized_path')) {
      context.handle(
          _materializedPathMeta,
          materializedPath.isAcceptableOrUnknown(
              data['materialized_path']!, _materializedPathMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('boundary_num')) {
      context.handle(
          _boundaryNumMeta,
          boundaryNum.isAcceptableOrUnknown(
              data['boundary_num']!, _boundaryNumMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code};
  @override
  BoundaryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BoundaryData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      label: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}label']),
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}latitude']),
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}longitude']),
      materializedPath: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}materialized_path']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      boundaryNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}boundary_num']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
    );
  }

  @override
  $BoundaryTable createAlias(String alias) {
    return $BoundaryTable(attachedDatabase, alias);
  }
}

class BoundaryData extends DataClass implements Insertable<BoundaryData> {
  final String? code;
  final String? name;
  final String? label;
  final String? latitude;
  final String? longitude;
  final String? materializedPath;
  final String? auditCreatedBy;
  final int? boundaryNum;
  final int? auditCreatedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  const BoundaryData(
      {this.code,
      this.name,
      this.label,
      this.latitude,
      this.longitude,
      this.materializedPath,
      this.auditCreatedBy,
      this.boundaryNum,
      this.auditCreatedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || label != null) {
      map['label'] = Variable<String>(label);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<String>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<String>(longitude);
    }
    if (!nullToAbsent || materializedPath != null) {
      map['materialized_path'] = Variable<String>(materializedPath);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || boundaryNum != null) {
      map['boundary_num'] = Variable<int>(boundaryNum);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    return map;
  }

  BoundaryCompanion toCompanion(bool nullToAbsent) {
    return BoundaryCompanion(
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      materializedPath: materializedPath == null && nullToAbsent
          ? const Value.absent()
          : Value(materializedPath),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      boundaryNum: boundaryNum == null && nullToAbsent
          ? const Value.absent()
          : Value(boundaryNum),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
    );
  }

  factory BoundaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BoundaryData(
      code: serializer.fromJson<String?>(json['code']),
      name: serializer.fromJson<String?>(json['name']),
      label: serializer.fromJson<String?>(json['label']),
      latitude: serializer.fromJson<String?>(json['latitude']),
      longitude: serializer.fromJson<String?>(json['longitude']),
      materializedPath: serializer.fromJson<String?>(json['materializedPath']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      boundaryNum: serializer.fromJson<int?>(json['boundaryNum']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String?>(code),
      'name': serializer.toJson<String?>(name),
      'label': serializer.toJson<String?>(label),
      'latitude': serializer.toJson<String?>(latitude),
      'longitude': serializer.toJson<String?>(longitude),
      'materializedPath': serializer.toJson<String?>(materializedPath),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'boundaryNum': serializer.toJson<int?>(boundaryNum),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
    };
  }

  BoundaryData copyWith(
          {Value<String?> code = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<String?> label = const Value.absent(),
          Value<String?> latitude = const Value.absent(),
          Value<String?> longitude = const Value.absent(),
          Value<String?> materializedPath = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<int?> boundaryNum = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent()}) =>
      BoundaryData(
        code: code.present ? code.value : this.code,
        name: name.present ? name.value : this.name,
        label: label.present ? label.value : this.label,
        latitude: latitude.present ? latitude.value : this.latitude,
        longitude: longitude.present ? longitude.value : this.longitude,
        materializedPath: materializedPath.present
            ? materializedPath.value
            : this.materializedPath,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        boundaryNum: boundaryNum.present ? boundaryNum.value : this.boundaryNum,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
      );
  @override
  String toString() {
    return (StringBuffer('BoundaryData(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('label: $label, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('materializedPath: $materializedPath, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('boundaryNum: $boundaryNum, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      code,
      name,
      label,
      latitude,
      longitude,
      materializedPath,
      auditCreatedBy,
      boundaryNum,
      auditCreatedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BoundaryData &&
          other.code == this.code &&
          other.name == this.name &&
          other.label == this.label &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.materializedPath == this.materializedPath &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.boundaryNum == this.boundaryNum &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion);
}

class BoundaryCompanion extends UpdateCompanion<BoundaryData> {
  final Value<String?> code;
  final Value<String?> name;
  final Value<String?> label;
  final Value<String?> latitude;
  final Value<String?> longitude;
  final Value<String?> materializedPath;
  final Value<String?> auditCreatedBy;
  final Value<int?> boundaryNum;
  final Value<int?> auditCreatedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int> rowid;
  const BoundaryCompanion({
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.label = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.materializedPath = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.boundaryNum = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BoundaryCompanion.insert({
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.label = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.materializedPath = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.boundaryNum = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<BoundaryData> custom({
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? label,
    Expression<String>? latitude,
    Expression<String>? longitude,
    Expression<String>? materializedPath,
    Expression<String>? auditCreatedBy,
    Expression<int>? boundaryNum,
    Expression<int>? auditCreatedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (label != null) 'label': label,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (materializedPath != null) 'materialized_path': materializedPath,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (boundaryNum != null) 'boundary_num': boundaryNum,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BoundaryCompanion copyWith(
      {Value<String?>? code,
      Value<String?>? name,
      Value<String?>? label,
      Value<String?>? latitude,
      Value<String?>? longitude,
      Value<String?>? materializedPath,
      Value<String?>? auditCreatedBy,
      Value<int?>? boundaryNum,
      Value<int?>? auditCreatedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int>? rowid}) {
    return BoundaryCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      label: label ?? this.label,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      materializedPath: materializedPath ?? this.materializedPath,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      boundaryNum: boundaryNum ?? this.boundaryNum,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (label.present) {
      map['label'] = Variable<String>(label.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<String>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<String>(longitude.value);
    }
    if (materializedPath.present) {
      map['materialized_path'] = Variable<String>(materializedPath.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (boundaryNum.present) {
      map['boundary_num'] = Variable<int>(boundaryNum.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BoundaryCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('label: $label, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('materializedPath: $materializedPath, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('boundaryNum: $boundaryNum, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DocumentTable extends Document
    with TableInfo<$DocumentTable, DocumentData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DocumentTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _documentTypeMeta =
      const VerificationMeta('documentType');
  @override
  late final GeneratedColumn<String> documentType = GeneratedColumn<String>(
      'document_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fileStoreIdMeta =
      const VerificationMeta('fileStoreId');
  @override
  late final GeneratedColumn<String> fileStoreId = GeneratedColumn<String>(
      'file_store_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _documentUidMeta =
      const VerificationMeta('documentUid');
  @override
  late final GeneratedColumn<String> documentUid = GeneratedColumn<String>(
      'document_uid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        documentType,
        fileStoreId,
        documentUid,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'document';
  @override
  VerificationContext validateIntegrity(Insertable<DocumentData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('document_type')) {
      context.handle(
          _documentTypeMeta,
          documentType.isAcceptableOrUnknown(
              data['document_type']!, _documentTypeMeta));
    }
    if (data.containsKey('file_store_id')) {
      context.handle(
          _fileStoreIdMeta,
          fileStoreId.isAcceptableOrUnknown(
              data['file_store_id']!, _fileStoreIdMeta));
    }
    if (data.containsKey('document_uid')) {
      context.handle(
          _documentUidMeta,
          documentUid.isAcceptableOrUnknown(
              data['document_uid']!, _documentUidMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  DocumentData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DocumentData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      documentType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}document_type']),
      fileStoreId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}file_store_id']),
      documentUid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}document_uid']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $DocumentTable createAlias(String alias) {
    return $DocumentTable(attachedDatabase, alias);
  }
}

class DocumentData extends DataClass implements Insertable<DocumentData> {
  final String? id;
  final String? documentType;
  final String? fileStoreId;
  final String? documentUid;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const DocumentData(
      {this.id,
      this.documentType,
      this.fileStoreId,
      this.documentUid,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || documentType != null) {
      map['document_type'] = Variable<String>(documentType);
    }
    if (!nullToAbsent || fileStoreId != null) {
      map['file_store_id'] = Variable<String>(fileStoreId);
    }
    if (!nullToAbsent || documentUid != null) {
      map['document_uid'] = Variable<String>(documentUid);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  DocumentCompanion toCompanion(bool nullToAbsent) {
    return DocumentCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      documentType: documentType == null && nullToAbsent
          ? const Value.absent()
          : Value(documentType),
      fileStoreId: fileStoreId == null && nullToAbsent
          ? const Value.absent()
          : Value(fileStoreId),
      documentUid: documentUid == null && nullToAbsent
          ? const Value.absent()
          : Value(documentUid),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory DocumentData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DocumentData(
      id: serializer.fromJson<String?>(json['id']),
      documentType: serializer.fromJson<String?>(json['documentType']),
      fileStoreId: serializer.fromJson<String?>(json['fileStoreId']),
      documentUid: serializer.fromJson<String?>(json['documentUid']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'documentType': serializer.toJson<String?>(documentType),
      'fileStoreId': serializer.toJson<String?>(fileStoreId),
      'documentUid': serializer.toJson<String?>(documentUid),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  DocumentData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> documentType = const Value.absent(),
          Value<String?> fileStoreId = const Value.absent(),
          Value<String?> documentUid = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      DocumentData(
        id: id.present ? id.value : this.id,
        documentType:
            documentType.present ? documentType.value : this.documentType,
        fileStoreId: fileStoreId.present ? fileStoreId.value : this.fileStoreId,
        documentUid: documentUid.present ? documentUid.value : this.documentUid,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('DocumentData(')
          ..write('id: $id, ')
          ..write('documentType: $documentType, ')
          ..write('fileStoreId: $fileStoreId, ')
          ..write('documentUid: $documentUid, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      documentType,
      fileStoreId,
      documentUid,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DocumentData &&
          other.id == this.id &&
          other.documentType == this.documentType &&
          other.fileStoreId == this.fileStoreId &&
          other.documentUid == this.documentUid &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class DocumentCompanion extends UpdateCompanion<DocumentData> {
  final Value<String?> id;
  final Value<String?> documentType;
  final Value<String?> fileStoreId;
  final Value<String?> documentUid;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const DocumentCompanion({
    this.id = const Value.absent(),
    this.documentType = const Value.absent(),
    this.fileStoreId = const Value.absent(),
    this.documentUid = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DocumentCompanion.insert({
    this.id = const Value.absent(),
    this.documentType = const Value.absent(),
    this.fileStoreId = const Value.absent(),
    this.documentUid = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<DocumentData> custom({
    Expression<String>? id,
    Expression<String>? documentType,
    Expression<String>? fileStoreId,
    Expression<String>? documentUid,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (documentType != null) 'document_type': documentType,
      if (fileStoreId != null) 'file_store_id': fileStoreId,
      if (documentUid != null) 'document_uid': documentUid,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DocumentCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? documentType,
      Value<String?>? fileStoreId,
      Value<String?>? documentUid,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return DocumentCompanion(
      id: id ?? this.id,
      documentType: documentType ?? this.documentType,
      fileStoreId: fileStoreId ?? this.fileStoreId,
      documentUid: documentUid ?? this.documentUid,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (documentType.present) {
      map['document_type'] = Variable<String>(documentType.value);
    }
    if (fileStoreId.present) {
      map['file_store_id'] = Variable<String>(fileStoreId.value);
    }
    if (documentUid.present) {
      map['document_uid'] = Variable<String>(documentUid.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DocumentCompanion(')
          ..write('id: $id, ')
          ..write('documentType: $documentType, ')
          ..write('fileStoreId: $fileStoreId, ')
          ..write('documentUid: $documentUid, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FacilityTable extends Facility
    with TableInfo<$FacilityTable, FacilityData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FacilityTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isPermanentMeta =
      const VerificationMeta('isPermanent');
  @override
  late final GeneratedColumn<bool> isPermanent = GeneratedColumn<bool>(
      'is_permanent', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_permanent" IN (0, 1))'));
  static const VerificationMeta _usageMeta = const VerificationMeta('usage');
  @override
  late final GeneratedColumn<String> usage = GeneratedColumn<String>(
      'usage', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _storageCapacityMeta =
      const VerificationMeta('storageCapacity');
  @override
  late final GeneratedColumn<int> storageCapacity = GeneratedColumn<int>(
      'storage_capacity', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        isPermanent,
        usage,
        storageCapacity,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        name,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'facility';
  @override
  VerificationContext validateIntegrity(Insertable<FacilityData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('is_permanent')) {
      context.handle(
          _isPermanentMeta,
          isPermanent.isAcceptableOrUnknown(
              data['is_permanent']!, _isPermanentMeta));
    }
    if (data.containsKey('usage')) {
      context.handle(
          _usageMeta, usage.isAcceptableOrUnknown(data['usage']!, _usageMeta));
    }
    if (data.containsKey('storage_capacity')) {
      context.handle(
          _storageCapacityMeta,
          storageCapacity.isAcceptableOrUnknown(
              data['storage_capacity']!, _storageCapacityMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  FacilityData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FacilityData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      isPermanent: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_permanent']),
      usage: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}usage']),
      storageCapacity: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}storage_capacity']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $FacilityTable createAlias(String alias) {
    return $FacilityTable(attachedDatabase, alias);
  }
}

class FacilityData extends DataClass implements Insertable<FacilityData> {
  final String id;
  final bool? isPermanent;
  final String? usage;
  final int? storageCapacity;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final String? name;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const FacilityData(
      {required this.id,
      this.isPermanent,
      this.usage,
      this.storageCapacity,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.name,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || isPermanent != null) {
      map['is_permanent'] = Variable<bool>(isPermanent);
    }
    if (!nullToAbsent || usage != null) {
      map['usage'] = Variable<String>(usage);
    }
    if (!nullToAbsent || storageCapacity != null) {
      map['storage_capacity'] = Variable<int>(storageCapacity);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  FacilityCompanion toCompanion(bool nullToAbsent) {
    return FacilityCompanion(
      id: Value(id),
      isPermanent: isPermanent == null && nullToAbsent
          ? const Value.absent()
          : Value(isPermanent),
      usage:
          usage == null && nullToAbsent ? const Value.absent() : Value(usage),
      storageCapacity: storageCapacity == null && nullToAbsent
          ? const Value.absent()
          : Value(storageCapacity),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory FacilityData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FacilityData(
      id: serializer.fromJson<String>(json['id']),
      isPermanent: serializer.fromJson<bool?>(json['isPermanent']),
      usage: serializer.fromJson<String?>(json['usage']),
      storageCapacity: serializer.fromJson<int?>(json['storageCapacity']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      name: serializer.fromJson<String?>(json['name']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'isPermanent': serializer.toJson<bool?>(isPermanent),
      'usage': serializer.toJson<String?>(usage),
      'storageCapacity': serializer.toJson<int?>(storageCapacity),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'name': serializer.toJson<String?>(name),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  FacilityData copyWith(
          {String? id,
          Value<bool?> isPermanent = const Value.absent(),
          Value<String?> usage = const Value.absent(),
          Value<int?> storageCapacity = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      FacilityData(
        id: id ?? this.id,
        isPermanent: isPermanent.present ? isPermanent.value : this.isPermanent,
        usage: usage.present ? usage.value : this.usage,
        storageCapacity: storageCapacity.present
            ? storageCapacity.value
            : this.storageCapacity,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        name: name.present ? name.value : this.name,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('FacilityData(')
          ..write('id: $id, ')
          ..write('isPermanent: $isPermanent, ')
          ..write('usage: $usage, ')
          ..write('storageCapacity: $storageCapacity, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('name: $name, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      isPermanent,
      usage,
      storageCapacity,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      name,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FacilityData &&
          other.id == this.id &&
          other.isPermanent == this.isPermanent &&
          other.usage == this.usage &&
          other.storageCapacity == this.storageCapacity &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.name == this.name &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class FacilityCompanion extends UpdateCompanion<FacilityData> {
  final Value<String> id;
  final Value<bool?> isPermanent;
  final Value<String?> usage;
  final Value<int?> storageCapacity;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<String?> name;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const FacilityCompanion({
    this.id = const Value.absent(),
    this.isPermanent = const Value.absent(),
    this.usage = const Value.absent(),
    this.storageCapacity = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.name = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FacilityCompanion.insert({
    required String id,
    this.isPermanent = const Value.absent(),
    this.usage = const Value.absent(),
    this.storageCapacity = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.name = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<FacilityData> custom({
    Expression<String>? id,
    Expression<bool>? isPermanent,
    Expression<String>? usage,
    Expression<int>? storageCapacity,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<String>? name,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (isPermanent != null) 'is_permanent': isPermanent,
      if (usage != null) 'usage': usage,
      if (storageCapacity != null) 'storage_capacity': storageCapacity,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (name != null) 'name': name,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FacilityCompanion copyWith(
      {Value<String>? id,
      Value<bool?>? isPermanent,
      Value<String?>? usage,
      Value<int?>? storageCapacity,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<String?>? name,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return FacilityCompanion(
      id: id ?? this.id,
      isPermanent: isPermanent ?? this.isPermanent,
      usage: usage ?? this.usage,
      storageCapacity: storageCapacity ?? this.storageCapacity,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      name: name ?? this.name,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (isPermanent.present) {
      map['is_permanent'] = Variable<bool>(isPermanent.value);
    }
    if (usage.present) {
      map['usage'] = Variable<String>(usage.value);
    }
    if (storageCapacity.present) {
      map['storage_capacity'] = Variable<int>(storageCapacity.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FacilityCompanion(')
          ..write('id: $id, ')
          ..write('isPermanent: $isPermanent, ')
          ..write('usage: $usage, ')
          ..write('storageCapacity: $storageCapacity, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('name: $name, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProductTable extends Product with TableInfo<$ProductTable, ProductData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _manufacturerMeta =
      const VerificationMeta('manufacturer');
  @override
  late final GeneratedColumn<String> manufacturer = GeneratedColumn<String>(
      'manufacturer', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        type,
        name,
        manufacturer,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'product';
  @override
  VerificationContext validateIntegrity(Insertable<ProductData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('manufacturer')) {
      context.handle(
          _manufacturerMeta,
          manufacturer.isAcceptableOrUnknown(
              data['manufacturer']!, _manufacturerMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  ProductData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProductData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      manufacturer: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}manufacturer']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProductTable createAlias(String alias) {
    return $ProductTable(attachedDatabase, alias);
  }
}

class ProductData extends DataClass implements Insertable<ProductData> {
  final String? id;
  final String? type;
  final String? name;
  final String? manufacturer;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ProductData(
      {this.id,
      this.type,
      this.name,
      this.manufacturer,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || manufacturer != null) {
      map['manufacturer'] = Variable<String>(manufacturer);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProductCompanion toCompanion(bool nullToAbsent) {
    return ProductCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      manufacturer: manufacturer == null && nullToAbsent
          ? const Value.absent()
          : Value(manufacturer),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProductData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProductData(
      id: serializer.fromJson<String?>(json['id']),
      type: serializer.fromJson<String?>(json['type']),
      name: serializer.fromJson<String?>(json['name']),
      manufacturer: serializer.fromJson<String?>(json['manufacturer']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'type': serializer.toJson<String?>(type),
      'name': serializer.toJson<String?>(name),
      'manufacturer': serializer.toJson<String?>(manufacturer),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProductData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<String?> manufacturer = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProductData(
        id: id.present ? id.value : this.id,
        type: type.present ? type.value : this.type,
        name: name.present ? name.value : this.name,
        manufacturer:
            manufacturer.present ? manufacturer.value : this.manufacturer,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProductData(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('name: $name, ')
          ..write('manufacturer: $manufacturer, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      type,
      name,
      manufacturer,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProductData &&
          other.id == this.id &&
          other.type == this.type &&
          other.name == this.name &&
          other.manufacturer == this.manufacturer &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ProductCompanion extends UpdateCompanion<ProductData> {
  final Value<String?> id;
  final Value<String?> type;
  final Value<String?> name;
  final Value<String?> manufacturer;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProductCompanion({
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.name = const Value.absent(),
    this.manufacturer = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProductCompanion.insert({
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.name = const Value.absent(),
    this.manufacturer = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<ProductData> custom({
    Expression<String>? id,
    Expression<String>? type,
    Expression<String>? name,
    Expression<String>? manufacturer,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (type != null) 'type': type,
      if (name != null) 'name': name,
      if (manufacturer != null) 'manufacturer': manufacturer,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProductCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? type,
      Value<String?>? name,
      Value<String?>? manufacturer,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProductCompanion(
      id: id ?? this.id,
      type: type ?? this.type,
      name: name ?? this.name,
      manufacturer: manufacturer ?? this.manufacturer,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (manufacturer.present) {
      map['manufacturer'] = Variable<String>(manufacturer.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductCompanion(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('name: $name, ')
          ..write('manufacturer: $manufacturer, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProductVariantTable extends ProductVariant
    with TableInfo<$ProductVariantTable, ProductVariantData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductVariantTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _productIdMeta =
      const VerificationMeta('productId');
  @override
  late final GeneratedColumn<String> productId = GeneratedColumn<String>(
      'product_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _skuMeta = const VerificationMeta('sku');
  @override
  late final GeneratedColumn<String> sku = GeneratedColumn<String>(
      'sku', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _variationMeta =
      const VerificationMeta('variation');
  @override
  late final GeneratedColumn<String> variation = GeneratedColumn<String>(
      'variation', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        productId,
        sku,
        variation,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'product_variant';
  @override
  VerificationContext validateIntegrity(Insertable<ProductVariantData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(_productIdMeta,
          productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta));
    }
    if (data.containsKey('sku')) {
      context.handle(
          _skuMeta, sku.isAcceptableOrUnknown(data['sku']!, _skuMeta));
    }
    if (data.containsKey('variation')) {
      context.handle(_variationMeta,
          variation.isAcceptableOrUnknown(data['variation']!, _variationMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  ProductVariantData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProductVariantData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      productId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_id']),
      sku: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sku']),
      variation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}variation']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProductVariantTable createAlias(String alias) {
    return $ProductVariantTable(attachedDatabase, alias);
  }
}

class ProductVariantData extends DataClass
    implements Insertable<ProductVariantData> {
  final String id;
  final String? productId;
  final String? sku;
  final String? variation;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ProductVariantData(
      {required this.id,
      this.productId,
      this.sku,
      this.variation,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || productId != null) {
      map['product_id'] = Variable<String>(productId);
    }
    if (!nullToAbsent || sku != null) {
      map['sku'] = Variable<String>(sku);
    }
    if (!nullToAbsent || variation != null) {
      map['variation'] = Variable<String>(variation);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProductVariantCompanion toCompanion(bool nullToAbsent) {
    return ProductVariantCompanion(
      id: Value(id),
      productId: productId == null && nullToAbsent
          ? const Value.absent()
          : Value(productId),
      sku: sku == null && nullToAbsent ? const Value.absent() : Value(sku),
      variation: variation == null && nullToAbsent
          ? const Value.absent()
          : Value(variation),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProductVariantData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProductVariantData(
      id: serializer.fromJson<String>(json['id']),
      productId: serializer.fromJson<String?>(json['productId']),
      sku: serializer.fromJson<String?>(json['sku']),
      variation: serializer.fromJson<String?>(json['variation']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'productId': serializer.toJson<String?>(productId),
      'sku': serializer.toJson<String?>(sku),
      'variation': serializer.toJson<String?>(variation),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProductVariantData copyWith(
          {String? id,
          Value<String?> productId = const Value.absent(),
          Value<String?> sku = const Value.absent(),
          Value<String?> variation = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProductVariantData(
        id: id ?? this.id,
        productId: productId.present ? productId.value : this.productId,
        sku: sku.present ? sku.value : this.sku,
        variation: variation.present ? variation.value : this.variation,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProductVariantData(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('sku: $sku, ')
          ..write('variation: $variation, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      productId,
      sku,
      variation,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProductVariantData &&
          other.id == this.id &&
          other.productId == this.productId &&
          other.sku == this.sku &&
          other.variation == this.variation &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ProductVariantCompanion extends UpdateCompanion<ProductVariantData> {
  final Value<String> id;
  final Value<String?> productId;
  final Value<String?> sku;
  final Value<String?> variation;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProductVariantCompanion({
    this.id = const Value.absent(),
    this.productId = const Value.absent(),
    this.sku = const Value.absent(),
    this.variation = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProductVariantCompanion.insert({
    required String id,
    this.productId = const Value.absent(),
    this.sku = const Value.absent(),
    this.variation = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<ProductVariantData> custom({
    Expression<String>? id,
    Expression<String>? productId,
    Expression<String>? sku,
    Expression<String>? variation,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productId != null) 'product_id': productId,
      if (sku != null) 'sku': sku,
      if (variation != null) 'variation': variation,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProductVariantCompanion copyWith(
      {Value<String>? id,
      Value<String?>? productId,
      Value<String?>? sku,
      Value<String?>? variation,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProductVariantCompanion(
      id: id ?? this.id,
      productId: productId ?? this.productId,
      sku: sku ?? this.sku,
      variation: variation ?? this.variation,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<String>(productId.value);
    }
    if (sku.present) {
      map['sku'] = Variable<String>(sku.value);
    }
    if (variation.present) {
      map['variation'] = Variable<String>(variation.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductVariantCompanion(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('sku: $sku, ')
          ..write('variation: $variation, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectTable extends Project with TableInfo<$ProjectTable, ProjectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _projectTypeMeta =
      const VerificationMeta('projectType');
  @override
  late final GeneratedColumn<String> projectType = GeneratedColumn<String>(
      'project_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _projectTypeIdMeta =
      const VerificationMeta('projectTypeId');
  @override
  late final GeneratedColumn<String> projectTypeId = GeneratedColumn<String>(
      'project_type_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectNumberMeta =
      const VerificationMeta('projectNumber');
  @override
  late final GeneratedColumn<String> projectNumber = GeneratedColumn<String>(
      'project_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _subProjectTypeIdMeta =
      const VerificationMeta('subProjectTypeId');
  @override
  late final GeneratedColumn<String> subProjectTypeId = GeneratedColumn<String>(
      'sub_project_type_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isTaskEnabledMeta =
      const VerificationMeta('isTaskEnabled');
  @override
  late final GeneratedColumn<bool> isTaskEnabled = GeneratedColumn<bool>(
      'is_task_enabled', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_task_enabled" IN (0, 1))'));
  static const VerificationMeta _parentMeta = const VerificationMeta('parent');
  @override
  late final GeneratedColumn<String> parent = GeneratedColumn<String>(
      'parent', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _departmentMeta =
      const VerificationMeta('department');
  @override
  late final GeneratedColumn<String> department = GeneratedColumn<String>(
      'department', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectHierarchyMeta =
      const VerificationMeta('projectHierarchy');
  @override
  late final GeneratedColumn<String> projectHierarchy = GeneratedColumn<String>(
      'project_hierarchy', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _startDateMeta =
      const VerificationMeta('startDate');
  @override
  late final GeneratedColumn<int> startDate = GeneratedColumn<int>(
      'start_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _endDateMeta =
      const VerificationMeta('endDate');
  @override
  late final GeneratedColumn<int> endDate = GeneratedColumn<int>(
      'end_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        projectType,
        id,
        projectTypeId,
        projectNumber,
        subProjectTypeId,
        isTaskEnabled,
        parent,
        name,
        department,
        description,
        referenceId,
        projectHierarchy,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        startDate,
        endDate,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project';
  @override
  VerificationContext validateIntegrity(Insertable<ProjectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('project_type')) {
      context.handle(
          _projectTypeMeta,
          projectType.isAcceptableOrUnknown(
              data['project_type']!, _projectTypeMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('project_type_id')) {
      context.handle(
          _projectTypeIdMeta,
          projectTypeId.isAcceptableOrUnknown(
              data['project_type_id']!, _projectTypeIdMeta));
    }
    if (data.containsKey('project_number')) {
      context.handle(
          _projectNumberMeta,
          projectNumber.isAcceptableOrUnknown(
              data['project_number']!, _projectNumberMeta));
    }
    if (data.containsKey('sub_project_type_id')) {
      context.handle(
          _subProjectTypeIdMeta,
          subProjectTypeId.isAcceptableOrUnknown(
              data['sub_project_type_id']!, _subProjectTypeIdMeta));
    }
    if (data.containsKey('is_task_enabled')) {
      context.handle(
          _isTaskEnabledMeta,
          isTaskEnabled.isAcceptableOrUnknown(
              data['is_task_enabled']!, _isTaskEnabledMeta));
    }
    if (data.containsKey('parent')) {
      context.handle(_parentMeta,
          parent.isAcceptableOrUnknown(data['parent']!, _parentMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('department')) {
      context.handle(
          _departmentMeta,
          department.isAcceptableOrUnknown(
              data['department']!, _departmentMeta));
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    }
    if (data.containsKey('project_hierarchy')) {
      context.handle(
          _projectHierarchyMeta,
          projectHierarchy.isAcceptableOrUnknown(
              data['project_hierarchy']!, _projectHierarchyMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  ProjectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectData(
      projectType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_type']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      projectTypeId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_type_id']),
      projectNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_number']),
      subProjectTypeId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}sub_project_type_id']),
      isTaskEnabled: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_task_enabled']),
      parent: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}parent']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      department: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}department']),
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id']),
      projectHierarchy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}project_hierarchy']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      startDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}start_date']),
      endDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}end_date']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectTable createAlias(String alias) {
    return $ProjectTable(attachedDatabase, alias);
  }
}

class ProjectData extends DataClass implements Insertable<ProjectData> {
  final String? projectType;
  final String id;
  final String? projectTypeId;
  final String? projectNumber;
  final String? subProjectTypeId;
  final bool? isTaskEnabled;
  final String? parent;
  final String name;
  final String? department;
  final String? description;
  final String? referenceId;
  final String? projectHierarchy;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final int? startDate;
  final int? endDate;
  final String? additionalFields;
  const ProjectData(
      {this.projectType,
      required this.id,
      this.projectTypeId,
      this.projectNumber,
      this.subProjectTypeId,
      this.isTaskEnabled,
      this.parent,
      required this.name,
      this.department,
      this.description,
      this.referenceId,
      this.projectHierarchy,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.startDate,
      this.endDate,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || projectType != null) {
      map['project_type'] = Variable<String>(projectType);
    }
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || projectTypeId != null) {
      map['project_type_id'] = Variable<String>(projectTypeId);
    }
    if (!nullToAbsent || projectNumber != null) {
      map['project_number'] = Variable<String>(projectNumber);
    }
    if (!nullToAbsent || subProjectTypeId != null) {
      map['sub_project_type_id'] = Variable<String>(subProjectTypeId);
    }
    if (!nullToAbsent || isTaskEnabled != null) {
      map['is_task_enabled'] = Variable<bool>(isTaskEnabled);
    }
    if (!nullToAbsent || parent != null) {
      map['parent'] = Variable<String>(parent);
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || department != null) {
      map['department'] = Variable<String>(department);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    if (!nullToAbsent || projectHierarchy != null) {
      map['project_hierarchy'] = Variable<String>(projectHierarchy);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || startDate != null) {
      map['start_date'] = Variable<int>(startDate);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<int>(endDate);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectCompanion toCompanion(bool nullToAbsent) {
    return ProjectCompanion(
      projectType: projectType == null && nullToAbsent
          ? const Value.absent()
          : Value(projectType),
      id: Value(id),
      projectTypeId: projectTypeId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectTypeId),
      projectNumber: projectNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(projectNumber),
      subProjectTypeId: subProjectTypeId == null && nullToAbsent
          ? const Value.absent()
          : Value(subProjectTypeId),
      isTaskEnabled: isTaskEnabled == null && nullToAbsent
          ? const Value.absent()
          : Value(isTaskEnabled),
      parent:
          parent == null && nullToAbsent ? const Value.absent() : Value(parent),
      name: Value(name),
      department: department == null && nullToAbsent
          ? const Value.absent()
          : Value(department),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      projectHierarchy: projectHierarchy == null && nullToAbsent
          ? const Value.absent()
          : Value(projectHierarchy),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      startDate: startDate == null && nullToAbsent
          ? const Value.absent()
          : Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectData(
      projectType: serializer.fromJson<String?>(json['projectType']),
      id: serializer.fromJson<String>(json['id']),
      projectTypeId: serializer.fromJson<String?>(json['projectTypeId']),
      projectNumber: serializer.fromJson<String?>(json['projectNumber']),
      subProjectTypeId: serializer.fromJson<String?>(json['subProjectTypeId']),
      isTaskEnabled: serializer.fromJson<bool?>(json['isTaskEnabled']),
      parent: serializer.fromJson<String?>(json['parent']),
      name: serializer.fromJson<String>(json['name']),
      department: serializer.fromJson<String?>(json['department']),
      description: serializer.fromJson<String?>(json['description']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      projectHierarchy: serializer.fromJson<String?>(json['projectHierarchy']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      startDate: serializer.fromJson<int?>(json['startDate']),
      endDate: serializer.fromJson<int?>(json['endDate']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'projectType': serializer.toJson<String?>(projectType),
      'id': serializer.toJson<String>(id),
      'projectTypeId': serializer.toJson<String?>(projectTypeId),
      'projectNumber': serializer.toJson<String?>(projectNumber),
      'subProjectTypeId': serializer.toJson<String?>(subProjectTypeId),
      'isTaskEnabled': serializer.toJson<bool?>(isTaskEnabled),
      'parent': serializer.toJson<String?>(parent),
      'name': serializer.toJson<String>(name),
      'department': serializer.toJson<String?>(department),
      'description': serializer.toJson<String?>(description),
      'referenceId': serializer.toJson<String?>(referenceId),
      'projectHierarchy': serializer.toJson<String?>(projectHierarchy),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'startDate': serializer.toJson<int?>(startDate),
      'endDate': serializer.toJson<int?>(endDate),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectData copyWith(
          {Value<String?> projectType = const Value.absent(),
          String? id,
          Value<String?> projectTypeId = const Value.absent(),
          Value<String?> projectNumber = const Value.absent(),
          Value<String?> subProjectTypeId = const Value.absent(),
          Value<bool?> isTaskEnabled = const Value.absent(),
          Value<String?> parent = const Value.absent(),
          String? name,
          Value<String?> department = const Value.absent(),
          Value<String?> description = const Value.absent(),
          Value<String?> referenceId = const Value.absent(),
          Value<String?> projectHierarchy = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<int?> startDate = const Value.absent(),
          Value<int?> endDate = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectData(
        projectType: projectType.present ? projectType.value : this.projectType,
        id: id ?? this.id,
        projectTypeId:
            projectTypeId.present ? projectTypeId.value : this.projectTypeId,
        projectNumber:
            projectNumber.present ? projectNumber.value : this.projectNumber,
        subProjectTypeId: subProjectTypeId.present
            ? subProjectTypeId.value
            : this.subProjectTypeId,
        isTaskEnabled:
            isTaskEnabled.present ? isTaskEnabled.value : this.isTaskEnabled,
        parent: parent.present ? parent.value : this.parent,
        name: name ?? this.name,
        department: department.present ? department.value : this.department,
        description: description.present ? description.value : this.description,
        referenceId: referenceId.present ? referenceId.value : this.referenceId,
        projectHierarchy: projectHierarchy.present
            ? projectHierarchy.value
            : this.projectHierarchy,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        startDate: startDate.present ? startDate.value : this.startDate,
        endDate: endDate.present ? endDate.value : this.endDate,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectData(')
          ..write('projectType: $projectType, ')
          ..write('id: $id, ')
          ..write('projectTypeId: $projectTypeId, ')
          ..write('projectNumber: $projectNumber, ')
          ..write('subProjectTypeId: $subProjectTypeId, ')
          ..write('isTaskEnabled: $isTaskEnabled, ')
          ..write('parent: $parent, ')
          ..write('name: $name, ')
          ..write('department: $department, ')
          ..write('description: $description, ')
          ..write('referenceId: $referenceId, ')
          ..write('projectHierarchy: $projectHierarchy, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        projectType,
        id,
        projectTypeId,
        projectNumber,
        subProjectTypeId,
        isTaskEnabled,
        parent,
        name,
        department,
        description,
        referenceId,
        projectHierarchy,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        startDate,
        endDate,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectData &&
          other.projectType == this.projectType &&
          other.id == this.id &&
          other.projectTypeId == this.projectTypeId &&
          other.projectNumber == this.projectNumber &&
          other.subProjectTypeId == this.subProjectTypeId &&
          other.isTaskEnabled == this.isTaskEnabled &&
          other.parent == this.parent &&
          other.name == this.name &&
          other.department == this.department &&
          other.description == this.description &&
          other.referenceId == this.referenceId &&
          other.projectHierarchy == this.projectHierarchy &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.additionalFields == this.additionalFields);
}

class ProjectCompanion extends UpdateCompanion<ProjectData> {
  final Value<String?> projectType;
  final Value<String> id;
  final Value<String?> projectTypeId;
  final Value<String?> projectNumber;
  final Value<String?> subProjectTypeId;
  final Value<bool?> isTaskEnabled;
  final Value<String?> parent;
  final Value<String> name;
  final Value<String?> department;
  final Value<String?> description;
  final Value<String?> referenceId;
  final Value<String?> projectHierarchy;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int?> startDate;
  final Value<int?> endDate;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectCompanion({
    this.projectType = const Value.absent(),
    this.id = const Value.absent(),
    this.projectTypeId = const Value.absent(),
    this.projectNumber = const Value.absent(),
    this.subProjectTypeId = const Value.absent(),
    this.isTaskEnabled = const Value.absent(),
    this.parent = const Value.absent(),
    this.name = const Value.absent(),
    this.department = const Value.absent(),
    this.description = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.projectHierarchy = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectCompanion.insert({
    this.projectType = const Value.absent(),
    required String id,
    this.projectTypeId = const Value.absent(),
    this.projectNumber = const Value.absent(),
    this.subProjectTypeId = const Value.absent(),
    this.isTaskEnabled = const Value.absent(),
    this.parent = const Value.absent(),
    required String name,
    this.department = const Value.absent(),
    this.description = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.projectHierarchy = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        name = Value(name);
  static Insertable<ProjectData> custom({
    Expression<String>? projectType,
    Expression<String>? id,
    Expression<String>? projectTypeId,
    Expression<String>? projectNumber,
    Expression<String>? subProjectTypeId,
    Expression<bool>? isTaskEnabled,
    Expression<String>? parent,
    Expression<String>? name,
    Expression<String>? department,
    Expression<String>? description,
    Expression<String>? referenceId,
    Expression<String>? projectHierarchy,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? startDate,
    Expression<int>? endDate,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (projectType != null) 'project_type': projectType,
      if (id != null) 'id': id,
      if (projectTypeId != null) 'project_type_id': projectTypeId,
      if (projectNumber != null) 'project_number': projectNumber,
      if (subProjectTypeId != null) 'sub_project_type_id': subProjectTypeId,
      if (isTaskEnabled != null) 'is_task_enabled': isTaskEnabled,
      if (parent != null) 'parent': parent,
      if (name != null) 'name': name,
      if (department != null) 'department': department,
      if (description != null) 'description': description,
      if (referenceId != null) 'reference_id': referenceId,
      if (projectHierarchy != null) 'project_hierarchy': projectHierarchy,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectCompanion copyWith(
      {Value<String?>? projectType,
      Value<String>? id,
      Value<String?>? projectTypeId,
      Value<String?>? projectNumber,
      Value<String?>? subProjectTypeId,
      Value<bool?>? isTaskEnabled,
      Value<String?>? parent,
      Value<String>? name,
      Value<String?>? department,
      Value<String?>? description,
      Value<String?>? referenceId,
      Value<String?>? projectHierarchy,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int?>? startDate,
      Value<int?>? endDate,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectCompanion(
      projectType: projectType ?? this.projectType,
      id: id ?? this.id,
      projectTypeId: projectTypeId ?? this.projectTypeId,
      projectNumber: projectNumber ?? this.projectNumber,
      subProjectTypeId: subProjectTypeId ?? this.subProjectTypeId,
      isTaskEnabled: isTaskEnabled ?? this.isTaskEnabled,
      parent: parent ?? this.parent,
      name: name ?? this.name,
      department: department ?? this.department,
      description: description ?? this.description,
      referenceId: referenceId ?? this.referenceId,
      projectHierarchy: projectHierarchy ?? this.projectHierarchy,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (projectType.present) {
      map['project_type'] = Variable<String>(projectType.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (projectTypeId.present) {
      map['project_type_id'] = Variable<String>(projectTypeId.value);
    }
    if (projectNumber.present) {
      map['project_number'] = Variable<String>(projectNumber.value);
    }
    if (subProjectTypeId.present) {
      map['sub_project_type_id'] = Variable<String>(subProjectTypeId.value);
    }
    if (isTaskEnabled.present) {
      map['is_task_enabled'] = Variable<bool>(isTaskEnabled.value);
    }
    if (parent.present) {
      map['parent'] = Variable<String>(parent.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (department.present) {
      map['department'] = Variable<String>(department.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (projectHierarchy.present) {
      map['project_hierarchy'] = Variable<String>(projectHierarchy.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<int>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<int>(endDate.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectCompanion(')
          ..write('projectType: $projectType, ')
          ..write('id: $id, ')
          ..write('projectTypeId: $projectTypeId, ')
          ..write('projectNumber: $projectNumber, ')
          ..write('subProjectTypeId: $subProjectTypeId, ')
          ..write('isTaskEnabled: $isTaskEnabled, ')
          ..write('parent: $parent, ')
          ..write('name: $name, ')
          ..write('department: $department, ')
          ..write('description: $description, ')
          ..write('referenceId: $referenceId, ')
          ..write('projectHierarchy: $projectHierarchy, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectBeneficiaryTable extends ProjectBeneficiary
    with TableInfo<$ProjectBeneficiaryTable, ProjectBeneficiaryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectBeneficiaryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _beneficiaryIdMeta =
      const VerificationMeta('beneficiaryId');
  @override
  late final GeneratedColumn<String> beneficiaryId = GeneratedColumn<String>(
      'beneficiary_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tagMeta = const VerificationMeta('tag');
  @override
  late final GeneratedColumn<String> tag = GeneratedColumn<String>(
      'tag', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _beneficiaryClientReferenceIdMeta =
      const VerificationMeta('beneficiaryClientReferenceId');
  @override
  late final GeneratedColumn<String> beneficiaryClientReferenceId =
      GeneratedColumn<String>(
          'beneficiary_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _dateOfRegistrationMeta =
      const VerificationMeta('dateOfRegistration');
  @override
  late final GeneratedColumn<int> dateOfRegistration = GeneratedColumn<int>(
      'date_of_registration', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        projectId,
        beneficiaryId,
        tag,
        beneficiaryClientReferenceId,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        dateOfRegistration,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project_beneficiary';
  @override
  VerificationContext validateIntegrity(
      Insertable<ProjectBeneficiaryData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('beneficiary_id')) {
      context.handle(
          _beneficiaryIdMeta,
          beneficiaryId.isAcceptableOrUnknown(
              data['beneficiary_id']!, _beneficiaryIdMeta));
    }
    if (data.containsKey('tag')) {
      context.handle(
          _tagMeta, tag.isAcceptableOrUnknown(data['tag']!, _tagMeta));
    }
    if (data.containsKey('beneficiary_client_reference_id')) {
      context.handle(
          _beneficiaryClientReferenceIdMeta,
          beneficiaryClientReferenceId.isAcceptableOrUnknown(
              data['beneficiary_client_reference_id']!,
              _beneficiaryClientReferenceIdMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('date_of_registration')) {
      context.handle(
          _dateOfRegistrationMeta,
          dateOfRegistration.isAcceptableOrUnknown(
              data['date_of_registration']!, _dateOfRegistrationMeta));
    } else if (isInserting) {
      context.missing(_dateOfRegistrationMeta);
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  ProjectBeneficiaryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectBeneficiaryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      beneficiaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}beneficiary_id']),
      tag: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tag']),
      beneficiaryClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}beneficiary_client_reference_id']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      dateOfRegistration: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}date_of_registration'])!,
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectBeneficiaryTable createAlias(String alias) {
    return $ProjectBeneficiaryTable(attachedDatabase, alias);
  }
}

class ProjectBeneficiaryData extends DataClass
    implements Insertable<ProjectBeneficiaryData> {
  final String? id;
  final String? projectId;
  final String? beneficiaryId;
  final String? tag;
  final String? beneficiaryClientReferenceId;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final int dateOfRegistration;
  final String? additionalFields;
  const ProjectBeneficiaryData(
      {this.id,
      this.projectId,
      this.beneficiaryId,
      this.tag,
      this.beneficiaryClientReferenceId,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      required this.dateOfRegistration,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || beneficiaryId != null) {
      map['beneficiary_id'] = Variable<String>(beneficiaryId);
    }
    if (!nullToAbsent || tag != null) {
      map['tag'] = Variable<String>(tag);
    }
    if (!nullToAbsent || beneficiaryClientReferenceId != null) {
      map['beneficiary_client_reference_id'] =
          Variable<String>(beneficiaryClientReferenceId);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    map['date_of_registration'] = Variable<int>(dateOfRegistration);
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectBeneficiaryCompanion toCompanion(bool nullToAbsent) {
    return ProjectBeneficiaryCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      beneficiaryId: beneficiaryId == null && nullToAbsent
          ? const Value.absent()
          : Value(beneficiaryId),
      tag: tag == null && nullToAbsent ? const Value.absent() : Value(tag),
      beneficiaryClientReferenceId:
          beneficiaryClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(beneficiaryClientReferenceId),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      dateOfRegistration: Value(dateOfRegistration),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectBeneficiaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectBeneficiaryData(
      id: serializer.fromJson<String?>(json['id']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      beneficiaryId: serializer.fromJson<String?>(json['beneficiaryId']),
      tag: serializer.fromJson<String?>(json['tag']),
      beneficiaryClientReferenceId:
          serializer.fromJson<String?>(json['beneficiaryClientReferenceId']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      dateOfRegistration: serializer.fromJson<int>(json['dateOfRegistration']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'projectId': serializer.toJson<String?>(projectId),
      'beneficiaryId': serializer.toJson<String?>(beneficiaryId),
      'tag': serializer.toJson<String?>(tag),
      'beneficiaryClientReferenceId':
          serializer.toJson<String?>(beneficiaryClientReferenceId),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'dateOfRegistration': serializer.toJson<int>(dateOfRegistration),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectBeneficiaryData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> beneficiaryId = const Value.absent(),
          Value<String?> tag = const Value.absent(),
          Value<String?> beneficiaryClientReferenceId = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          int? dateOfRegistration,
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectBeneficiaryData(
        id: id.present ? id.value : this.id,
        projectId: projectId.present ? projectId.value : this.projectId,
        beneficiaryId:
            beneficiaryId.present ? beneficiaryId.value : this.beneficiaryId,
        tag: tag.present ? tag.value : this.tag,
        beneficiaryClientReferenceId: beneficiaryClientReferenceId.present
            ? beneficiaryClientReferenceId.value
            : this.beneficiaryClientReferenceId,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        dateOfRegistration: dateOfRegistration ?? this.dateOfRegistration,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectBeneficiaryData(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('beneficiaryId: $beneficiaryId, ')
          ..write('tag: $tag, ')
          ..write(
              'beneficiaryClientReferenceId: $beneficiaryClientReferenceId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('dateOfRegistration: $dateOfRegistration, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      projectId,
      beneficiaryId,
      tag,
      beneficiaryClientReferenceId,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      dateOfRegistration,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectBeneficiaryData &&
          other.id == this.id &&
          other.projectId == this.projectId &&
          other.beneficiaryId == this.beneficiaryId &&
          other.tag == this.tag &&
          other.beneficiaryClientReferenceId ==
              this.beneficiaryClientReferenceId &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.dateOfRegistration == this.dateOfRegistration &&
          other.additionalFields == this.additionalFields);
}

class ProjectBeneficiaryCompanion
    extends UpdateCompanion<ProjectBeneficiaryData> {
  final Value<String?> id;
  final Value<String?> projectId;
  final Value<String?> beneficiaryId;
  final Value<String?> tag;
  final Value<String?> beneficiaryClientReferenceId;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int> dateOfRegistration;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectBeneficiaryCompanion({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.beneficiaryId = const Value.absent(),
    this.tag = const Value.absent(),
    this.beneficiaryClientReferenceId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.dateOfRegistration = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectBeneficiaryCompanion.insert({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.beneficiaryId = const Value.absent(),
    this.tag = const Value.absent(),
    this.beneficiaryClientReferenceId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    required int dateOfRegistration,
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : clientReferenceId = Value(clientReferenceId),
        dateOfRegistration = Value(dateOfRegistration);
  static Insertable<ProjectBeneficiaryData> custom({
    Expression<String>? id,
    Expression<String>? projectId,
    Expression<String>? beneficiaryId,
    Expression<String>? tag,
    Expression<String>? beneficiaryClientReferenceId,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? dateOfRegistration,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (projectId != null) 'project_id': projectId,
      if (beneficiaryId != null) 'beneficiary_id': beneficiaryId,
      if (tag != null) 'tag': tag,
      if (beneficiaryClientReferenceId != null)
        'beneficiary_client_reference_id': beneficiaryClientReferenceId,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (dateOfRegistration != null)
        'date_of_registration': dateOfRegistration,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectBeneficiaryCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? projectId,
      Value<String?>? beneficiaryId,
      Value<String?>? tag,
      Value<String?>? beneficiaryClientReferenceId,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int>? dateOfRegistration,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectBeneficiaryCompanion(
      id: id ?? this.id,
      projectId: projectId ?? this.projectId,
      beneficiaryId: beneficiaryId ?? this.beneficiaryId,
      tag: tag ?? this.tag,
      beneficiaryClientReferenceId:
          beneficiaryClientReferenceId ?? this.beneficiaryClientReferenceId,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      dateOfRegistration: dateOfRegistration ?? this.dateOfRegistration,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (beneficiaryId.present) {
      map['beneficiary_id'] = Variable<String>(beneficiaryId.value);
    }
    if (tag.present) {
      map['tag'] = Variable<String>(tag.value);
    }
    if (beneficiaryClientReferenceId.present) {
      map['beneficiary_client_reference_id'] =
          Variable<String>(beneficiaryClientReferenceId.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (dateOfRegistration.present) {
      map['date_of_registration'] = Variable<int>(dateOfRegistration.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectBeneficiaryCompanion(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('beneficiaryId: $beneficiaryId, ')
          ..write('tag: $tag, ')
          ..write(
              'beneficiaryClientReferenceId: $beneficiaryClientReferenceId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('dateOfRegistration: $dateOfRegistration, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectFacilityTable extends ProjectFacility
    with TableInfo<$ProjectFacilityTable, ProjectFacilityData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectFacilityTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _facilityIdMeta =
      const VerificationMeta('facilityId');
  @override
  late final GeneratedColumn<String> facilityId = GeneratedColumn<String>(
      'facility_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        facilityId,
        projectId,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project_facility';
  @override
  VerificationContext validateIntegrity(
      Insertable<ProjectFacilityData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('facility_id')) {
      context.handle(
          _facilityIdMeta,
          facilityId.isAcceptableOrUnknown(
              data['facility_id']!, _facilityIdMeta));
    } else if (isInserting) {
      context.missing(_facilityIdMeta);
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    } else if (isInserting) {
      context.missing(_projectIdMeta);
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  ProjectFacilityData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectFacilityData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      facilityId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}facility_id'])!,
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id'])!,
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectFacilityTable createAlias(String alias) {
    return $ProjectFacilityTable(attachedDatabase, alias);
  }
}

class ProjectFacilityData extends DataClass
    implements Insertable<ProjectFacilityData> {
  final String id;
  final String facilityId;
  final String projectId;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ProjectFacilityData(
      {required this.id,
      required this.facilityId,
      required this.projectId,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['facility_id'] = Variable<String>(facilityId);
    map['project_id'] = Variable<String>(projectId);
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectFacilityCompanion toCompanion(bool nullToAbsent) {
    return ProjectFacilityCompanion(
      id: Value(id),
      facilityId: Value(facilityId),
      projectId: Value(projectId),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectFacilityData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectFacilityData(
      id: serializer.fromJson<String>(json['id']),
      facilityId: serializer.fromJson<String>(json['facilityId']),
      projectId: serializer.fromJson<String>(json['projectId']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'facilityId': serializer.toJson<String>(facilityId),
      'projectId': serializer.toJson<String>(projectId),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectFacilityData copyWith(
          {String? id,
          String? facilityId,
          String? projectId,
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectFacilityData(
        id: id ?? this.id,
        facilityId: facilityId ?? this.facilityId,
        projectId: projectId ?? this.projectId,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectFacilityData(')
          ..write('id: $id, ')
          ..write('facilityId: $facilityId, ')
          ..write('projectId: $projectId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      facilityId,
      projectId,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectFacilityData &&
          other.id == this.id &&
          other.facilityId == this.facilityId &&
          other.projectId == this.projectId &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ProjectFacilityCompanion extends UpdateCompanion<ProjectFacilityData> {
  final Value<String> id;
  final Value<String> facilityId;
  final Value<String> projectId;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectFacilityCompanion({
    this.id = const Value.absent(),
    this.facilityId = const Value.absent(),
    this.projectId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectFacilityCompanion.insert({
    required String id,
    required String facilityId,
    required String projectId,
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        facilityId = Value(facilityId),
        projectId = Value(projectId);
  static Insertable<ProjectFacilityData> custom({
    Expression<String>? id,
    Expression<String>? facilityId,
    Expression<String>? projectId,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (facilityId != null) 'facility_id': facilityId,
      if (projectId != null) 'project_id': projectId,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectFacilityCompanion copyWith(
      {Value<String>? id,
      Value<String>? facilityId,
      Value<String>? projectId,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectFacilityCompanion(
      id: id ?? this.id,
      facilityId: facilityId ?? this.facilityId,
      projectId: projectId ?? this.projectId,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (facilityId.present) {
      map['facility_id'] = Variable<String>(facilityId.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectFacilityCompanion(')
          ..write('id: $id, ')
          ..write('facilityId: $facilityId, ')
          ..write('projectId: $projectId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectProductVariantTable extends ProjectProductVariant
    with TableInfo<$ProjectProductVariantTable, ProjectProductVariantData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectProductVariantTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _productVariantIdMeta =
      const VerificationMeta('productVariantId');
  @override
  late final GeneratedColumn<String> productVariantId = GeneratedColumn<String>(
      'product_variant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isBaseUnitVariantMeta =
      const VerificationMeta('isBaseUnitVariant');
  @override
  late final GeneratedColumn<bool> isBaseUnitVariant = GeneratedColumn<bool>(
      'is_base_unit_variant', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_base_unit_variant" IN (0, 1))'));
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        productVariantId,
        type,
        isBaseUnitVariant,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        name,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project_product_variant';
  @override
  VerificationContext validateIntegrity(
      Insertable<ProjectProductVariantData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('product_variant_id')) {
      context.handle(
          _productVariantIdMeta,
          productVariantId.isAcceptableOrUnknown(
              data['product_variant_id']!, _productVariantIdMeta));
    } else if (isInserting) {
      context.missing(_productVariantIdMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('is_base_unit_variant')) {
      context.handle(
          _isBaseUnitVariantMeta,
          isBaseUnitVariant.isAcceptableOrUnknown(
              data['is_base_unit_variant']!, _isBaseUnitVariantMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {productVariantId, auditCreatedBy};
  @override
  ProjectProductVariantData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectProductVariantData(
      productVariantId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}product_variant_id'])!,
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      isBaseUnitVariant: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}is_base_unit_variant']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectProductVariantTable createAlias(String alias) {
    return $ProjectProductVariantTable(attachedDatabase, alias);
  }
}

class ProjectProductVariantData extends DataClass
    implements Insertable<ProjectProductVariantData> {
  final String productVariantId;
  final String? type;
  final bool? isBaseUnitVariant;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? name;
  final String? additionalFields;
  const ProjectProductVariantData(
      {required this.productVariantId,
      this.type,
      this.isBaseUnitVariant,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.name,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['product_variant_id'] = Variable<String>(productVariantId);
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || isBaseUnitVariant != null) {
      map['is_base_unit_variant'] = Variable<bool>(isBaseUnitVariant);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectProductVariantCompanion toCompanion(bool nullToAbsent) {
    return ProjectProductVariantCompanion(
      productVariantId: Value(productVariantId),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      isBaseUnitVariant: isBaseUnitVariant == null && nullToAbsent
          ? const Value.absent()
          : Value(isBaseUnitVariant),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectProductVariantData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectProductVariantData(
      productVariantId: serializer.fromJson<String>(json['productVariantId']),
      type: serializer.fromJson<String?>(json['type']),
      isBaseUnitVariant: serializer.fromJson<bool?>(json['isBaseUnitVariant']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      name: serializer.fromJson<String?>(json['name']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'productVariantId': serializer.toJson<String>(productVariantId),
      'type': serializer.toJson<String?>(type),
      'isBaseUnitVariant': serializer.toJson<bool?>(isBaseUnitVariant),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'name': serializer.toJson<String?>(name),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectProductVariantData copyWith(
          {String? productVariantId,
          Value<String?> type = const Value.absent(),
          Value<bool?> isBaseUnitVariant = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectProductVariantData(
        productVariantId: productVariantId ?? this.productVariantId,
        type: type.present ? type.value : this.type,
        isBaseUnitVariant: isBaseUnitVariant.present
            ? isBaseUnitVariant.value
            : this.isBaseUnitVariant,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        name: name.present ? name.value : this.name,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectProductVariantData(')
          ..write('productVariantId: $productVariantId, ')
          ..write('type: $type, ')
          ..write('isBaseUnitVariant: $isBaseUnitVariant, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('name: $name, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      productVariantId,
      type,
      isBaseUnitVariant,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      name,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectProductVariantData &&
          other.productVariantId == this.productVariantId &&
          other.type == this.type &&
          other.isBaseUnitVariant == this.isBaseUnitVariant &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.name == this.name &&
          other.additionalFields == this.additionalFields);
}

class ProjectProductVariantCompanion
    extends UpdateCompanion<ProjectProductVariantData> {
  final Value<String> productVariantId;
  final Value<String?> type;
  final Value<bool?> isBaseUnitVariant;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> name;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectProductVariantCompanion({
    this.productVariantId = const Value.absent(),
    this.type = const Value.absent(),
    this.isBaseUnitVariant = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.name = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectProductVariantCompanion.insert({
    required String productVariantId,
    this.type = const Value.absent(),
    this.isBaseUnitVariant = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.name = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : productVariantId = Value(productVariantId);
  static Insertable<ProjectProductVariantData> custom({
    Expression<String>? productVariantId,
    Expression<String>? type,
    Expression<bool>? isBaseUnitVariant,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? name,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (productVariantId != null) 'product_variant_id': productVariantId,
      if (type != null) 'type': type,
      if (isBaseUnitVariant != null) 'is_base_unit_variant': isBaseUnitVariant,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (name != null) 'name': name,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectProductVariantCompanion copyWith(
      {Value<String>? productVariantId,
      Value<String?>? type,
      Value<bool?>? isBaseUnitVariant,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? name,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectProductVariantCompanion(
      productVariantId: productVariantId ?? this.productVariantId,
      type: type ?? this.type,
      isBaseUnitVariant: isBaseUnitVariant ?? this.isBaseUnitVariant,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      name: name ?? this.name,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (productVariantId.present) {
      map['product_variant_id'] = Variable<String>(productVariantId.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (isBaseUnitVariant.present) {
      map['is_base_unit_variant'] = Variable<bool>(isBaseUnitVariant.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectProductVariantCompanion(')
          ..write('productVariantId: $productVariantId, ')
          ..write('type: $type, ')
          ..write('isBaseUnitVariant: $isBaseUnitVariant, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('name: $name, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectResourceTable extends ProjectResource
    with TableInfo<$ProjectResourceTable, ProjectResourceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectResourceTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _resourceMeta =
      const VerificationMeta('resource');
  @override
  late final GeneratedColumn<String> resource = GeneratedColumn<String>(
      'resource', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES project_product_variant (product_variant_id)'));
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        projectId,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        resource,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project_resource';
  @override
  VerificationContext validateIntegrity(
      Insertable<ProjectResourceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('resource')) {
      context.handle(_resourceMeta,
          resource.isAcceptableOrUnknown(data['resource']!, _resourceMeta));
    } else if (isInserting) {
      context.missing(_resourceMeta);
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  ProjectResourceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectResourceData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      resource: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}resource'])!,
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectResourceTable createAlias(String alias) {
    return $ProjectResourceTable(attachedDatabase, alias);
  }
}

class ProjectResourceData extends DataClass
    implements Insertable<ProjectResourceData> {
  final String? id;
  final String? projectId;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String resource;
  final String? additionalFields;
  const ProjectResourceData(
      {this.id,
      this.projectId,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      required this.resource,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    map['resource'] = Variable<String>(resource);
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectResourceCompanion toCompanion(bool nullToAbsent) {
    return ProjectResourceCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      resource: Value(resource),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectResourceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectResourceData(
      id: serializer.fromJson<String?>(json['id']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      resource: serializer.fromJson<String>(json['resource']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'projectId': serializer.toJson<String?>(projectId),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'resource': serializer.toJson<String>(resource),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectResourceData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          String? resource,
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectResourceData(
        id: id.present ? id.value : this.id,
        projectId: projectId.present ? projectId.value : this.projectId,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        resource: resource ?? this.resource,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectResourceData(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('resource: $resource, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      projectId,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      resource,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectResourceData &&
          other.id == this.id &&
          other.projectId == this.projectId &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.resource == this.resource &&
          other.additionalFields == this.additionalFields);
}

class ProjectResourceCompanion extends UpdateCompanion<ProjectResourceData> {
  final Value<String?> id;
  final Value<String?> projectId;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String> resource;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectResourceCompanion({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.resource = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectResourceCompanion.insert({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    required String resource,
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : resource = Value(resource);
  static Insertable<ProjectResourceData> custom({
    Expression<String>? id,
    Expression<String>? projectId,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? resource,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (projectId != null) 'project_id': projectId,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (resource != null) 'resource': resource,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectResourceCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? projectId,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String>? resource,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectResourceCompanion(
      id: id ?? this.id,
      projectId: projectId ?? this.projectId,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      resource: resource ?? this.resource,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (resource.present) {
      map['resource'] = Variable<String>(resource.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectResourceCompanion(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('resource: $resource, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectStaffTable extends ProjectStaff
    with TableInfo<$ProjectStaffTable, ProjectStaffData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectStaffTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _staffIdMeta =
      const VerificationMeta('staffId');
  @override
  late final GeneratedColumn<String> staffId = GeneratedColumn<String>(
      'staff_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
      'user_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _channelMeta =
      const VerificationMeta('channel');
  @override
  late final GeneratedColumn<String> channel = GeneratedColumn<String>(
      'channel', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _startDateMeta =
      const VerificationMeta('startDate');
  @override
  late final GeneratedColumn<int> startDate = GeneratedColumn<int>(
      'start_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _endDateMeta =
      const VerificationMeta('endDate');
  @override
  late final GeneratedColumn<int> endDate = GeneratedColumn<int>(
      'end_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        staffId,
        userId,
        projectId,
        channel,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        startDate,
        endDate,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project_staff';
  @override
  VerificationContext validateIntegrity(Insertable<ProjectStaffData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('staff_id')) {
      context.handle(_staffIdMeta,
          staffId.isAcceptableOrUnknown(data['staff_id']!, _staffIdMeta));
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('channel')) {
      context.handle(_channelMeta,
          channel.isAcceptableOrUnknown(data['channel']!, _channelMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  ProjectStaffData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectStaffData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      staffId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}staff_id']),
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_id']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      channel: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}channel']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      startDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}start_date']),
      endDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}end_date']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectStaffTable createAlias(String alias) {
    return $ProjectStaffTable(attachedDatabase, alias);
  }
}

class ProjectStaffData extends DataClass
    implements Insertable<ProjectStaffData> {
  final String id;
  final String? staffId;
  final String? userId;
  final String? projectId;
  final String? channel;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final int? startDate;
  final int? endDate;
  final String? additionalFields;
  const ProjectStaffData(
      {required this.id,
      this.staffId,
      this.userId,
      this.projectId,
      this.channel,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.startDate,
      this.endDate,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || staffId != null) {
      map['staff_id'] = Variable<String>(staffId);
    }
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<String>(userId);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || channel != null) {
      map['channel'] = Variable<String>(channel);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || startDate != null) {
      map['start_date'] = Variable<int>(startDate);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<int>(endDate);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectStaffCompanion toCompanion(bool nullToAbsent) {
    return ProjectStaffCompanion(
      id: Value(id),
      staffId: staffId == null && nullToAbsent
          ? const Value.absent()
          : Value(staffId),
      userId:
          userId == null && nullToAbsent ? const Value.absent() : Value(userId),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      channel: channel == null && nullToAbsent
          ? const Value.absent()
          : Value(channel),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      startDate: startDate == null && nullToAbsent
          ? const Value.absent()
          : Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectStaffData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectStaffData(
      id: serializer.fromJson<String>(json['id']),
      staffId: serializer.fromJson<String?>(json['staffId']),
      userId: serializer.fromJson<String?>(json['userId']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      channel: serializer.fromJson<String?>(json['channel']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      startDate: serializer.fromJson<int?>(json['startDate']),
      endDate: serializer.fromJson<int?>(json['endDate']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'staffId': serializer.toJson<String?>(staffId),
      'userId': serializer.toJson<String?>(userId),
      'projectId': serializer.toJson<String?>(projectId),
      'channel': serializer.toJson<String?>(channel),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'startDate': serializer.toJson<int?>(startDate),
      'endDate': serializer.toJson<int?>(endDate),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectStaffData copyWith(
          {String? id,
          Value<String?> staffId = const Value.absent(),
          Value<String?> userId = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> channel = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<int?> startDate = const Value.absent(),
          Value<int?> endDate = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectStaffData(
        id: id ?? this.id,
        staffId: staffId.present ? staffId.value : this.staffId,
        userId: userId.present ? userId.value : this.userId,
        projectId: projectId.present ? projectId.value : this.projectId,
        channel: channel.present ? channel.value : this.channel,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        startDate: startDate.present ? startDate.value : this.startDate,
        endDate: endDate.present ? endDate.value : this.endDate,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectStaffData(')
          ..write('id: $id, ')
          ..write('staffId: $staffId, ')
          ..write('userId: $userId, ')
          ..write('projectId: $projectId, ')
          ..write('channel: $channel, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      staffId,
      userId,
      projectId,
      channel,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      startDate,
      endDate,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectStaffData &&
          other.id == this.id &&
          other.staffId == this.staffId &&
          other.userId == this.userId &&
          other.projectId == this.projectId &&
          other.channel == this.channel &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.additionalFields == this.additionalFields);
}

class ProjectStaffCompanion extends UpdateCompanion<ProjectStaffData> {
  final Value<String> id;
  final Value<String?> staffId;
  final Value<String?> userId;
  final Value<String?> projectId;
  final Value<String?> channel;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int?> startDate;
  final Value<int?> endDate;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectStaffCompanion({
    this.id = const Value.absent(),
    this.staffId = const Value.absent(),
    this.userId = const Value.absent(),
    this.projectId = const Value.absent(),
    this.channel = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectStaffCompanion.insert({
    required String id,
    this.staffId = const Value.absent(),
    this.userId = const Value.absent(),
    this.projectId = const Value.absent(),
    this.channel = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<ProjectStaffData> custom({
    Expression<String>? id,
    Expression<String>? staffId,
    Expression<String>? userId,
    Expression<String>? projectId,
    Expression<String>? channel,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? startDate,
    Expression<int>? endDate,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (staffId != null) 'staff_id': staffId,
      if (userId != null) 'user_id': userId,
      if (projectId != null) 'project_id': projectId,
      if (channel != null) 'channel': channel,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectStaffCompanion copyWith(
      {Value<String>? id,
      Value<String?>? staffId,
      Value<String?>? userId,
      Value<String?>? projectId,
      Value<String?>? channel,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int?>? startDate,
      Value<int?>? endDate,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectStaffCompanion(
      id: id ?? this.id,
      staffId: staffId ?? this.staffId,
      userId: userId ?? this.userId,
      projectId: projectId ?? this.projectId,
      channel: channel ?? this.channel,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (staffId.present) {
      map['staff_id'] = Variable<String>(staffId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (channel.present) {
      map['channel'] = Variable<String>(channel.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<int>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<int>(endDate.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectStaffCompanion(')
          ..write('id: $id, ')
          ..write('staffId: $staffId, ')
          ..write('userId: $userId, ')
          ..write('projectId: $projectId, ')
          ..write('channel: $channel, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectTypeTable extends ProjectType
    with TableInfo<$ProjectTypeTable, ProjectTypeData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectTypeTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _groupMeta = const VerificationMeta('group');
  @override
  late final GeneratedColumn<String> group = GeneratedColumn<String>(
      'group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _beneficiaryTypeMeta =
      const VerificationMeta('beneficiaryType');
  @override
  late final GeneratedColumnWithTypeConverter<BeneficiaryType?, int>
      beneficiaryType = GeneratedColumn<int>(
              'beneficiary_type', aliasedName, true,
              type: DriftSqlType.int, requiredDuringInsert: false)
          .withConverter<BeneficiaryType?>(
              $ProjectTypeTable.$converterbeneficiaryTypen);
  static const VerificationMeta _eligibilityCriteriaMeta =
      const VerificationMeta('eligibilityCriteria');
  @override
  late final GeneratedColumn<String> eligibilityCriteria =
      GeneratedColumn<String>('eligibility_criteria', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _taskProcedureMeta =
      const VerificationMeta('taskProcedure');
  @override
  late final GeneratedColumn<String> taskProcedure = GeneratedColumn<String>(
      'task_procedure', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        name,
        code,
        group,
        beneficiaryType,
        eligibilityCriteria,
        taskProcedure,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project_type';
  @override
  VerificationContext validateIntegrity(Insertable<ProjectTypeData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('group')) {
      context.handle(
          _groupMeta, group.isAcceptableOrUnknown(data['group']!, _groupMeta));
    }
    context.handle(_beneficiaryTypeMeta, const VerificationResult.success());
    if (data.containsKey('eligibility_criteria')) {
      context.handle(
          _eligibilityCriteriaMeta,
          eligibilityCriteria.isAcceptableOrUnknown(
              data['eligibility_criteria']!, _eligibilityCriteriaMeta));
    }
    if (data.containsKey('task_procedure')) {
      context.handle(
          _taskProcedureMeta,
          taskProcedure.isAcceptableOrUnknown(
              data['task_procedure']!, _taskProcedureMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  ProjectTypeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectTypeData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      group: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}group']),
      beneficiaryType: $ProjectTypeTable.$converterbeneficiaryTypen.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.int, data['${effectivePrefix}beneficiary_type'])),
      eligibilityCriteria: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}eligibility_criteria']),
      taskProcedure: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}task_procedure']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectTypeTable createAlias(String alias) {
    return $ProjectTypeTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<BeneficiaryType, int, int>
      $converterbeneficiaryType =
      const EnumIndexConverter<BeneficiaryType>(BeneficiaryType.values);
  static JsonTypeConverter2<BeneficiaryType?, int?, int?>
      $converterbeneficiaryTypen =
      JsonTypeConverter2.asNullable($converterbeneficiaryType);
}

class ProjectTypeData extends DataClass implements Insertable<ProjectTypeData> {
  final String? id;
  final String? name;
  final String? code;
  final String? group;
  final BeneficiaryType? beneficiaryType;
  final String? eligibilityCriteria;
  final String? taskProcedure;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ProjectTypeData(
      {this.id,
      this.name,
      this.code,
      this.group,
      this.beneficiaryType,
      this.eligibilityCriteria,
      this.taskProcedure,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || group != null) {
      map['group'] = Variable<String>(group);
    }
    if (!nullToAbsent || beneficiaryType != null) {
      map['beneficiary_type'] = Variable<int>(
          $ProjectTypeTable.$converterbeneficiaryTypen.toSql(beneficiaryType));
    }
    if (!nullToAbsent || eligibilityCriteria != null) {
      map['eligibility_criteria'] = Variable<String>(eligibilityCriteria);
    }
    if (!nullToAbsent || taskProcedure != null) {
      map['task_procedure'] = Variable<String>(taskProcedure);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectTypeCompanion toCompanion(bool nullToAbsent) {
    return ProjectTypeCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      group:
          group == null && nullToAbsent ? const Value.absent() : Value(group),
      beneficiaryType: beneficiaryType == null && nullToAbsent
          ? const Value.absent()
          : Value(beneficiaryType),
      eligibilityCriteria: eligibilityCriteria == null && nullToAbsent
          ? const Value.absent()
          : Value(eligibilityCriteria),
      taskProcedure: taskProcedure == null && nullToAbsent
          ? const Value.absent()
          : Value(taskProcedure),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectTypeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectTypeData(
      id: serializer.fromJson<String?>(json['id']),
      name: serializer.fromJson<String?>(json['name']),
      code: serializer.fromJson<String?>(json['code']),
      group: serializer.fromJson<String?>(json['group']),
      beneficiaryType: $ProjectTypeTable.$converterbeneficiaryTypen
          .fromJson(serializer.fromJson<int?>(json['beneficiaryType'])),
      eligibilityCriteria:
          serializer.fromJson<String?>(json['eligibilityCriteria']),
      taskProcedure: serializer.fromJson<String?>(json['taskProcedure']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'name': serializer.toJson<String?>(name),
      'code': serializer.toJson<String?>(code),
      'group': serializer.toJson<String?>(group),
      'beneficiaryType': serializer.toJson<int?>(
          $ProjectTypeTable.$converterbeneficiaryTypen.toJson(beneficiaryType)),
      'eligibilityCriteria': serializer.toJson<String?>(eligibilityCriteria),
      'taskProcedure': serializer.toJson<String?>(taskProcedure),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectTypeData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<String?> code = const Value.absent(),
          Value<String?> group = const Value.absent(),
          Value<BeneficiaryType?> beneficiaryType = const Value.absent(),
          Value<String?> eligibilityCriteria = const Value.absent(),
          Value<String?> taskProcedure = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectTypeData(
        id: id.present ? id.value : this.id,
        name: name.present ? name.value : this.name,
        code: code.present ? code.value : this.code,
        group: group.present ? group.value : this.group,
        beneficiaryType: beneficiaryType.present
            ? beneficiaryType.value
            : this.beneficiaryType,
        eligibilityCriteria: eligibilityCriteria.present
            ? eligibilityCriteria.value
            : this.eligibilityCriteria,
        taskProcedure:
            taskProcedure.present ? taskProcedure.value : this.taskProcedure,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectTypeData(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('group: $group, ')
          ..write('beneficiaryType: $beneficiaryType, ')
          ..write('eligibilityCriteria: $eligibilityCriteria, ')
          ..write('taskProcedure: $taskProcedure, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        name,
        code,
        group,
        beneficiaryType,
        eligibilityCriteria,
        taskProcedure,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectTypeData &&
          other.id == this.id &&
          other.name == this.name &&
          other.code == this.code &&
          other.group == this.group &&
          other.beneficiaryType == this.beneficiaryType &&
          other.eligibilityCriteria == this.eligibilityCriteria &&
          other.taskProcedure == this.taskProcedure &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ProjectTypeCompanion extends UpdateCompanion<ProjectTypeData> {
  final Value<String?> id;
  final Value<String?> name;
  final Value<String?> code;
  final Value<String?> group;
  final Value<BeneficiaryType?> beneficiaryType;
  final Value<String?> eligibilityCriteria;
  final Value<String?> taskProcedure;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectTypeCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.group = const Value.absent(),
    this.beneficiaryType = const Value.absent(),
    this.eligibilityCriteria = const Value.absent(),
    this.taskProcedure = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectTypeCompanion.insert({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.group = const Value.absent(),
    this.beneficiaryType = const Value.absent(),
    this.eligibilityCriteria = const Value.absent(),
    this.taskProcedure = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<ProjectTypeData> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? code,
    Expression<String>? group,
    Expression<int>? beneficiaryType,
    Expression<String>? eligibilityCriteria,
    Expression<String>? taskProcedure,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (group != null) 'group': group,
      if (beneficiaryType != null) 'beneficiary_type': beneficiaryType,
      if (eligibilityCriteria != null)
        'eligibility_criteria': eligibilityCriteria,
      if (taskProcedure != null) 'task_procedure': taskProcedure,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectTypeCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? name,
      Value<String?>? code,
      Value<String?>? group,
      Value<BeneficiaryType?>? beneficiaryType,
      Value<String?>? eligibilityCriteria,
      Value<String?>? taskProcedure,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectTypeCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      code: code ?? this.code,
      group: group ?? this.group,
      beneficiaryType: beneficiaryType ?? this.beneficiaryType,
      eligibilityCriteria: eligibilityCriteria ?? this.eligibilityCriteria,
      taskProcedure: taskProcedure ?? this.taskProcedure,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (group.present) {
      map['group'] = Variable<String>(group.value);
    }
    if (beneficiaryType.present) {
      map['beneficiary_type'] = Variable<int>($ProjectTypeTable
          .$converterbeneficiaryTypen
          .toSql(beneficiaryType.value));
    }
    if (eligibilityCriteria.present) {
      map['eligibility_criteria'] = Variable<String>(eligibilityCriteria.value);
    }
    if (taskProcedure.present) {
      map['task_procedure'] = Variable<String>(taskProcedure.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectTypeCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('group: $group, ')
          ..write('beneficiaryType: $beneficiaryType, ')
          ..write('eligibilityCriteria: $eligibilityCriteria, ')
          ..write('taskProcedure: $taskProcedure, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $IndividualTable extends Individual
    with TableInfo<$IndividualTable, IndividualData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $IndividualTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _individualIdMeta =
      const VerificationMeta('individualId');
  @override
  late final GeneratedColumn<String> individualId = GeneratedColumn<String>(
      'individual_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
      'user_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userUuidMeta =
      const VerificationMeta('userUuid');
  @override
  late final GeneratedColumn<String> userUuid = GeneratedColumn<String>(
      'user_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _dateOfBirthMeta =
      const VerificationMeta('dateOfBirth');
  @override
  late final GeneratedColumn<String> dateOfBirth = GeneratedColumn<String>(
      'date_of_birth', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _mobileNumberMeta =
      const VerificationMeta('mobileNumber');
  @override
  late final GeneratedColumn<String> mobileNumber = GeneratedColumn<String>(
      'mobile_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _altContactNumberMeta =
      const VerificationMeta('altContactNumber');
  @override
  late final GeneratedColumn<String> altContactNumber = GeneratedColumn<String>(
      'alt_contact_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fatherNameMeta =
      const VerificationMeta('fatherName');
  @override
  late final GeneratedColumn<String> fatherName = GeneratedColumn<String>(
      'father_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _husbandNameMeta =
      const VerificationMeta('husbandName');
  @override
  late final GeneratedColumn<String> husbandName = GeneratedColumn<String>(
      'husband_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _photoMeta = const VerificationMeta('photo');
  @override
  late final GeneratedColumn<String> photo = GeneratedColumn<String>(
      'photo', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _bloodGroupMeta =
      const VerificationMeta('bloodGroup');
  @override
  late final GeneratedColumnWithTypeConverter<BloodGroup?, int> bloodGroup =
      GeneratedColumn<int>('blood_group', aliasedName, true,
              type: DriftSqlType.int, requiredDuringInsert: false)
          .withConverter<BloodGroup?>($IndividualTable.$converterbloodGroupn);
  static const VerificationMeta _genderMeta = const VerificationMeta('gender');
  @override
  late final GeneratedColumnWithTypeConverter<Gender?, int> gender =
      GeneratedColumn<int>('gender', aliasedName, true,
              type: DriftSqlType.int, requiredDuringInsert: false)
          .withConverter<Gender?>($IndividualTable.$convertergendern);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        individualId,
        userId,
        userUuid,
        dateOfBirth,
        mobileNumber,
        altContactNumber,
        email,
        fatherName,
        husbandName,
        photo,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        bloodGroup,
        gender,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'individual';
  @override
  VerificationContext validateIntegrity(Insertable<IndividualData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('individual_id')) {
      context.handle(
          _individualIdMeta,
          individualId.isAcceptableOrUnknown(
              data['individual_id']!, _individualIdMeta));
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    }
    if (data.containsKey('user_uuid')) {
      context.handle(_userUuidMeta,
          userUuid.isAcceptableOrUnknown(data['user_uuid']!, _userUuidMeta));
    }
    if (data.containsKey('date_of_birth')) {
      context.handle(
          _dateOfBirthMeta,
          dateOfBirth.isAcceptableOrUnknown(
              data['date_of_birth']!, _dateOfBirthMeta));
    }
    if (data.containsKey('mobile_number')) {
      context.handle(
          _mobileNumberMeta,
          mobileNumber.isAcceptableOrUnknown(
              data['mobile_number']!, _mobileNumberMeta));
    }
    if (data.containsKey('alt_contact_number')) {
      context.handle(
          _altContactNumberMeta,
          altContactNumber.isAcceptableOrUnknown(
              data['alt_contact_number']!, _altContactNumberMeta));
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('father_name')) {
      context.handle(
          _fatherNameMeta,
          fatherName.isAcceptableOrUnknown(
              data['father_name']!, _fatherNameMeta));
    }
    if (data.containsKey('husband_name')) {
      context.handle(
          _husbandNameMeta,
          husbandName.isAcceptableOrUnknown(
              data['husband_name']!, _husbandNameMeta));
    }
    if (data.containsKey('photo')) {
      context.handle(
          _photoMeta, photo.isAcceptableOrUnknown(data['photo']!, _photoMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    context.handle(_bloodGroupMeta, const VerificationResult.success());
    context.handle(_genderMeta, const VerificationResult.success());
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  IndividualData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return IndividualData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      individualId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}individual_id']),
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_id']),
      userUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_uuid']),
      dateOfBirth: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}date_of_birth']),
      mobileNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mobile_number']),
      altContactNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}alt_contact_number']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      fatherName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}father_name']),
      husbandName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}husband_name']),
      photo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}photo']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      bloodGroup: $IndividualTable.$converterbloodGroupn.fromSql(
          attachedDatabase.typeMapping
              .read(DriftSqlType.int, data['${effectivePrefix}blood_group'])),
      gender: $IndividualTable.$convertergendern.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}gender'])),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $IndividualTable createAlias(String alias) {
    return $IndividualTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<BloodGroup, int, int> $converterbloodGroup =
      const EnumIndexConverter<BloodGroup>(BloodGroup.values);
  static JsonTypeConverter2<BloodGroup?, int?, int?> $converterbloodGroupn =
      JsonTypeConverter2.asNullable($converterbloodGroup);
  static JsonTypeConverter2<Gender, int, int> $convertergender =
      const EnumIndexConverter<Gender>(Gender.values);
  static JsonTypeConverter2<Gender?, int?, int?> $convertergendern =
      JsonTypeConverter2.asNullable($convertergender);
}

class IndividualData extends DataClass implements Insertable<IndividualData> {
  final String? id;
  final String? individualId;
  final String? userId;
  final String? userUuid;
  final String? dateOfBirth;
  final String? mobileNumber;
  final String? altContactNumber;
  final String? email;
  final String? fatherName;
  final String? husbandName;
  final String? photo;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final BloodGroup? bloodGroup;
  final Gender? gender;
  final String? additionalFields;
  const IndividualData(
      {this.id,
      this.individualId,
      this.userId,
      this.userUuid,
      this.dateOfBirth,
      this.mobileNumber,
      this.altContactNumber,
      this.email,
      this.fatherName,
      this.husbandName,
      this.photo,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.bloodGroup,
      this.gender,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || individualId != null) {
      map['individual_id'] = Variable<String>(individualId);
    }
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<String>(userId);
    }
    if (!nullToAbsent || userUuid != null) {
      map['user_uuid'] = Variable<String>(userUuid);
    }
    if (!nullToAbsent || dateOfBirth != null) {
      map['date_of_birth'] = Variable<String>(dateOfBirth);
    }
    if (!nullToAbsent || mobileNumber != null) {
      map['mobile_number'] = Variable<String>(mobileNumber);
    }
    if (!nullToAbsent || altContactNumber != null) {
      map['alt_contact_number'] = Variable<String>(altContactNumber);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || fatherName != null) {
      map['father_name'] = Variable<String>(fatherName);
    }
    if (!nullToAbsent || husbandName != null) {
      map['husband_name'] = Variable<String>(husbandName);
    }
    if (!nullToAbsent || photo != null) {
      map['photo'] = Variable<String>(photo);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || bloodGroup != null) {
      map['blood_group'] = Variable<int>(
          $IndividualTable.$converterbloodGroupn.toSql(bloodGroup));
    }
    if (!nullToAbsent || gender != null) {
      map['gender'] =
          Variable<int>($IndividualTable.$convertergendern.toSql(gender));
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  IndividualCompanion toCompanion(bool nullToAbsent) {
    return IndividualCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      individualId: individualId == null && nullToAbsent
          ? const Value.absent()
          : Value(individualId),
      userId:
          userId == null && nullToAbsent ? const Value.absent() : Value(userId),
      userUuid: userUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(userUuid),
      dateOfBirth: dateOfBirth == null && nullToAbsent
          ? const Value.absent()
          : Value(dateOfBirth),
      mobileNumber: mobileNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(mobileNumber),
      altContactNumber: altContactNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(altContactNumber),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      fatherName: fatherName == null && nullToAbsent
          ? const Value.absent()
          : Value(fatherName),
      husbandName: husbandName == null && nullToAbsent
          ? const Value.absent()
          : Value(husbandName),
      photo:
          photo == null && nullToAbsent ? const Value.absent() : Value(photo),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      bloodGroup: bloodGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(bloodGroup),
      gender:
          gender == null && nullToAbsent ? const Value.absent() : Value(gender),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory IndividualData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return IndividualData(
      id: serializer.fromJson<String?>(json['id']),
      individualId: serializer.fromJson<String?>(json['individualId']),
      userId: serializer.fromJson<String?>(json['userId']),
      userUuid: serializer.fromJson<String?>(json['userUuid']),
      dateOfBirth: serializer.fromJson<String?>(json['dateOfBirth']),
      mobileNumber: serializer.fromJson<String?>(json['mobileNumber']),
      altContactNumber: serializer.fromJson<String?>(json['altContactNumber']),
      email: serializer.fromJson<String?>(json['email']),
      fatherName: serializer.fromJson<String?>(json['fatherName']),
      husbandName: serializer.fromJson<String?>(json['husbandName']),
      photo: serializer.fromJson<String?>(json['photo']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      bloodGroup: $IndividualTable.$converterbloodGroupn
          .fromJson(serializer.fromJson<int?>(json['bloodGroup'])),
      gender: $IndividualTable.$convertergendern
          .fromJson(serializer.fromJson<int?>(json['gender'])),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'individualId': serializer.toJson<String?>(individualId),
      'userId': serializer.toJson<String?>(userId),
      'userUuid': serializer.toJson<String?>(userUuid),
      'dateOfBirth': serializer.toJson<String?>(dateOfBirth),
      'mobileNumber': serializer.toJson<String?>(mobileNumber),
      'altContactNumber': serializer.toJson<String?>(altContactNumber),
      'email': serializer.toJson<String?>(email),
      'fatherName': serializer.toJson<String?>(fatherName),
      'husbandName': serializer.toJson<String?>(husbandName),
      'photo': serializer.toJson<String?>(photo),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'bloodGroup': serializer.toJson<int?>(
          $IndividualTable.$converterbloodGroupn.toJson(bloodGroup)),
      'gender': serializer
          .toJson<int?>($IndividualTable.$convertergendern.toJson(gender)),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  IndividualData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> individualId = const Value.absent(),
          Value<String?> userId = const Value.absent(),
          Value<String?> userUuid = const Value.absent(),
          Value<String?> dateOfBirth = const Value.absent(),
          Value<String?> mobileNumber = const Value.absent(),
          Value<String?> altContactNumber = const Value.absent(),
          Value<String?> email = const Value.absent(),
          Value<String?> fatherName = const Value.absent(),
          Value<String?> husbandName = const Value.absent(),
          Value<String?> photo = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<BloodGroup?> bloodGroup = const Value.absent(),
          Value<Gender?> gender = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      IndividualData(
        id: id.present ? id.value : this.id,
        individualId:
            individualId.present ? individualId.value : this.individualId,
        userId: userId.present ? userId.value : this.userId,
        userUuid: userUuid.present ? userUuid.value : this.userUuid,
        dateOfBirth: dateOfBirth.present ? dateOfBirth.value : this.dateOfBirth,
        mobileNumber:
            mobileNumber.present ? mobileNumber.value : this.mobileNumber,
        altContactNumber: altContactNumber.present
            ? altContactNumber.value
            : this.altContactNumber,
        email: email.present ? email.value : this.email,
        fatherName: fatherName.present ? fatherName.value : this.fatherName,
        husbandName: husbandName.present ? husbandName.value : this.husbandName,
        photo: photo.present ? photo.value : this.photo,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        bloodGroup: bloodGroup.present ? bloodGroup.value : this.bloodGroup,
        gender: gender.present ? gender.value : this.gender,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('IndividualData(')
          ..write('id: $id, ')
          ..write('individualId: $individualId, ')
          ..write('userId: $userId, ')
          ..write('userUuid: $userUuid, ')
          ..write('dateOfBirth: $dateOfBirth, ')
          ..write('mobileNumber: $mobileNumber, ')
          ..write('altContactNumber: $altContactNumber, ')
          ..write('email: $email, ')
          ..write('fatherName: $fatherName, ')
          ..write('husbandName: $husbandName, ')
          ..write('photo: $photo, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('bloodGroup: $bloodGroup, ')
          ..write('gender: $gender, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        individualId,
        userId,
        userUuid,
        dateOfBirth,
        mobileNumber,
        altContactNumber,
        email,
        fatherName,
        husbandName,
        photo,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        bloodGroup,
        gender,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is IndividualData &&
          other.id == this.id &&
          other.individualId == this.individualId &&
          other.userId == this.userId &&
          other.userUuid == this.userUuid &&
          other.dateOfBirth == this.dateOfBirth &&
          other.mobileNumber == this.mobileNumber &&
          other.altContactNumber == this.altContactNumber &&
          other.email == this.email &&
          other.fatherName == this.fatherName &&
          other.husbandName == this.husbandName &&
          other.photo == this.photo &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.bloodGroup == this.bloodGroup &&
          other.gender == this.gender &&
          other.additionalFields == this.additionalFields);
}

class IndividualCompanion extends UpdateCompanion<IndividualData> {
  final Value<String?> id;
  final Value<String?> individualId;
  final Value<String?> userId;
  final Value<String?> userUuid;
  final Value<String?> dateOfBirth;
  final Value<String?> mobileNumber;
  final Value<String?> altContactNumber;
  final Value<String?> email;
  final Value<String?> fatherName;
  final Value<String?> husbandName;
  final Value<String?> photo;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<BloodGroup?> bloodGroup;
  final Value<Gender?> gender;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const IndividualCompanion({
    this.id = const Value.absent(),
    this.individualId = const Value.absent(),
    this.userId = const Value.absent(),
    this.userUuid = const Value.absent(),
    this.dateOfBirth = const Value.absent(),
    this.mobileNumber = const Value.absent(),
    this.altContactNumber = const Value.absent(),
    this.email = const Value.absent(),
    this.fatherName = const Value.absent(),
    this.husbandName = const Value.absent(),
    this.photo = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.bloodGroup = const Value.absent(),
    this.gender = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  IndividualCompanion.insert({
    this.id = const Value.absent(),
    this.individualId = const Value.absent(),
    this.userId = const Value.absent(),
    this.userUuid = const Value.absent(),
    this.dateOfBirth = const Value.absent(),
    this.mobileNumber = const Value.absent(),
    this.altContactNumber = const Value.absent(),
    this.email = const Value.absent(),
    this.fatherName = const Value.absent(),
    this.husbandName = const Value.absent(),
    this.photo = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.bloodGroup = const Value.absent(),
    this.gender = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<IndividualData> custom({
    Expression<String>? id,
    Expression<String>? individualId,
    Expression<String>? userId,
    Expression<String>? userUuid,
    Expression<String>? dateOfBirth,
    Expression<String>? mobileNumber,
    Expression<String>? altContactNumber,
    Expression<String>? email,
    Expression<String>? fatherName,
    Expression<String>? husbandName,
    Expression<String>? photo,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? bloodGroup,
    Expression<int>? gender,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (individualId != null) 'individual_id': individualId,
      if (userId != null) 'user_id': userId,
      if (userUuid != null) 'user_uuid': userUuid,
      if (dateOfBirth != null) 'date_of_birth': dateOfBirth,
      if (mobileNumber != null) 'mobile_number': mobileNumber,
      if (altContactNumber != null) 'alt_contact_number': altContactNumber,
      if (email != null) 'email': email,
      if (fatherName != null) 'father_name': fatherName,
      if (husbandName != null) 'husband_name': husbandName,
      if (photo != null) 'photo': photo,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (bloodGroup != null) 'blood_group': bloodGroup,
      if (gender != null) 'gender': gender,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  IndividualCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? individualId,
      Value<String?>? userId,
      Value<String?>? userUuid,
      Value<String?>? dateOfBirth,
      Value<String?>? mobileNumber,
      Value<String?>? altContactNumber,
      Value<String?>? email,
      Value<String?>? fatherName,
      Value<String?>? husbandName,
      Value<String?>? photo,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<BloodGroup?>? bloodGroup,
      Value<Gender?>? gender,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return IndividualCompanion(
      id: id ?? this.id,
      individualId: individualId ?? this.individualId,
      userId: userId ?? this.userId,
      userUuid: userUuid ?? this.userUuid,
      dateOfBirth: dateOfBirth ?? this.dateOfBirth,
      mobileNumber: mobileNumber ?? this.mobileNumber,
      altContactNumber: altContactNumber ?? this.altContactNumber,
      email: email ?? this.email,
      fatherName: fatherName ?? this.fatherName,
      husbandName: husbandName ?? this.husbandName,
      photo: photo ?? this.photo,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      bloodGroup: bloodGroup ?? this.bloodGroup,
      gender: gender ?? this.gender,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (individualId.present) {
      map['individual_id'] = Variable<String>(individualId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (userUuid.present) {
      map['user_uuid'] = Variable<String>(userUuid.value);
    }
    if (dateOfBirth.present) {
      map['date_of_birth'] = Variable<String>(dateOfBirth.value);
    }
    if (mobileNumber.present) {
      map['mobile_number'] = Variable<String>(mobileNumber.value);
    }
    if (altContactNumber.present) {
      map['alt_contact_number'] = Variable<String>(altContactNumber.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (fatherName.present) {
      map['father_name'] = Variable<String>(fatherName.value);
    }
    if (husbandName.present) {
      map['husband_name'] = Variable<String>(husbandName.value);
    }
    if (photo.present) {
      map['photo'] = Variable<String>(photo.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (bloodGroup.present) {
      map['blood_group'] = Variable<int>(
          $IndividualTable.$converterbloodGroupn.toSql(bloodGroup.value));
    }
    if (gender.present) {
      map['gender'] =
          Variable<int>($IndividualTable.$convertergendern.toSql(gender.value));
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('IndividualCompanion(')
          ..write('id: $id, ')
          ..write('individualId: $individualId, ')
          ..write('userId: $userId, ')
          ..write('userUuid: $userUuid, ')
          ..write('dateOfBirth: $dateOfBirth, ')
          ..write('mobileNumber: $mobileNumber, ')
          ..write('altContactNumber: $altContactNumber, ')
          ..write('email: $email, ')
          ..write('fatherName: $fatherName, ')
          ..write('husbandName: $husbandName, ')
          ..write('photo: $photo, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('bloodGroup: $bloodGroup, ')
          ..write('gender: $gender, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $IdentifierTable extends Identifier
    with TableInfo<$IdentifierTable, IdentifierData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $IdentifierTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _individualIdMeta =
      const VerificationMeta('individualId');
  @override
  late final GeneratedColumn<String> individualId = GeneratedColumn<String>(
      'individual_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _individualClientReferenceIdMeta =
      const VerificationMeta('individualClientReferenceId');
  @override
  late final GeneratedColumn<String> individualClientReferenceId =
      GeneratedColumn<String>(
          'individual_client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _identifierTypeMeta =
      const VerificationMeta('identifierType');
  @override
  late final GeneratedColumn<String> identifierType = GeneratedColumn<String>(
      'identifier_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _identifierIdMeta =
      const VerificationMeta('identifierId');
  @override
  late final GeneratedColumn<String> identifierId = GeneratedColumn<String>(
      'identifier_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        individualId,
        individualClientReferenceId,
        identifierType,
        identifierId,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'identifier';
  @override
  VerificationContext validateIntegrity(Insertable<IdentifierData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('individual_id')) {
      context.handle(
          _individualIdMeta,
          individualId.isAcceptableOrUnknown(
              data['individual_id']!, _individualIdMeta));
    }
    if (data.containsKey('individual_client_reference_id')) {
      context.handle(
          _individualClientReferenceIdMeta,
          individualClientReferenceId.isAcceptableOrUnknown(
              data['individual_client_reference_id']!,
              _individualClientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_individualClientReferenceIdMeta);
    }
    if (data.containsKey('identifier_type')) {
      context.handle(
          _identifierTypeMeta,
          identifierType.isAcceptableOrUnknown(
              data['identifier_type']!, _identifierTypeMeta));
    }
    if (data.containsKey('identifier_id')) {
      context.handle(
          _identifierIdMeta,
          identifierId.isAcceptableOrUnknown(
              data['identifier_id']!, _identifierIdMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey =>
      {individualClientReferenceId, identifierType};
  @override
  IdentifierData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return IdentifierData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      individualId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}individual_id']),
      individualClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}individual_client_reference_id'])!,
      identifierType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}identifier_type']),
      identifierId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}identifier_id']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $IdentifierTable createAlias(String alias) {
    return $IdentifierTable(attachedDatabase, alias);
  }
}

class IdentifierData extends DataClass implements Insertable<IdentifierData> {
  final String? id;
  final String? individualId;
  final String individualClientReferenceId;
  final String? identifierType;
  final String? identifierId;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const IdentifierData(
      {this.id,
      this.individualId,
      required this.individualClientReferenceId,
      this.identifierType,
      this.identifierId,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || individualId != null) {
      map['individual_id'] = Variable<String>(individualId);
    }
    map['individual_client_reference_id'] =
        Variable<String>(individualClientReferenceId);
    if (!nullToAbsent || identifierType != null) {
      map['identifier_type'] = Variable<String>(identifierType);
    }
    if (!nullToAbsent || identifierId != null) {
      map['identifier_id'] = Variable<String>(identifierId);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  IdentifierCompanion toCompanion(bool nullToAbsent) {
    return IdentifierCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      individualId: individualId == null && nullToAbsent
          ? const Value.absent()
          : Value(individualId),
      individualClientReferenceId: Value(individualClientReferenceId),
      identifierType: identifierType == null && nullToAbsent
          ? const Value.absent()
          : Value(identifierType),
      identifierId: identifierId == null && nullToAbsent
          ? const Value.absent()
          : Value(identifierId),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory IdentifierData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return IdentifierData(
      id: serializer.fromJson<String?>(json['id']),
      individualId: serializer.fromJson<String?>(json['individualId']),
      individualClientReferenceId:
          serializer.fromJson<String>(json['individualClientReferenceId']),
      identifierType: serializer.fromJson<String?>(json['identifierType']),
      identifierId: serializer.fromJson<String?>(json['identifierId']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'individualId': serializer.toJson<String?>(individualId),
      'individualClientReferenceId':
          serializer.toJson<String>(individualClientReferenceId),
      'identifierType': serializer.toJson<String?>(identifierType),
      'identifierId': serializer.toJson<String?>(identifierId),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  IdentifierData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> individualId = const Value.absent(),
          String? individualClientReferenceId,
          Value<String?> identifierType = const Value.absent(),
          Value<String?> identifierId = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      IdentifierData(
        id: id.present ? id.value : this.id,
        individualId:
            individualId.present ? individualId.value : this.individualId,
        individualClientReferenceId:
            individualClientReferenceId ?? this.individualClientReferenceId,
        identifierType:
            identifierType.present ? identifierType.value : this.identifierType,
        identifierId:
            identifierId.present ? identifierId.value : this.identifierId,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('IdentifierData(')
          ..write('id: $id, ')
          ..write('individualId: $individualId, ')
          ..write('individualClientReferenceId: $individualClientReferenceId, ')
          ..write('identifierType: $identifierType, ')
          ..write('identifierId: $identifierId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      individualId,
      individualClientReferenceId,
      identifierType,
      identifierId,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is IdentifierData &&
          other.id == this.id &&
          other.individualId == this.individualId &&
          other.individualClientReferenceId ==
              this.individualClientReferenceId &&
          other.identifierType == this.identifierType &&
          other.identifierId == this.identifierId &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class IdentifierCompanion extends UpdateCompanion<IdentifierData> {
  final Value<String?> id;
  final Value<String?> individualId;
  final Value<String> individualClientReferenceId;
  final Value<String?> identifierType;
  final Value<String?> identifierId;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const IdentifierCompanion({
    this.id = const Value.absent(),
    this.individualId = const Value.absent(),
    this.individualClientReferenceId = const Value.absent(),
    this.identifierType = const Value.absent(),
    this.identifierId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  IdentifierCompanion.insert({
    this.id = const Value.absent(),
    this.individualId = const Value.absent(),
    required String individualClientReferenceId,
    this.identifierType = const Value.absent(),
    this.identifierId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : individualClientReferenceId = Value(individualClientReferenceId),
        clientReferenceId = Value(clientReferenceId);
  static Insertable<IdentifierData> custom({
    Expression<String>? id,
    Expression<String>? individualId,
    Expression<String>? individualClientReferenceId,
    Expression<String>? identifierType,
    Expression<String>? identifierId,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (individualId != null) 'individual_id': individualId,
      if (individualClientReferenceId != null)
        'individual_client_reference_id': individualClientReferenceId,
      if (identifierType != null) 'identifier_type': identifierType,
      if (identifierId != null) 'identifier_id': identifierId,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  IdentifierCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? individualId,
      Value<String>? individualClientReferenceId,
      Value<String?>? identifierType,
      Value<String?>? identifierId,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return IdentifierCompanion(
      id: id ?? this.id,
      individualId: individualId ?? this.individualId,
      individualClientReferenceId:
          individualClientReferenceId ?? this.individualClientReferenceId,
      identifierType: identifierType ?? this.identifierType,
      identifierId: identifierId ?? this.identifierId,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (individualId.present) {
      map['individual_id'] = Variable<String>(individualId.value);
    }
    if (individualClientReferenceId.present) {
      map['individual_client_reference_id'] =
          Variable<String>(individualClientReferenceId.value);
    }
    if (identifierType.present) {
      map['identifier_type'] = Variable<String>(identifierType.value);
    }
    if (identifierId.present) {
      map['identifier_id'] = Variable<String>(identifierId.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('IdentifierCompanion(')
          ..write('id: $id, ')
          ..write('individualId: $individualId, ')
          ..write('individualClientReferenceId: $individualClientReferenceId, ')
          ..write('identifierType: $identifierType, ')
          ..write('identifierId: $identifierId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StockTable extends Stock with TableInfo<$StockTable, StockData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _facilityIdMeta =
      const VerificationMeta('facilityId');
  @override
  late final GeneratedColumn<String> facilityId = GeneratedColumn<String>(
      'facility_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _productVariantIdMeta =
      const VerificationMeta('productVariantId');
  @override
  late final GeneratedColumn<String> productVariantId = GeneratedColumn<String>(
      'product_variant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdTypeMeta =
      const VerificationMeta('referenceIdType');
  @override
  late final GeneratedColumn<String> referenceIdType = GeneratedColumn<String>(
      'reference_id_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _transactingPartyIdMeta =
      const VerificationMeta('transactingPartyId');
  @override
  late final GeneratedColumn<String> transactingPartyId =
      GeneratedColumn<String>('transacting_party_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _transactingPartyTypeMeta =
      const VerificationMeta('transactingPartyType');
  @override
  late final GeneratedColumn<String> transactingPartyType =
      GeneratedColumn<String>('transacting_party_type', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  @override
  late final GeneratedColumn<String> quantity = GeneratedColumn<String>(
      'quantity', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _waybillNumberMeta =
      const VerificationMeta('waybillNumber');
  @override
  late final GeneratedColumn<String> waybillNumber = GeneratedColumn<String>(
      'waybill_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _receiverIdMeta =
      const VerificationMeta('receiverId');
  @override
  late final GeneratedColumn<String> receiverId = GeneratedColumn<String>(
      'receiver_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _receiverTypeMeta =
      const VerificationMeta('receiverType');
  @override
  late final GeneratedColumn<String> receiverType = GeneratedColumn<String>(
      'receiver_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _senderIdMeta =
      const VerificationMeta('senderId');
  @override
  late final GeneratedColumn<String> senderId = GeneratedColumn<String>(
      'sender_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _senderTypeMeta =
      const VerificationMeta('senderType');
  @override
  late final GeneratedColumn<String> senderType = GeneratedColumn<String>(
      'sender_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _dateOfEntryMeta =
      const VerificationMeta('dateOfEntry');
  @override
  late final GeneratedColumn<int> dateOfEntry = GeneratedColumn<int>(
      'date_of_entry', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _transactionTypeMeta =
      const VerificationMeta('transactionType');
  @override
  late final GeneratedColumn<String> transactionType = GeneratedColumn<String>(
      'transaction_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _transactionReasonMeta =
      const VerificationMeta('transactionReason');
  @override
  late final GeneratedColumn<String> transactionReason =
      GeneratedColumn<String>('transaction_reason', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        facilityId,
        productVariantId,
        referenceId,
        referenceIdType,
        transactingPartyId,
        transactingPartyType,
        quantity,
        waybillNumber,
        receiverId,
        receiverType,
        senderId,
        senderType,
        dateOfEntry,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        transactionType,
        transactionReason,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock';
  @override
  VerificationContext validateIntegrity(Insertable<StockData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('facility_id')) {
      context.handle(
          _facilityIdMeta,
          facilityId.isAcceptableOrUnknown(
              data['facility_id']!, _facilityIdMeta));
    }
    if (data.containsKey('product_variant_id')) {
      context.handle(
          _productVariantIdMeta,
          productVariantId.isAcceptableOrUnknown(
              data['product_variant_id']!, _productVariantIdMeta));
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    }
    if (data.containsKey('reference_id_type')) {
      context.handle(
          _referenceIdTypeMeta,
          referenceIdType.isAcceptableOrUnknown(
              data['reference_id_type']!, _referenceIdTypeMeta));
    }
    if (data.containsKey('transacting_party_id')) {
      context.handle(
          _transactingPartyIdMeta,
          transactingPartyId.isAcceptableOrUnknown(
              data['transacting_party_id']!, _transactingPartyIdMeta));
    }
    if (data.containsKey('transacting_party_type')) {
      context.handle(
          _transactingPartyTypeMeta,
          transactingPartyType.isAcceptableOrUnknown(
              data['transacting_party_type']!, _transactingPartyTypeMeta));
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    }
    if (data.containsKey('waybill_number')) {
      context.handle(
          _waybillNumberMeta,
          waybillNumber.isAcceptableOrUnknown(
              data['waybill_number']!, _waybillNumberMeta));
    }
    if (data.containsKey('receiver_id')) {
      context.handle(
          _receiverIdMeta,
          receiverId.isAcceptableOrUnknown(
              data['receiver_id']!, _receiverIdMeta));
    }
    if (data.containsKey('receiver_type')) {
      context.handle(
          _receiverTypeMeta,
          receiverType.isAcceptableOrUnknown(
              data['receiver_type']!, _receiverTypeMeta));
    }
    if (data.containsKey('sender_id')) {
      context.handle(_senderIdMeta,
          senderId.isAcceptableOrUnknown(data['sender_id']!, _senderIdMeta));
    }
    if (data.containsKey('sender_type')) {
      context.handle(
          _senderTypeMeta,
          senderType.isAcceptableOrUnknown(
              data['sender_type']!, _senderTypeMeta));
    }
    if (data.containsKey('date_of_entry')) {
      context.handle(
          _dateOfEntryMeta,
          dateOfEntry.isAcceptableOrUnknown(
              data['date_of_entry']!, _dateOfEntryMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('transaction_type')) {
      context.handle(
          _transactionTypeMeta,
          transactionType.isAcceptableOrUnknown(
              data['transaction_type']!, _transactionTypeMeta));
    }
    if (data.containsKey('transaction_reason')) {
      context.handle(
          _transactionReasonMeta,
          transactionReason.isAcceptableOrUnknown(
              data['transaction_reason']!, _transactionReasonMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  StockData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      facilityId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}facility_id']),
      productVariantId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}product_variant_id']),
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id']),
      referenceIdType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}reference_id_type']),
      transactingPartyId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transacting_party_id']),
      transactingPartyType: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}transacting_party_type']),
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}quantity']),
      waybillNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}waybill_number']),
      receiverId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}receiver_id']),
      receiverType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}receiver_type']),
      senderId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sender_id']),
      senderType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sender_type']),
      dateOfEntry: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}date_of_entry']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      transactionType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_type']),
      transactionReason: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_reason']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $StockTable createAlias(String alias) {
    return $StockTable(attachedDatabase, alias);
  }
}

class StockData extends DataClass implements Insertable<StockData> {
  final String? id;
  final String? tenantId;
  final String? facilityId;
  final String? productVariantId;
  final String? referenceId;
  final String? referenceIdType;
  final String? transactingPartyId;
  final String? transactingPartyType;
  final String? quantity;
  final String? waybillNumber;
  final String? receiverId;
  final String? receiverType;
  final String? senderId;
  final String? senderType;
  final int? dateOfEntry;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? transactionType;
  final String? transactionReason;
  final String? additionalFields;
  const StockData(
      {this.id,
      this.tenantId,
      this.facilityId,
      this.productVariantId,
      this.referenceId,
      this.referenceIdType,
      this.transactingPartyId,
      this.transactingPartyType,
      this.quantity,
      this.waybillNumber,
      this.receiverId,
      this.receiverType,
      this.senderId,
      this.senderType,
      this.dateOfEntry,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.isDeleted,
      this.rowVersion,
      this.transactionType,
      this.transactionReason,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || facilityId != null) {
      map['facility_id'] = Variable<String>(facilityId);
    }
    if (!nullToAbsent || productVariantId != null) {
      map['product_variant_id'] = Variable<String>(productVariantId);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    if (!nullToAbsent || referenceIdType != null) {
      map['reference_id_type'] = Variable<String>(referenceIdType);
    }
    if (!nullToAbsent || transactingPartyId != null) {
      map['transacting_party_id'] = Variable<String>(transactingPartyId);
    }
    if (!nullToAbsent || transactingPartyType != null) {
      map['transacting_party_type'] = Variable<String>(transactingPartyType);
    }
    if (!nullToAbsent || quantity != null) {
      map['quantity'] = Variable<String>(quantity);
    }
    if (!nullToAbsent || waybillNumber != null) {
      map['waybill_number'] = Variable<String>(waybillNumber);
    }
    if (!nullToAbsent || receiverId != null) {
      map['receiver_id'] = Variable<String>(receiverId);
    }
    if (!nullToAbsent || receiverType != null) {
      map['receiver_type'] = Variable<String>(receiverType);
    }
    if (!nullToAbsent || senderId != null) {
      map['sender_id'] = Variable<String>(senderId);
    }
    if (!nullToAbsent || senderType != null) {
      map['sender_type'] = Variable<String>(senderType);
    }
    if (!nullToAbsent || dateOfEntry != null) {
      map['date_of_entry'] = Variable<int>(dateOfEntry);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || transactionType != null) {
      map['transaction_type'] = Variable<String>(transactionType);
    }
    if (!nullToAbsent || transactionReason != null) {
      map['transaction_reason'] = Variable<String>(transactionReason);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  StockCompanion toCompanion(bool nullToAbsent) {
    return StockCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      facilityId: facilityId == null && nullToAbsent
          ? const Value.absent()
          : Value(facilityId),
      productVariantId: productVariantId == null && nullToAbsent
          ? const Value.absent()
          : Value(productVariantId),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      referenceIdType: referenceIdType == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceIdType),
      transactingPartyId: transactingPartyId == null && nullToAbsent
          ? const Value.absent()
          : Value(transactingPartyId),
      transactingPartyType: transactingPartyType == null && nullToAbsent
          ? const Value.absent()
          : Value(transactingPartyType),
      quantity: quantity == null && nullToAbsent
          ? const Value.absent()
          : Value(quantity),
      waybillNumber: waybillNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(waybillNumber),
      receiverId: receiverId == null && nullToAbsent
          ? const Value.absent()
          : Value(receiverId),
      receiverType: receiverType == null && nullToAbsent
          ? const Value.absent()
          : Value(receiverType),
      senderId: senderId == null && nullToAbsent
          ? const Value.absent()
          : Value(senderId),
      senderType: senderType == null && nullToAbsent
          ? const Value.absent()
          : Value(senderType),
      dateOfEntry: dateOfEntry == null && nullToAbsent
          ? const Value.absent()
          : Value(dateOfEntry),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      transactionType: transactionType == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionType),
      transactionReason: transactionReason == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionReason),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory StockData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      facilityId: serializer.fromJson<String?>(json['facilityId']),
      productVariantId: serializer.fromJson<String?>(json['productVariantId']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      referenceIdType: serializer.fromJson<String?>(json['referenceIdType']),
      transactingPartyId:
          serializer.fromJson<String?>(json['transactingPartyId']),
      transactingPartyType:
          serializer.fromJson<String?>(json['transactingPartyType']),
      quantity: serializer.fromJson<String?>(json['quantity']),
      waybillNumber: serializer.fromJson<String?>(json['waybillNumber']),
      receiverId: serializer.fromJson<String?>(json['receiverId']),
      receiverType: serializer.fromJson<String?>(json['receiverType']),
      senderId: serializer.fromJson<String?>(json['senderId']),
      senderType: serializer.fromJson<String?>(json['senderType']),
      dateOfEntry: serializer.fromJson<int?>(json['dateOfEntry']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      transactionType: serializer.fromJson<String?>(json['transactionType']),
      transactionReason:
          serializer.fromJson<String?>(json['transactionReason']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String?>(tenantId),
      'facilityId': serializer.toJson<String?>(facilityId),
      'productVariantId': serializer.toJson<String?>(productVariantId),
      'referenceId': serializer.toJson<String?>(referenceId),
      'referenceIdType': serializer.toJson<String?>(referenceIdType),
      'transactingPartyId': serializer.toJson<String?>(transactingPartyId),
      'transactingPartyType': serializer.toJson<String?>(transactingPartyType),
      'quantity': serializer.toJson<String?>(quantity),
      'waybillNumber': serializer.toJson<String?>(waybillNumber),
      'receiverId': serializer.toJson<String?>(receiverId),
      'receiverType': serializer.toJson<String?>(receiverType),
      'senderId': serializer.toJson<String?>(senderId),
      'senderType': serializer.toJson<String?>(senderType),
      'dateOfEntry': serializer.toJson<int?>(dateOfEntry),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'transactionType': serializer.toJson<String?>(transactionType),
      'transactionReason': serializer.toJson<String?>(transactionReason),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  StockData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> facilityId = const Value.absent(),
          Value<String?> productVariantId = const Value.absent(),
          Value<String?> referenceId = const Value.absent(),
          Value<String?> referenceIdType = const Value.absent(),
          Value<String?> transactingPartyId = const Value.absent(),
          Value<String?> transactingPartyType = const Value.absent(),
          Value<String?> quantity = const Value.absent(),
          Value<String?> waybillNumber = const Value.absent(),
          Value<String?> receiverId = const Value.absent(),
          Value<String?> receiverType = const Value.absent(),
          Value<String?> senderId = const Value.absent(),
          Value<String?> senderType = const Value.absent(),
          Value<int?> dateOfEntry = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> transactionType = const Value.absent(),
          Value<String?> transactionReason = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      StockData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        facilityId: facilityId.present ? facilityId.value : this.facilityId,
        productVariantId: productVariantId.present
            ? productVariantId.value
            : this.productVariantId,
        referenceId: referenceId.present ? referenceId.value : this.referenceId,
        referenceIdType: referenceIdType.present
            ? referenceIdType.value
            : this.referenceIdType,
        transactingPartyId: transactingPartyId.present
            ? transactingPartyId.value
            : this.transactingPartyId,
        transactingPartyType: transactingPartyType.present
            ? transactingPartyType.value
            : this.transactingPartyType,
        quantity: quantity.present ? quantity.value : this.quantity,
        waybillNumber:
            waybillNumber.present ? waybillNumber.value : this.waybillNumber,
        receiverId: receiverId.present ? receiverId.value : this.receiverId,
        receiverType:
            receiverType.present ? receiverType.value : this.receiverType,
        senderId: senderId.present ? senderId.value : this.senderId,
        senderType: senderType.present ? senderType.value : this.senderType,
        dateOfEntry: dateOfEntry.present ? dateOfEntry.value : this.dateOfEntry,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        transactionType: transactionType.present
            ? transactionType.value
            : this.transactionType,
        transactionReason: transactionReason.present
            ? transactionReason.value
            : this.transactionReason,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('StockData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('facilityId: $facilityId, ')
          ..write('productVariantId: $productVariantId, ')
          ..write('referenceId: $referenceId, ')
          ..write('referenceIdType: $referenceIdType, ')
          ..write('transactingPartyId: $transactingPartyId, ')
          ..write('transactingPartyType: $transactingPartyType, ')
          ..write('quantity: $quantity, ')
          ..write('waybillNumber: $waybillNumber, ')
          ..write('receiverId: $receiverId, ')
          ..write('receiverType: $receiverType, ')
          ..write('senderId: $senderId, ')
          ..write('senderType: $senderType, ')
          ..write('dateOfEntry: $dateOfEntry, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('transactionType: $transactionType, ')
          ..write('transactionReason: $transactionReason, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        tenantId,
        facilityId,
        productVariantId,
        referenceId,
        referenceIdType,
        transactingPartyId,
        transactingPartyType,
        quantity,
        waybillNumber,
        receiverId,
        receiverType,
        senderId,
        senderType,
        dateOfEntry,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        transactionType,
        transactionReason,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.facilityId == this.facilityId &&
          other.productVariantId == this.productVariantId &&
          other.referenceId == this.referenceId &&
          other.referenceIdType == this.referenceIdType &&
          other.transactingPartyId == this.transactingPartyId &&
          other.transactingPartyType == this.transactingPartyType &&
          other.quantity == this.quantity &&
          other.waybillNumber == this.waybillNumber &&
          other.receiverId == this.receiverId &&
          other.receiverType == this.receiverType &&
          other.senderId == this.senderId &&
          other.senderType == this.senderType &&
          other.dateOfEntry == this.dateOfEntry &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.transactionType == this.transactionType &&
          other.transactionReason == this.transactionReason &&
          other.additionalFields == this.additionalFields);
}

class StockCompanion extends UpdateCompanion<StockData> {
  final Value<String?> id;
  final Value<String?> tenantId;
  final Value<String?> facilityId;
  final Value<String?> productVariantId;
  final Value<String?> referenceId;
  final Value<String?> referenceIdType;
  final Value<String?> transactingPartyId;
  final Value<String?> transactingPartyType;
  final Value<String?> quantity;
  final Value<String?> waybillNumber;
  final Value<String?> receiverId;
  final Value<String?> receiverType;
  final Value<String?> senderId;
  final Value<String?> senderType;
  final Value<int?> dateOfEntry;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> transactionType;
  final Value<String?> transactionReason;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const StockCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.facilityId = const Value.absent(),
    this.productVariantId = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.referenceIdType = const Value.absent(),
    this.transactingPartyId = const Value.absent(),
    this.transactingPartyType = const Value.absent(),
    this.quantity = const Value.absent(),
    this.waybillNumber = const Value.absent(),
    this.receiverId = const Value.absent(),
    this.receiverType = const Value.absent(),
    this.senderId = const Value.absent(),
    this.senderType = const Value.absent(),
    this.dateOfEntry = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.transactionType = const Value.absent(),
    this.transactionReason = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  StockCompanion.insert({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.facilityId = const Value.absent(),
    this.productVariantId = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.referenceIdType = const Value.absent(),
    this.transactingPartyId = const Value.absent(),
    this.transactingPartyType = const Value.absent(),
    this.quantity = const Value.absent(),
    this.waybillNumber = const Value.absent(),
    this.receiverId = const Value.absent(),
    this.receiverType = const Value.absent(),
    this.senderId = const Value.absent(),
    this.senderType = const Value.absent(),
    this.dateOfEntry = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.transactionType = const Value.absent(),
    this.transactionReason = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<StockData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? facilityId,
    Expression<String>? productVariantId,
    Expression<String>? referenceId,
    Expression<String>? referenceIdType,
    Expression<String>? transactingPartyId,
    Expression<String>? transactingPartyType,
    Expression<String>? quantity,
    Expression<String>? waybillNumber,
    Expression<String>? receiverId,
    Expression<String>? receiverType,
    Expression<String>? senderId,
    Expression<String>? senderType,
    Expression<int>? dateOfEntry,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? transactionType,
    Expression<String>? transactionReason,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (facilityId != null) 'facility_id': facilityId,
      if (productVariantId != null) 'product_variant_id': productVariantId,
      if (referenceId != null) 'reference_id': referenceId,
      if (referenceIdType != null) 'reference_id_type': referenceIdType,
      if (transactingPartyId != null)
        'transacting_party_id': transactingPartyId,
      if (transactingPartyType != null)
        'transacting_party_type': transactingPartyType,
      if (quantity != null) 'quantity': quantity,
      if (waybillNumber != null) 'waybill_number': waybillNumber,
      if (receiverId != null) 'receiver_id': receiverId,
      if (receiverType != null) 'receiver_type': receiverType,
      if (senderId != null) 'sender_id': senderId,
      if (senderType != null) 'sender_type': senderType,
      if (dateOfEntry != null) 'date_of_entry': dateOfEntry,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (transactionType != null) 'transaction_type': transactionType,
      if (transactionReason != null) 'transaction_reason': transactionReason,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StockCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? tenantId,
      Value<String?>? facilityId,
      Value<String?>? productVariantId,
      Value<String?>? referenceId,
      Value<String?>? referenceIdType,
      Value<String?>? transactingPartyId,
      Value<String?>? transactingPartyType,
      Value<String?>? quantity,
      Value<String?>? waybillNumber,
      Value<String?>? receiverId,
      Value<String?>? receiverType,
      Value<String?>? senderId,
      Value<String?>? senderType,
      Value<int?>? dateOfEntry,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? transactionType,
      Value<String?>? transactionReason,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return StockCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      facilityId: facilityId ?? this.facilityId,
      productVariantId: productVariantId ?? this.productVariantId,
      referenceId: referenceId ?? this.referenceId,
      referenceIdType: referenceIdType ?? this.referenceIdType,
      transactingPartyId: transactingPartyId ?? this.transactingPartyId,
      transactingPartyType: transactingPartyType ?? this.transactingPartyType,
      quantity: quantity ?? this.quantity,
      waybillNumber: waybillNumber ?? this.waybillNumber,
      receiverId: receiverId ?? this.receiverId,
      receiverType: receiverType ?? this.receiverType,
      senderId: senderId ?? this.senderId,
      senderType: senderType ?? this.senderType,
      dateOfEntry: dateOfEntry ?? this.dateOfEntry,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      transactionType: transactionType ?? this.transactionType,
      transactionReason: transactionReason ?? this.transactionReason,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (facilityId.present) {
      map['facility_id'] = Variable<String>(facilityId.value);
    }
    if (productVariantId.present) {
      map['product_variant_id'] = Variable<String>(productVariantId.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (referenceIdType.present) {
      map['reference_id_type'] = Variable<String>(referenceIdType.value);
    }
    if (transactingPartyId.present) {
      map['transacting_party_id'] = Variable<String>(transactingPartyId.value);
    }
    if (transactingPartyType.present) {
      map['transacting_party_type'] =
          Variable<String>(transactingPartyType.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<String>(quantity.value);
    }
    if (waybillNumber.present) {
      map['waybill_number'] = Variable<String>(waybillNumber.value);
    }
    if (receiverId.present) {
      map['receiver_id'] = Variable<String>(receiverId.value);
    }
    if (receiverType.present) {
      map['receiver_type'] = Variable<String>(receiverType.value);
    }
    if (senderId.present) {
      map['sender_id'] = Variable<String>(senderId.value);
    }
    if (senderType.present) {
      map['sender_type'] = Variable<String>(senderType.value);
    }
    if (dateOfEntry.present) {
      map['date_of_entry'] = Variable<int>(dateOfEntry.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (transactionType.present) {
      map['transaction_type'] = Variable<String>(transactionType.value);
    }
    if (transactionReason.present) {
      map['transaction_reason'] = Variable<String>(transactionReason.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('facilityId: $facilityId, ')
          ..write('productVariantId: $productVariantId, ')
          ..write('referenceId: $referenceId, ')
          ..write('referenceIdType: $referenceIdType, ')
          ..write('transactingPartyId: $transactingPartyId, ')
          ..write('transactingPartyType: $transactingPartyType, ')
          ..write('quantity: $quantity, ')
          ..write('waybillNumber: $waybillNumber, ')
          ..write('receiverId: $receiverId, ')
          ..write('receiverType: $receiverType, ')
          ..write('senderId: $senderId, ')
          ..write('senderType: $senderType, ')
          ..write('dateOfEntry: $dateOfEntry, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('transactionType: $transactionType, ')
          ..write('transactionReason: $transactionReason, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StockReconciliationTable extends StockReconciliation
    with TableInfo<$StockReconciliationTable, StockReconciliationData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockReconciliationTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _facilityIdMeta =
      const VerificationMeta('facilityId');
  @override
  late final GeneratedColumn<String> facilityId = GeneratedColumn<String>(
      'facility_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _productVariantIdMeta =
      const VerificationMeta('productVariantId');
  @override
  late final GeneratedColumn<String> productVariantId = GeneratedColumn<String>(
      'product_variant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdTypeMeta =
      const VerificationMeta('referenceIdType');
  @override
  late final GeneratedColumn<String> referenceIdType = GeneratedColumn<String>(
      'reference_id_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _physicalCountMeta =
      const VerificationMeta('physicalCount');
  @override
  late final GeneratedColumn<int> physicalCount = GeneratedColumn<int>(
      'physical_count', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _calculatedCountMeta =
      const VerificationMeta('calculatedCount');
  @override
  late final GeneratedColumn<int> calculatedCount = GeneratedColumn<int>(
      'calculated_count', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _commentsOnReconciliationMeta =
      const VerificationMeta('commentsOnReconciliation');
  @override
  late final GeneratedColumn<String> commentsOnReconciliation =
      GeneratedColumn<String>('comments_on_reconciliation', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _dateOfReconciliationMeta =
      const VerificationMeta('dateOfReconciliation');
  @override
  late final GeneratedColumn<int> dateOfReconciliation = GeneratedColumn<int>(
      'date_of_reconciliation', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        facilityId,
        productVariantId,
        referenceId,
        referenceIdType,
        physicalCount,
        calculatedCount,
        commentsOnReconciliation,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        dateOfReconciliation,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_reconciliation';
  @override
  VerificationContext validateIntegrity(
      Insertable<StockReconciliationData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('facility_id')) {
      context.handle(
          _facilityIdMeta,
          facilityId.isAcceptableOrUnknown(
              data['facility_id']!, _facilityIdMeta));
    }
    if (data.containsKey('product_variant_id')) {
      context.handle(
          _productVariantIdMeta,
          productVariantId.isAcceptableOrUnknown(
              data['product_variant_id']!, _productVariantIdMeta));
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    }
    if (data.containsKey('reference_id_type')) {
      context.handle(
          _referenceIdTypeMeta,
          referenceIdType.isAcceptableOrUnknown(
              data['reference_id_type']!, _referenceIdTypeMeta));
    }
    if (data.containsKey('physical_count')) {
      context.handle(
          _physicalCountMeta,
          physicalCount.isAcceptableOrUnknown(
              data['physical_count']!, _physicalCountMeta));
    }
    if (data.containsKey('calculated_count')) {
      context.handle(
          _calculatedCountMeta,
          calculatedCount.isAcceptableOrUnknown(
              data['calculated_count']!, _calculatedCountMeta));
    }
    if (data.containsKey('comments_on_reconciliation')) {
      context.handle(
          _commentsOnReconciliationMeta,
          commentsOnReconciliation.isAcceptableOrUnknown(
              data['comments_on_reconciliation']!,
              _commentsOnReconciliationMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('date_of_reconciliation')) {
      context.handle(
          _dateOfReconciliationMeta,
          dateOfReconciliation.isAcceptableOrUnknown(
              data['date_of_reconciliation']!, _dateOfReconciliationMeta));
    } else if (isInserting) {
      context.missing(_dateOfReconciliationMeta);
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  StockReconciliationData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockReconciliationData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      facilityId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}facility_id']),
      productVariantId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}product_variant_id']),
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id']),
      referenceIdType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}reference_id_type']),
      physicalCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}physical_count']),
      calculatedCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}calculated_count']),
      commentsOnReconciliation: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}comments_on_reconciliation']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      dateOfReconciliation: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}date_of_reconciliation'])!,
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $StockReconciliationTable createAlias(String alias) {
    return $StockReconciliationTable(attachedDatabase, alias);
  }
}

class StockReconciliationData extends DataClass
    implements Insertable<StockReconciliationData> {
  final String? id;
  final String? tenantId;
  final String? facilityId;
  final String? productVariantId;
  final String? referenceId;
  final String? referenceIdType;
  final int? physicalCount;
  final int? calculatedCount;
  final String? commentsOnReconciliation;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final bool? isDeleted;
  final int? rowVersion;
  final int dateOfReconciliation;
  final String? additionalFields;
  const StockReconciliationData(
      {this.id,
      this.tenantId,
      this.facilityId,
      this.productVariantId,
      this.referenceId,
      this.referenceIdType,
      this.physicalCount,
      this.calculatedCount,
      this.commentsOnReconciliation,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.isDeleted,
      this.rowVersion,
      required this.dateOfReconciliation,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || facilityId != null) {
      map['facility_id'] = Variable<String>(facilityId);
    }
    if (!nullToAbsent || productVariantId != null) {
      map['product_variant_id'] = Variable<String>(productVariantId);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    if (!nullToAbsent || referenceIdType != null) {
      map['reference_id_type'] = Variable<String>(referenceIdType);
    }
    if (!nullToAbsent || physicalCount != null) {
      map['physical_count'] = Variable<int>(physicalCount);
    }
    if (!nullToAbsent || calculatedCount != null) {
      map['calculated_count'] = Variable<int>(calculatedCount);
    }
    if (!nullToAbsent || commentsOnReconciliation != null) {
      map['comments_on_reconciliation'] =
          Variable<String>(commentsOnReconciliation);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    map['date_of_reconciliation'] = Variable<int>(dateOfReconciliation);
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  StockReconciliationCompanion toCompanion(bool nullToAbsent) {
    return StockReconciliationCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      facilityId: facilityId == null && nullToAbsent
          ? const Value.absent()
          : Value(facilityId),
      productVariantId: productVariantId == null && nullToAbsent
          ? const Value.absent()
          : Value(productVariantId),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      referenceIdType: referenceIdType == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceIdType),
      physicalCount: physicalCount == null && nullToAbsent
          ? const Value.absent()
          : Value(physicalCount),
      calculatedCount: calculatedCount == null && nullToAbsent
          ? const Value.absent()
          : Value(calculatedCount),
      commentsOnReconciliation: commentsOnReconciliation == null && nullToAbsent
          ? const Value.absent()
          : Value(commentsOnReconciliation),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      dateOfReconciliation: Value(dateOfReconciliation),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory StockReconciliationData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockReconciliationData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      facilityId: serializer.fromJson<String?>(json['facilityId']),
      productVariantId: serializer.fromJson<String?>(json['productVariantId']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      referenceIdType: serializer.fromJson<String?>(json['referenceIdType']),
      physicalCount: serializer.fromJson<int?>(json['physicalCount']),
      calculatedCount: serializer.fromJson<int?>(json['calculatedCount']),
      commentsOnReconciliation:
          serializer.fromJson<String?>(json['commentsOnReconciliation']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      dateOfReconciliation:
          serializer.fromJson<int>(json['dateOfReconciliation']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String?>(tenantId),
      'facilityId': serializer.toJson<String?>(facilityId),
      'productVariantId': serializer.toJson<String?>(productVariantId),
      'referenceId': serializer.toJson<String?>(referenceId),
      'referenceIdType': serializer.toJson<String?>(referenceIdType),
      'physicalCount': serializer.toJson<int?>(physicalCount),
      'calculatedCount': serializer.toJson<int?>(calculatedCount),
      'commentsOnReconciliation':
          serializer.toJson<String?>(commentsOnReconciliation),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'dateOfReconciliation': serializer.toJson<int>(dateOfReconciliation),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  StockReconciliationData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> facilityId = const Value.absent(),
          Value<String?> productVariantId = const Value.absent(),
          Value<String?> referenceId = const Value.absent(),
          Value<String?> referenceIdType = const Value.absent(),
          Value<int?> physicalCount = const Value.absent(),
          Value<int?> calculatedCount = const Value.absent(),
          Value<String?> commentsOnReconciliation = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          int? dateOfReconciliation,
          Value<String?> additionalFields = const Value.absent()}) =>
      StockReconciliationData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        facilityId: facilityId.present ? facilityId.value : this.facilityId,
        productVariantId: productVariantId.present
            ? productVariantId.value
            : this.productVariantId,
        referenceId: referenceId.present ? referenceId.value : this.referenceId,
        referenceIdType: referenceIdType.present
            ? referenceIdType.value
            : this.referenceIdType,
        physicalCount:
            physicalCount.present ? physicalCount.value : this.physicalCount,
        calculatedCount: calculatedCount.present
            ? calculatedCount.value
            : this.calculatedCount,
        commentsOnReconciliation: commentsOnReconciliation.present
            ? commentsOnReconciliation.value
            : this.commentsOnReconciliation,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        dateOfReconciliation: dateOfReconciliation ?? this.dateOfReconciliation,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('StockReconciliationData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('facilityId: $facilityId, ')
          ..write('productVariantId: $productVariantId, ')
          ..write('referenceId: $referenceId, ')
          ..write('referenceIdType: $referenceIdType, ')
          ..write('physicalCount: $physicalCount, ')
          ..write('calculatedCount: $calculatedCount, ')
          ..write('commentsOnReconciliation: $commentsOnReconciliation, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('dateOfReconciliation: $dateOfReconciliation, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        tenantId,
        facilityId,
        productVariantId,
        referenceId,
        referenceIdType,
        physicalCount,
        calculatedCount,
        commentsOnReconciliation,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        dateOfReconciliation,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockReconciliationData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.facilityId == this.facilityId &&
          other.productVariantId == this.productVariantId &&
          other.referenceId == this.referenceId &&
          other.referenceIdType == this.referenceIdType &&
          other.physicalCount == this.physicalCount &&
          other.calculatedCount == this.calculatedCount &&
          other.commentsOnReconciliation == this.commentsOnReconciliation &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.dateOfReconciliation == this.dateOfReconciliation &&
          other.additionalFields == this.additionalFields);
}

class StockReconciliationCompanion
    extends UpdateCompanion<StockReconciliationData> {
  final Value<String?> id;
  final Value<String?> tenantId;
  final Value<String?> facilityId;
  final Value<String?> productVariantId;
  final Value<String?> referenceId;
  final Value<String?> referenceIdType;
  final Value<int?> physicalCount;
  final Value<int?> calculatedCount;
  final Value<String?> commentsOnReconciliation;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int> dateOfReconciliation;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const StockReconciliationCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.facilityId = const Value.absent(),
    this.productVariantId = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.referenceIdType = const Value.absent(),
    this.physicalCount = const Value.absent(),
    this.calculatedCount = const Value.absent(),
    this.commentsOnReconciliation = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.dateOfReconciliation = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  StockReconciliationCompanion.insert({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.facilityId = const Value.absent(),
    this.productVariantId = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.referenceIdType = const Value.absent(),
    this.physicalCount = const Value.absent(),
    this.calculatedCount = const Value.absent(),
    this.commentsOnReconciliation = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    required int dateOfReconciliation,
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : clientReferenceId = Value(clientReferenceId),
        dateOfReconciliation = Value(dateOfReconciliation);
  static Insertable<StockReconciliationData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? facilityId,
    Expression<String>? productVariantId,
    Expression<String>? referenceId,
    Expression<String>? referenceIdType,
    Expression<int>? physicalCount,
    Expression<int>? calculatedCount,
    Expression<String>? commentsOnReconciliation,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? dateOfReconciliation,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (facilityId != null) 'facility_id': facilityId,
      if (productVariantId != null) 'product_variant_id': productVariantId,
      if (referenceId != null) 'reference_id': referenceId,
      if (referenceIdType != null) 'reference_id_type': referenceIdType,
      if (physicalCount != null) 'physical_count': physicalCount,
      if (calculatedCount != null) 'calculated_count': calculatedCount,
      if (commentsOnReconciliation != null)
        'comments_on_reconciliation': commentsOnReconciliation,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (dateOfReconciliation != null)
        'date_of_reconciliation': dateOfReconciliation,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StockReconciliationCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? tenantId,
      Value<String?>? facilityId,
      Value<String?>? productVariantId,
      Value<String?>? referenceId,
      Value<String?>? referenceIdType,
      Value<int?>? physicalCount,
      Value<int?>? calculatedCount,
      Value<String?>? commentsOnReconciliation,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int>? dateOfReconciliation,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return StockReconciliationCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      facilityId: facilityId ?? this.facilityId,
      productVariantId: productVariantId ?? this.productVariantId,
      referenceId: referenceId ?? this.referenceId,
      referenceIdType: referenceIdType ?? this.referenceIdType,
      physicalCount: physicalCount ?? this.physicalCount,
      calculatedCount: calculatedCount ?? this.calculatedCount,
      commentsOnReconciliation:
          commentsOnReconciliation ?? this.commentsOnReconciliation,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      dateOfReconciliation: dateOfReconciliation ?? this.dateOfReconciliation,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (facilityId.present) {
      map['facility_id'] = Variable<String>(facilityId.value);
    }
    if (productVariantId.present) {
      map['product_variant_id'] = Variable<String>(productVariantId.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (referenceIdType.present) {
      map['reference_id_type'] = Variable<String>(referenceIdType.value);
    }
    if (physicalCount.present) {
      map['physical_count'] = Variable<int>(physicalCount.value);
    }
    if (calculatedCount.present) {
      map['calculated_count'] = Variable<int>(calculatedCount.value);
    }
    if (commentsOnReconciliation.present) {
      map['comments_on_reconciliation'] =
          Variable<String>(commentsOnReconciliation.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (dateOfReconciliation.present) {
      map['date_of_reconciliation'] = Variable<int>(dateOfReconciliation.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockReconciliationCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('facilityId: $facilityId, ')
          ..write('productVariantId: $productVariantId, ')
          ..write('referenceId: $referenceId, ')
          ..write('referenceIdType: $referenceIdType, ')
          ..write('physicalCount: $physicalCount, ')
          ..write('calculatedCount: $calculatedCount, ')
          ..write('commentsOnReconciliation: $commentsOnReconciliation, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('dateOfReconciliation: $dateOfReconciliation, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TargetTable extends Target with TableInfo<$TargetTable, TargetData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TargetTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _totalNoMeta =
      const VerificationMeta('totalNo');
  @override
  late final GeneratedColumn<double> totalNo = GeneratedColumn<double>(
      'total_no', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _targetNoMeta =
      const VerificationMeta('targetNo');
  @override
  late final GeneratedColumn<double> targetNo = GeneratedColumn<double>(
      'target_no', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _beneficiaryTypeMeta =
      const VerificationMeta('beneficiaryType');
  @override
  late final GeneratedColumn<String> beneficiaryType = GeneratedColumn<String>(
      'beneficiary_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        clientReferenceId,
        totalNo,
        targetNo,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        beneficiaryType,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'target';
  @override
  VerificationContext validateIntegrity(Insertable<TargetData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    }
    if (data.containsKey('total_no')) {
      context.handle(_totalNoMeta,
          totalNo.isAcceptableOrUnknown(data['total_no']!, _totalNoMeta));
    }
    if (data.containsKey('target_no')) {
      context.handle(_targetNoMeta,
          targetNo.isAcceptableOrUnknown(data['target_no']!, _targetNoMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('beneficiary_type')) {
      context.handle(
          _beneficiaryTypeMeta,
          beneficiaryType.isAcceptableOrUnknown(
              data['beneficiary_type']!, _beneficiaryTypeMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  TargetData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TargetData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id']),
      totalNo: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_no']),
      targetNo: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}target_no']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      beneficiaryType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}beneficiary_type']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $TargetTable createAlias(String alias) {
    return $TargetTable(attachedDatabase, alias);
  }
}

class TargetData extends DataClass implements Insertable<TargetData> {
  final String id;
  final String? clientReferenceId;
  final double? totalNo;
  final double? targetNo;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? beneficiaryType;
  final String? additionalFields;
  const TargetData(
      {required this.id,
      this.clientReferenceId,
      this.totalNo,
      this.targetNo,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.beneficiaryType,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || clientReferenceId != null) {
      map['client_reference_id'] = Variable<String>(clientReferenceId);
    }
    if (!nullToAbsent || totalNo != null) {
      map['total_no'] = Variable<double>(totalNo);
    }
    if (!nullToAbsent || targetNo != null) {
      map['target_no'] = Variable<double>(targetNo);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || beneficiaryType != null) {
      map['beneficiary_type'] = Variable<String>(beneficiaryType);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  TargetCompanion toCompanion(bool nullToAbsent) {
    return TargetCompanion(
      id: Value(id),
      clientReferenceId: clientReferenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(clientReferenceId),
      totalNo: totalNo == null && nullToAbsent
          ? const Value.absent()
          : Value(totalNo),
      targetNo: targetNo == null && nullToAbsent
          ? const Value.absent()
          : Value(targetNo),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      beneficiaryType: beneficiaryType == null && nullToAbsent
          ? const Value.absent()
          : Value(beneficiaryType),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory TargetData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TargetData(
      id: serializer.fromJson<String>(json['id']),
      clientReferenceId:
          serializer.fromJson<String?>(json['clientReferenceId']),
      totalNo: serializer.fromJson<double?>(json['totalNo']),
      targetNo: serializer.fromJson<double?>(json['targetNo']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      beneficiaryType: serializer.fromJson<String?>(json['beneficiaryType']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientReferenceId': serializer.toJson<String?>(clientReferenceId),
      'totalNo': serializer.toJson<double?>(totalNo),
      'targetNo': serializer.toJson<double?>(targetNo),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'beneficiaryType': serializer.toJson<String?>(beneficiaryType),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  TargetData copyWith(
          {String? id,
          Value<String?> clientReferenceId = const Value.absent(),
          Value<double?> totalNo = const Value.absent(),
          Value<double?> targetNo = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> beneficiaryType = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      TargetData(
        id: id ?? this.id,
        clientReferenceId: clientReferenceId.present
            ? clientReferenceId.value
            : this.clientReferenceId,
        totalNo: totalNo.present ? totalNo.value : this.totalNo,
        targetNo: targetNo.present ? targetNo.value : this.targetNo,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        beneficiaryType: beneficiaryType.present
            ? beneficiaryType.value
            : this.beneficiaryType,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('TargetData(')
          ..write('id: $id, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('totalNo: $totalNo, ')
          ..write('targetNo: $targetNo, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('beneficiaryType: $beneficiaryType, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      clientReferenceId,
      totalNo,
      targetNo,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      beneficiaryType,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TargetData &&
          other.id == this.id &&
          other.clientReferenceId == this.clientReferenceId &&
          other.totalNo == this.totalNo &&
          other.targetNo == this.targetNo &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.beneficiaryType == this.beneficiaryType &&
          other.additionalFields == this.additionalFields);
}

class TargetCompanion extends UpdateCompanion<TargetData> {
  final Value<String> id;
  final Value<String?> clientReferenceId;
  final Value<double?> totalNo;
  final Value<double?> targetNo;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> beneficiaryType;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const TargetCompanion({
    this.id = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.totalNo = const Value.absent(),
    this.targetNo = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.beneficiaryType = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TargetCompanion.insert({
    required String id,
    this.clientReferenceId = const Value.absent(),
    this.totalNo = const Value.absent(),
    this.targetNo = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.beneficiaryType = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<TargetData> custom({
    Expression<String>? id,
    Expression<String>? clientReferenceId,
    Expression<double>? totalNo,
    Expression<double>? targetNo,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? beneficiaryType,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (totalNo != null) 'total_no': totalNo,
      if (targetNo != null) 'target_no': targetNo,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (beneficiaryType != null) 'beneficiary_type': beneficiaryType,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TargetCompanion copyWith(
      {Value<String>? id,
      Value<String?>? clientReferenceId,
      Value<double?>? totalNo,
      Value<double?>? targetNo,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? beneficiaryType,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return TargetCompanion(
      id: id ?? this.id,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      totalNo: totalNo ?? this.totalNo,
      targetNo: targetNo ?? this.targetNo,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      beneficiaryType: beneficiaryType ?? this.beneficiaryType,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (totalNo.present) {
      map['total_no'] = Variable<double>(totalNo.value);
    }
    if (targetNo.present) {
      map['target_no'] = Variable<double>(targetNo.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (beneficiaryType.present) {
      map['beneficiary_type'] = Variable<String>(beneficiaryType.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TargetCompanion(')
          ..write('id: $id, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('totalNo: $totalNo, ')
          ..write('targetNo: $targetNo, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('beneficiaryType: $beneficiaryType, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ServiceTable extends Service with TableInfo<$ServiceTable, ServiceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ServiceTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientIdMeta =
      const VerificationMeta('clientId');
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
      'client_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _serviceDefIdMeta =
      const VerificationMeta('serviceDefId');
  @override
  late final GeneratedColumn<String> serviceDefId = GeneratedColumn<String>(
      'service_def_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'));
  static const VerificationMeta _accountIdMeta =
      const VerificationMeta('accountId');
  @override
  late final GeneratedColumn<String> accountId = GeneratedColumn<String>(
      'account_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _additionalDetailsMeta =
      const VerificationMeta('additionalDetails');
  @override
  late final GeneratedColumn<String> additionalDetails =
      GeneratedColumn<String>('additional_details', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<String> createdAt = GeneratedColumn<String>(
      'created_at', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        clientId,
        serviceDefId,
        referenceId,
        isActive,
        accountId,
        additionalDetails,
        createdAt,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'service';
  @override
  VerificationContext validateIntegrity(Insertable<ServiceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('client_id')) {
      context.handle(_clientIdMeta,
          clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta));
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('service_def_id')) {
      context.handle(
          _serviceDefIdMeta,
          serviceDefId.isAcceptableOrUnknown(
              data['service_def_id']!, _serviceDefIdMeta));
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('account_id')) {
      context.handle(_accountIdMeta,
          accountId.isAcceptableOrUnknown(data['account_id']!, _accountIdMeta));
    }
    if (data.containsKey('additional_details')) {
      context.handle(
          _additionalDetailsMeta,
          additionalDetails.isAcceptableOrUnknown(
              data['additional_details']!, _additionalDetailsMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {clientId, auditCreatedBy};
  @override
  ServiceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ServiceData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      clientId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}client_id'])!,
      serviceDefId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}service_def_id']),
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id']),
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active']),
      accountId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}account_id']),
      additionalDetails: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_details']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_at']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ServiceTable createAlias(String alias) {
    return $ServiceTable(attachedDatabase, alias);
  }
}

class ServiceData extends DataClass implements Insertable<ServiceData> {
  final String? id;
  final String clientId;
  final String? serviceDefId;
  final String? referenceId;
  final bool? isActive;
  final String? accountId;
  final String? additionalDetails;
  final String? createdAt;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ServiceData(
      {this.id,
      required this.clientId,
      this.serviceDefId,
      this.referenceId,
      this.isActive,
      this.accountId,
      this.additionalDetails,
      this.createdAt,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    map['client_id'] = Variable<String>(clientId);
    if (!nullToAbsent || serviceDefId != null) {
      map['service_def_id'] = Variable<String>(serviceDefId);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    if (!nullToAbsent || isActive != null) {
      map['is_active'] = Variable<bool>(isActive);
    }
    if (!nullToAbsent || accountId != null) {
      map['account_id'] = Variable<String>(accountId);
    }
    if (!nullToAbsent || additionalDetails != null) {
      map['additional_details'] = Variable<String>(additionalDetails);
    }
    if (!nullToAbsent || createdAt != null) {
      map['created_at'] = Variable<String>(createdAt);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ServiceCompanion toCompanion(bool nullToAbsent) {
    return ServiceCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      clientId: Value(clientId),
      serviceDefId: serviceDefId == null && nullToAbsent
          ? const Value.absent()
          : Value(serviceDefId),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      isActive: isActive == null && nullToAbsent
          ? const Value.absent()
          : Value(isActive),
      accountId: accountId == null && nullToAbsent
          ? const Value.absent()
          : Value(accountId),
      additionalDetails: additionalDetails == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalDetails),
      createdAt: createdAt == null && nullToAbsent
          ? const Value.absent()
          : Value(createdAt),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ServiceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ServiceData(
      id: serializer.fromJson<String?>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      serviceDefId: serializer.fromJson<String?>(json['serviceDefId']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      isActive: serializer.fromJson<bool?>(json['isActive']),
      accountId: serializer.fromJson<String?>(json['accountId']),
      additionalDetails:
          serializer.fromJson<String?>(json['additionalDetails']),
      createdAt: serializer.fromJson<String?>(json['createdAt']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'clientId': serializer.toJson<String>(clientId),
      'serviceDefId': serializer.toJson<String?>(serviceDefId),
      'referenceId': serializer.toJson<String?>(referenceId),
      'isActive': serializer.toJson<bool?>(isActive),
      'accountId': serializer.toJson<String?>(accountId),
      'additionalDetails': serializer.toJson<String?>(additionalDetails),
      'createdAt': serializer.toJson<String?>(createdAt),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ServiceData copyWith(
          {Value<String?> id = const Value.absent(),
          String? clientId,
          Value<String?> serviceDefId = const Value.absent(),
          Value<String?> referenceId = const Value.absent(),
          Value<bool?> isActive = const Value.absent(),
          Value<String?> accountId = const Value.absent(),
          Value<String?> additionalDetails = const Value.absent(),
          Value<String?> createdAt = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ServiceData(
        id: id.present ? id.value : this.id,
        clientId: clientId ?? this.clientId,
        serviceDefId:
            serviceDefId.present ? serviceDefId.value : this.serviceDefId,
        referenceId: referenceId.present ? referenceId.value : this.referenceId,
        isActive: isActive.present ? isActive.value : this.isActive,
        accountId: accountId.present ? accountId.value : this.accountId,
        additionalDetails: additionalDetails.present
            ? additionalDetails.value
            : this.additionalDetails,
        createdAt: createdAt.present ? createdAt.value : this.createdAt,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ServiceData(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('serviceDefId: $serviceDefId, ')
          ..write('referenceId: $referenceId, ')
          ..write('isActive: $isActive, ')
          ..write('accountId: $accountId, ')
          ..write('additionalDetails: $additionalDetails, ')
          ..write('createdAt: $createdAt, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        clientId,
        serviceDefId,
        referenceId,
        isActive,
        accountId,
        additionalDetails,
        createdAt,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ServiceData &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.serviceDefId == this.serviceDefId &&
          other.referenceId == this.referenceId &&
          other.isActive == this.isActive &&
          other.accountId == this.accountId &&
          other.additionalDetails == this.additionalDetails &&
          other.createdAt == this.createdAt &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ServiceCompanion extends UpdateCompanion<ServiceData> {
  final Value<String?> id;
  final Value<String> clientId;
  final Value<String?> serviceDefId;
  final Value<String?> referenceId;
  final Value<bool?> isActive;
  final Value<String?> accountId;
  final Value<String?> additionalDetails;
  final Value<String?> createdAt;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ServiceCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.serviceDefId = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.isActive = const Value.absent(),
    this.accountId = const Value.absent(),
    this.additionalDetails = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ServiceCompanion.insert({
    this.id = const Value.absent(),
    required String clientId,
    this.serviceDefId = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.isActive = const Value.absent(),
    this.accountId = const Value.absent(),
    this.additionalDetails = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientId = Value(clientId);
  static Insertable<ServiceData> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? serviceDefId,
    Expression<String>? referenceId,
    Expression<bool>? isActive,
    Expression<String>? accountId,
    Expression<String>? additionalDetails,
    Expression<String>? createdAt,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (serviceDefId != null) 'service_def_id': serviceDefId,
      if (referenceId != null) 'reference_id': referenceId,
      if (isActive != null) 'is_active': isActive,
      if (accountId != null) 'account_id': accountId,
      if (additionalDetails != null) 'additional_details': additionalDetails,
      if (createdAt != null) 'created_at': createdAt,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ServiceCompanion copyWith(
      {Value<String?>? id,
      Value<String>? clientId,
      Value<String?>? serviceDefId,
      Value<String?>? referenceId,
      Value<bool?>? isActive,
      Value<String?>? accountId,
      Value<String?>? additionalDetails,
      Value<String?>? createdAt,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ServiceCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      serviceDefId: serviceDefId ?? this.serviceDefId,
      referenceId: referenceId ?? this.referenceId,
      isActive: isActive ?? this.isActive,
      accountId: accountId ?? this.accountId,
      additionalDetails: additionalDetails ?? this.additionalDetails,
      createdAt: createdAt ?? this.createdAt,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (serviceDefId.present) {
      map['service_def_id'] = Variable<String>(serviceDefId.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (accountId.present) {
      map['account_id'] = Variable<String>(accountId.value);
    }
    if (additionalDetails.present) {
      map['additional_details'] = Variable<String>(additionalDetails.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<String>(createdAt.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ServiceCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('serviceDefId: $serviceDefId, ')
          ..write('referenceId: $referenceId, ')
          ..write('isActive: $isActive, ')
          ..write('accountId: $accountId, ')
          ..write('additionalDetails: $additionalDetails, ')
          ..write('createdAt: $createdAt, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ServiceAttributesTable extends ServiceAttributes
    with TableInfo<$ServiceAttributesTable, ServiceAttribute> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ServiceAttributesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _attributeCodeMeta =
      const VerificationMeta('attributeCode');
  @override
  late final GeneratedColumn<String> attributeCode = GeneratedColumn<String>(
      'attribute_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
      'value', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _dataTypeMeta =
      const VerificationMeta('dataType');
  @override
  late final GeneratedColumn<String> dataType = GeneratedColumn<String>(
      'data_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _additionalDetailsMeta =
      const VerificationMeta('additionalDetails');
  @override
  late final GeneratedColumn<String> additionalDetails =
      GeneratedColumn<String>('additional_details', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _serviceClientReferenceIdMeta =
      const VerificationMeta('serviceClientReferenceId');
  @override
  late final GeneratedColumn<String> serviceClientReferenceId =
      GeneratedColumn<String>('service_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        attributeCode,
        value,
        dataType,
        referenceId,
        additionalDetails,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        serviceClientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'service_attributes';
  @override
  VerificationContext validateIntegrity(Insertable<ServiceAttribute> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('attribute_code')) {
      context.handle(
          _attributeCodeMeta,
          attributeCode.isAcceptableOrUnknown(
              data['attribute_code']!, _attributeCodeMeta));
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value']!, _valueMeta));
    }
    if (data.containsKey('data_type')) {
      context.handle(_dataTypeMeta,
          dataType.isAcceptableOrUnknown(data['data_type']!, _dataTypeMeta));
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    }
    if (data.containsKey('additional_details')) {
      context.handle(
          _additionalDetailsMeta,
          additionalDetails.isAcceptableOrUnknown(
              data['additional_details']!, _additionalDetailsMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    }
    if (data.containsKey('service_client_reference_id')) {
      context.handle(
          _serviceClientReferenceIdMeta,
          serviceClientReferenceId.isAcceptableOrUnknown(
              data['service_client_reference_id']!,
              _serviceClientReferenceIdMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => const {};
  @override
  ServiceAttribute map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ServiceAttribute(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      attributeCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}attribute_code']),
      value: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}value']),
      dataType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_type']),
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id']),
      additionalDetails: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_details']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id']),
      serviceClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}service_client_reference_id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ServiceAttributesTable createAlias(String alias) {
    return $ServiceAttributesTable(attachedDatabase, alias);
  }
}

class ServiceAttribute extends DataClass
    implements Insertable<ServiceAttribute> {
  final String? id;
  final String? attributeCode;
  final String? value;
  final String? dataType;
  final String? referenceId;
  final String? additionalDetails;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? clientReferenceId;
  final String? serviceClientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ServiceAttribute(
      {this.id,
      this.attributeCode,
      this.value,
      this.dataType,
      this.referenceId,
      this.additionalDetails,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.clientReferenceId,
      this.serviceClientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || attributeCode != null) {
      map['attribute_code'] = Variable<String>(attributeCode);
    }
    if (!nullToAbsent || value != null) {
      map['value'] = Variable<String>(value);
    }
    if (!nullToAbsent || dataType != null) {
      map['data_type'] = Variable<String>(dataType);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    if (!nullToAbsent || additionalDetails != null) {
      map['additional_details'] = Variable<String>(additionalDetails);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || clientReferenceId != null) {
      map['client_reference_id'] = Variable<String>(clientReferenceId);
    }
    if (!nullToAbsent || serviceClientReferenceId != null) {
      map['service_client_reference_id'] =
          Variable<String>(serviceClientReferenceId);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ServiceAttributesCompanion toCompanion(bool nullToAbsent) {
    return ServiceAttributesCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      attributeCode: attributeCode == null && nullToAbsent
          ? const Value.absent()
          : Value(attributeCode),
      value:
          value == null && nullToAbsent ? const Value.absent() : Value(value),
      dataType: dataType == null && nullToAbsent
          ? const Value.absent()
          : Value(dataType),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      additionalDetails: additionalDetails == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalDetails),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: clientReferenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(clientReferenceId),
      serviceClientReferenceId: serviceClientReferenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(serviceClientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ServiceAttribute.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ServiceAttribute(
      id: serializer.fromJson<String?>(json['id']),
      attributeCode: serializer.fromJson<String?>(json['attributeCode']),
      value: serializer.fromJson<String?>(json['value']),
      dataType: serializer.fromJson<String?>(json['dataType']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      additionalDetails:
          serializer.fromJson<String?>(json['additionalDetails']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId:
          serializer.fromJson<String?>(json['clientReferenceId']),
      serviceClientReferenceId:
          serializer.fromJson<String?>(json['serviceClientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'attributeCode': serializer.toJson<String?>(attributeCode),
      'value': serializer.toJson<String?>(value),
      'dataType': serializer.toJson<String?>(dataType),
      'referenceId': serializer.toJson<String?>(referenceId),
      'additionalDetails': serializer.toJson<String?>(additionalDetails),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String?>(clientReferenceId),
      'serviceClientReferenceId':
          serializer.toJson<String?>(serviceClientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ServiceAttribute copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> attributeCode = const Value.absent(),
          Value<String?> value = const Value.absent(),
          Value<String?> dataType = const Value.absent(),
          Value<String?> referenceId = const Value.absent(),
          Value<String?> additionalDetails = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> clientReferenceId = const Value.absent(),
          Value<String?> serviceClientReferenceId = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ServiceAttribute(
        id: id.present ? id.value : this.id,
        attributeCode:
            attributeCode.present ? attributeCode.value : this.attributeCode,
        value: value.present ? value.value : this.value,
        dataType: dataType.present ? dataType.value : this.dataType,
        referenceId: referenceId.present ? referenceId.value : this.referenceId,
        additionalDetails: additionalDetails.present
            ? additionalDetails.value
            : this.additionalDetails,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId.present
            ? clientReferenceId.value
            : this.clientReferenceId,
        serviceClientReferenceId: serviceClientReferenceId.present
            ? serviceClientReferenceId.value
            : this.serviceClientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ServiceAttribute(')
          ..write('id: $id, ')
          ..write('attributeCode: $attributeCode, ')
          ..write('value: $value, ')
          ..write('dataType: $dataType, ')
          ..write('referenceId: $referenceId, ')
          ..write('additionalDetails: $additionalDetails, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('serviceClientReferenceId: $serviceClientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        attributeCode,
        value,
        dataType,
        referenceId,
        additionalDetails,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        serviceClientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ServiceAttribute &&
          other.id == this.id &&
          other.attributeCode == this.attributeCode &&
          other.value == this.value &&
          other.dataType == this.dataType &&
          other.referenceId == this.referenceId &&
          other.additionalDetails == this.additionalDetails &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.serviceClientReferenceId == this.serviceClientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ServiceAttributesCompanion extends UpdateCompanion<ServiceAttribute> {
  final Value<String?> id;
  final Value<String?> attributeCode;
  final Value<String?> value;
  final Value<String?> dataType;
  final Value<String?> referenceId;
  final Value<String?> additionalDetails;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> clientReferenceId;
  final Value<String?> serviceClientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ServiceAttributesCompanion({
    this.id = const Value.absent(),
    this.attributeCode = const Value.absent(),
    this.value = const Value.absent(),
    this.dataType = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.additionalDetails = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.serviceClientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ServiceAttributesCompanion.insert({
    this.id = const Value.absent(),
    this.attributeCode = const Value.absent(),
    this.value = const Value.absent(),
    this.dataType = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.additionalDetails = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.serviceClientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<ServiceAttribute> custom({
    Expression<String>? id,
    Expression<String>? attributeCode,
    Expression<String>? value,
    Expression<String>? dataType,
    Expression<String>? referenceId,
    Expression<String>? additionalDetails,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? serviceClientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (attributeCode != null) 'attribute_code': attributeCode,
      if (value != null) 'value': value,
      if (dataType != null) 'data_type': dataType,
      if (referenceId != null) 'reference_id': referenceId,
      if (additionalDetails != null) 'additional_details': additionalDetails,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (serviceClientReferenceId != null)
        'service_client_reference_id': serviceClientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ServiceAttributesCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? attributeCode,
      Value<String?>? value,
      Value<String?>? dataType,
      Value<String?>? referenceId,
      Value<String?>? additionalDetails,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? clientReferenceId,
      Value<String?>? serviceClientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ServiceAttributesCompanion(
      id: id ?? this.id,
      attributeCode: attributeCode ?? this.attributeCode,
      value: value ?? this.value,
      dataType: dataType ?? this.dataType,
      referenceId: referenceId ?? this.referenceId,
      additionalDetails: additionalDetails ?? this.additionalDetails,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      serviceClientReferenceId:
          serviceClientReferenceId ?? this.serviceClientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (attributeCode.present) {
      map['attribute_code'] = Variable<String>(attributeCode.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (dataType.present) {
      map['data_type'] = Variable<String>(dataType.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (additionalDetails.present) {
      map['additional_details'] = Variable<String>(additionalDetails.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (serviceClientReferenceId.present) {
      map['service_client_reference_id'] =
          Variable<String>(serviceClientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ServiceAttributesCompanion(')
          ..write('id: $id, ')
          ..write('attributeCode: $attributeCode, ')
          ..write('value: $value, ')
          ..write('dataType: $dataType, ')
          ..write('referenceId: $referenceId, ')
          ..write('additionalDetails: $additionalDetails, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('serviceClientReferenceId: $serviceClientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ServiceDefinitionTable extends ServiceDefinition
    with TableInfo<$ServiceDefinitionTable, ServiceDefinitionData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ServiceDefinitionTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'));
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        code,
        isActive,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'service_definition';
  @override
  VerificationContext validateIntegrity(
      Insertable<ServiceDefinitionData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  ServiceDefinitionData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ServiceDefinitionData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ServiceDefinitionTable createAlias(String alias) {
    return $ServiceDefinitionTable(attachedDatabase, alias);
  }
}

class ServiceDefinitionData extends DataClass
    implements Insertable<ServiceDefinitionData> {
  final String? id;
  final String? tenantId;
  final String? code;
  final bool? isActive;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ServiceDefinitionData(
      {this.id,
      this.tenantId,
      this.code,
      this.isActive,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || isActive != null) {
      map['is_active'] = Variable<bool>(isActive);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ServiceDefinitionCompanion toCompanion(bool nullToAbsent) {
    return ServiceDefinitionCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      isActive: isActive == null && nullToAbsent
          ? const Value.absent()
          : Value(isActive),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ServiceDefinitionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ServiceDefinitionData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      code: serializer.fromJson<String?>(json['code']),
      isActive: serializer.fromJson<bool?>(json['isActive']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String?>(tenantId),
      'code': serializer.toJson<String?>(code),
      'isActive': serializer.toJson<bool?>(isActive),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ServiceDefinitionData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> code = const Value.absent(),
          Value<bool?> isActive = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ServiceDefinitionData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        code: code.present ? code.value : this.code,
        isActive: isActive.present ? isActive.value : this.isActive,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ServiceDefinitionData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('code: $code, ')
          ..write('isActive: $isActive, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      tenantId,
      code,
      isActive,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ServiceDefinitionData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.code == this.code &&
          other.isActive == this.isActive &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ServiceDefinitionCompanion
    extends UpdateCompanion<ServiceDefinitionData> {
  final Value<String?> id;
  final Value<String?> tenantId;
  final Value<String?> code;
  final Value<bool?> isActive;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ServiceDefinitionCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.code = const Value.absent(),
    this.isActive = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ServiceDefinitionCompanion.insert({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.code = const Value.absent(),
    this.isActive = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<ServiceDefinitionData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? code,
    Expression<bool>? isActive,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (code != null) 'code': code,
      if (isActive != null) 'is_active': isActive,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ServiceDefinitionCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? tenantId,
      Value<String?>? code,
      Value<bool?>? isActive,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ServiceDefinitionCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      code: code ?? this.code,
      isActive: isActive ?? this.isActive,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ServiceDefinitionCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('code: $code, ')
          ..write('isActive: $isActive, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LocalityTable extends Locality
    with TableInfo<$LocalityTable, LocalityData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LocalityTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        code,
        name,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'locality';
  @override
  VerificationContext validateIntegrity(Insertable<LocalityData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code, auditCreatedBy};
  @override
  LocalityData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LocalityData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $LocalityTable createAlias(String alias) {
    return $LocalityTable(attachedDatabase, alias);
  }
}

class LocalityData extends DataClass implements Insertable<LocalityData> {
  final String code;
  final String? name;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const LocalityData(
      {required this.code,
      this.name,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['code'] = Variable<String>(code);
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  LocalityCompanion toCompanion(bool nullToAbsent) {
    return LocalityCompanion(
      code: Value(code),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory LocalityData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LocalityData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String?>(json['name']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String?>(name),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  LocalityData copyWith(
          {String? code,
          Value<String?> name = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      LocalityData(
        code: code ?? this.code,
        name: name.present ? name.value : this.name,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('LocalityData(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      code,
      name,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LocalityData &&
          other.code == this.code &&
          other.name == this.name &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class LocalityCompanion extends UpdateCompanion<LocalityData> {
  final Value<String> code;
  final Value<String?> name;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const LocalityCompanion({
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  LocalityCompanion.insert({
    required String code,
    this.name = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : code = Value(code);
  static Insertable<LocalityData> custom({
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LocalityCompanion copyWith(
      {Value<String>? code,
      Value<String?>? name,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return LocalityCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LocalityCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StaffTable extends Staff with TableInfo<$StaffTable, StaffData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StaffTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _registerIdMeta =
      const VerificationMeta('registerId');
  @override
  late final GeneratedColumn<String> registerId = GeneratedColumn<String>(
      'register_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
      'user_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _enrollmentDateMeta =
      const VerificationMeta('enrollmentDate');
  @override
  late final GeneratedColumn<int> enrollmentDate = GeneratedColumn<int>(
      'enrollment_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _denrollmentDateMeta =
      const VerificationMeta('denrollmentDate');
  @override
  late final GeneratedColumn<int> denrollmentDate = GeneratedColumn<int>(
      'denrollment_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [id, tenantId, registerId, userId, enrollmentDate, denrollmentDate];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'staff';
  @override
  VerificationContext validateIntegrity(Insertable<StaffData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('register_id')) {
      context.handle(
          _registerIdMeta,
          registerId.isAcceptableOrUnknown(
              data['register_id']!, _registerIdMeta));
    } else if (isInserting) {
      context.missing(_registerIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('enrollment_date')) {
      context.handle(
          _enrollmentDateMeta,
          enrollmentDate.isAcceptableOrUnknown(
              data['enrollment_date']!, _enrollmentDateMeta));
    }
    if (data.containsKey('denrollment_date')) {
      context.handle(
          _denrollmentDateMeta,
          denrollmentDate.isAcceptableOrUnknown(
              data['denrollment_date']!, _denrollmentDateMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, registerId};
  @override
  StaffData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StaffData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      registerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}register_id'])!,
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_id'])!,
      enrollmentDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}enrollment_date']),
      denrollmentDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}denrollment_date']),
    );
  }

  @override
  $StaffTable createAlias(String alias) {
    return $StaffTable(attachedDatabase, alias);
  }
}

class StaffData extends DataClass implements Insertable<StaffData> {
  final String? id;
  final String tenantId;
  final String registerId;
  final String userId;
  final int? enrollmentDate;
  final int? denrollmentDate;
  const StaffData(
      {this.id,
      required this.tenantId,
      required this.registerId,
      required this.userId,
      this.enrollmentDate,
      this.denrollmentDate});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    map['tenant_id'] = Variable<String>(tenantId);
    map['register_id'] = Variable<String>(registerId);
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || enrollmentDate != null) {
      map['enrollment_date'] = Variable<int>(enrollmentDate);
    }
    if (!nullToAbsent || denrollmentDate != null) {
      map['denrollment_date'] = Variable<int>(denrollmentDate);
    }
    return map;
  }

  StaffCompanion toCompanion(bool nullToAbsent) {
    return StaffCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: Value(tenantId),
      registerId: Value(registerId),
      userId: Value(userId),
      enrollmentDate: enrollmentDate == null && nullToAbsent
          ? const Value.absent()
          : Value(enrollmentDate),
      denrollmentDate: denrollmentDate == null && nullToAbsent
          ? const Value.absent()
          : Value(denrollmentDate),
    );
  }

  factory StaffData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StaffData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String>(json['tenantId']),
      registerId: serializer.fromJson<String>(json['registerId']),
      userId: serializer.fromJson<String>(json['userId']),
      enrollmentDate: serializer.fromJson<int?>(json['enrollmentDate']),
      denrollmentDate: serializer.fromJson<int?>(json['denrollmentDate']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String>(tenantId),
      'registerId': serializer.toJson<String>(registerId),
      'userId': serializer.toJson<String>(userId),
      'enrollmentDate': serializer.toJson<int?>(enrollmentDate),
      'denrollmentDate': serializer.toJson<int?>(denrollmentDate),
    };
  }

  StaffData copyWith(
          {Value<String?> id = const Value.absent(),
          String? tenantId,
          String? registerId,
          String? userId,
          Value<int?> enrollmentDate = const Value.absent(),
          Value<int?> denrollmentDate = const Value.absent()}) =>
      StaffData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId ?? this.tenantId,
        registerId: registerId ?? this.registerId,
        userId: userId ?? this.userId,
        enrollmentDate:
            enrollmentDate.present ? enrollmentDate.value : this.enrollmentDate,
        denrollmentDate: denrollmentDate.present
            ? denrollmentDate.value
            : this.denrollmentDate,
      );
  @override
  String toString() {
    return (StringBuffer('StaffData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerId: $registerId, ')
          ..write('userId: $userId, ')
          ..write('enrollmentDate: $enrollmentDate, ')
          ..write('denrollmentDate: $denrollmentDate')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, tenantId, registerId, userId, enrollmentDate, denrollmentDate);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StaffData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.registerId == this.registerId &&
          other.userId == this.userId &&
          other.enrollmentDate == this.enrollmentDate &&
          other.denrollmentDate == this.denrollmentDate);
}

class StaffCompanion extends UpdateCompanion<StaffData> {
  final Value<String?> id;
  final Value<String> tenantId;
  final Value<String> registerId;
  final Value<String> userId;
  final Value<int?> enrollmentDate;
  final Value<int?> denrollmentDate;
  final Value<int> rowid;
  const StaffCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.registerId = const Value.absent(),
    this.userId = const Value.absent(),
    this.enrollmentDate = const Value.absent(),
    this.denrollmentDate = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  StaffCompanion.insert({
    this.id = const Value.absent(),
    required String tenantId,
    required String registerId,
    required String userId,
    this.enrollmentDate = const Value.absent(),
    this.denrollmentDate = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : tenantId = Value(tenantId),
        registerId = Value(registerId),
        userId = Value(userId);
  static Insertable<StaffData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? registerId,
    Expression<String>? userId,
    Expression<int>? enrollmentDate,
    Expression<int>? denrollmentDate,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (registerId != null) 'register_id': registerId,
      if (userId != null) 'user_id': userId,
      if (enrollmentDate != null) 'enrollment_date': enrollmentDate,
      if (denrollmentDate != null) 'denrollment_date': denrollmentDate,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StaffCompanion copyWith(
      {Value<String?>? id,
      Value<String>? tenantId,
      Value<String>? registerId,
      Value<String>? userId,
      Value<int?>? enrollmentDate,
      Value<int?>? denrollmentDate,
      Value<int>? rowid}) {
    return StaffCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      registerId: registerId ?? this.registerId,
      userId: userId ?? this.userId,
      enrollmentDate: enrollmentDate ?? this.enrollmentDate,
      denrollmentDate: denrollmentDate ?? this.denrollmentDate,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (registerId.present) {
      map['register_id'] = Variable<String>(registerId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (enrollmentDate.present) {
      map['enrollment_date'] = Variable<int>(enrollmentDate.value);
    }
    if (denrollmentDate.present) {
      map['denrollment_date'] = Variable<int>(denrollmentDate.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StaffCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerId: $registerId, ')
          ..write('userId: $userId, ')
          ..write('enrollmentDate: $enrollmentDate, ')
          ..write('denrollmentDate: $denrollmentDate, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AttributesTable extends Attributes
    with TableInfo<$AttributesTable, Attribute> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AttributesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _dataTypeMeta =
      const VerificationMeta('dataType');
  @override
  late final GeneratedColumn<String> dataType = GeneratedColumn<String>(
      'data_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _valuesMeta = const VerificationMeta('values');
  @override
  late final GeneratedColumn<String> values = GeneratedColumn<String>(
      'values', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'));
  static const VerificationMeta _requiredMeta =
      const VerificationMeta('required');
  @override
  late final GeneratedColumn<bool> required = GeneratedColumn<bool>(
      'required', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("required" IN (0, 1))'));
  static const VerificationMeta _regexMeta = const VerificationMeta('regex');
  @override
  late final GeneratedColumn<String> regex = GeneratedColumn<String>(
      'regex', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _orderMeta = const VerificationMeta('order');
  @override
  late final GeneratedColumn<int> order = GeneratedColumn<int>(
      'order', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalDetailsMeta =
      const VerificationMeta('additionalDetails');
  @override
  late final GeneratedColumn<String> additionalDetails =
      GeneratedColumn<String>('additional_details', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        dataType,
        referenceId,
        tenantId,
        code,
        values,
        isActive,
        required,
        regex,
        order,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalDetails,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'attributes';
  @override
  VerificationContext validateIntegrity(Insertable<Attribute> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('data_type')) {
      context.handle(_dataTypeMeta,
          dataType.isAcceptableOrUnknown(data['data_type']!, _dataTypeMeta));
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('values')) {
      context.handle(_valuesMeta,
          values.isAcceptableOrUnknown(data['values']!, _valuesMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('required')) {
      context.handle(_requiredMeta,
          required.isAcceptableOrUnknown(data['required']!, _requiredMeta));
    }
    if (data.containsKey('regex')) {
      context.handle(
          _regexMeta, regex.isAcceptableOrUnknown(data['regex']!, _regexMeta));
    }
    if (data.containsKey('order')) {
      context.handle(
          _orderMeta, order.isAcceptableOrUnknown(data['order']!, _orderMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_details')) {
      context.handle(
          _additionalDetailsMeta,
          additionalDetails.isAcceptableOrUnknown(
              data['additional_details']!, _additionalDetailsMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  Attribute map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Attribute(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      dataType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_type']),
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      values: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}values']),
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active']),
      required: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}required']),
      regex: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}regex']),
      order: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}order']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalDetails: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_details']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $AttributesTable createAlias(String alias) {
    return $AttributesTable(attachedDatabase, alias);
  }
}

class Attribute extends DataClass implements Insertable<Attribute> {
  final String? id;
  final String? dataType;
  final String? referenceId;
  final String? tenantId;
  final String? code;
  final String? values;
  final bool? isActive;
  final bool? required;
  final String? regex;
  final int? order;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalDetails;
  final String? additionalFields;
  const Attribute(
      {this.id,
      this.dataType,
      this.referenceId,
      this.tenantId,
      this.code,
      this.values,
      this.isActive,
      this.required,
      this.regex,
      this.order,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.isDeleted,
      this.rowVersion,
      this.additionalDetails,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || dataType != null) {
      map['data_type'] = Variable<String>(dataType);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || values != null) {
      map['values'] = Variable<String>(values);
    }
    if (!nullToAbsent || isActive != null) {
      map['is_active'] = Variable<bool>(isActive);
    }
    if (!nullToAbsent || required != null) {
      map['required'] = Variable<bool>(required);
    }
    if (!nullToAbsent || regex != null) {
      map['regex'] = Variable<String>(regex);
    }
    if (!nullToAbsent || order != null) {
      map['order'] = Variable<int>(order);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalDetails != null) {
      map['additional_details'] = Variable<String>(additionalDetails);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  AttributesCompanion toCompanion(bool nullToAbsent) {
    return AttributesCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      dataType: dataType == null && nullToAbsent
          ? const Value.absent()
          : Value(dataType),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      values:
          values == null && nullToAbsent ? const Value.absent() : Value(values),
      isActive: isActive == null && nullToAbsent
          ? const Value.absent()
          : Value(isActive),
      required: required == null && nullToAbsent
          ? const Value.absent()
          : Value(required),
      regex:
          regex == null && nullToAbsent ? const Value.absent() : Value(regex),
      order:
          order == null && nullToAbsent ? const Value.absent() : Value(order),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalDetails: additionalDetails == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalDetails),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory Attribute.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Attribute(
      id: serializer.fromJson<String?>(json['id']),
      dataType: serializer.fromJson<String?>(json['dataType']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      code: serializer.fromJson<String?>(json['code']),
      values: serializer.fromJson<String?>(json['values']),
      isActive: serializer.fromJson<bool?>(json['isActive']),
      required: serializer.fromJson<bool?>(json['required']),
      regex: serializer.fromJson<String?>(json['regex']),
      order: serializer.fromJson<int?>(json['order']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalDetails:
          serializer.fromJson<String?>(json['additionalDetails']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'dataType': serializer.toJson<String?>(dataType),
      'referenceId': serializer.toJson<String?>(referenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'code': serializer.toJson<String?>(code),
      'values': serializer.toJson<String?>(values),
      'isActive': serializer.toJson<bool?>(isActive),
      'required': serializer.toJson<bool?>(required),
      'regex': serializer.toJson<String?>(regex),
      'order': serializer.toJson<int?>(order),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalDetails': serializer.toJson<String?>(additionalDetails),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  Attribute copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> dataType = const Value.absent(),
          Value<String?> referenceId = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> code = const Value.absent(),
          Value<String?> values = const Value.absent(),
          Value<bool?> isActive = const Value.absent(),
          Value<bool?> required = const Value.absent(),
          Value<String?> regex = const Value.absent(),
          Value<int?> order = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalDetails = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      Attribute(
        id: id.present ? id.value : this.id,
        dataType: dataType.present ? dataType.value : this.dataType,
        referenceId: referenceId.present ? referenceId.value : this.referenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        code: code.present ? code.value : this.code,
        values: values.present ? values.value : this.values,
        isActive: isActive.present ? isActive.value : this.isActive,
        required: required.present ? required.value : this.required,
        regex: regex.present ? regex.value : this.regex,
        order: order.present ? order.value : this.order,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalDetails: additionalDetails.present
            ? additionalDetails.value
            : this.additionalDetails,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('Attribute(')
          ..write('id: $id, ')
          ..write('dataType: $dataType, ')
          ..write('referenceId: $referenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('code: $code, ')
          ..write('values: $values, ')
          ..write('isActive: $isActive, ')
          ..write('required: $required, ')
          ..write('regex: $regex, ')
          ..write('order: $order, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalDetails: $additionalDetails, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        dataType,
        referenceId,
        tenantId,
        code,
        values,
        isActive,
        required,
        regex,
        order,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalDetails,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Attribute &&
          other.id == this.id &&
          other.dataType == this.dataType &&
          other.referenceId == this.referenceId &&
          other.tenantId == this.tenantId &&
          other.code == this.code &&
          other.values == this.values &&
          other.isActive == this.isActive &&
          other.required == this.required &&
          other.regex == this.regex &&
          other.order == this.order &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalDetails == this.additionalDetails &&
          other.additionalFields == this.additionalFields);
}

class AttributesCompanion extends UpdateCompanion<Attribute> {
  final Value<String?> id;
  final Value<String?> dataType;
  final Value<String?> referenceId;
  final Value<String?> tenantId;
  final Value<String?> code;
  final Value<String?> values;
  final Value<bool?> isActive;
  final Value<bool?> required;
  final Value<String?> regex;
  final Value<int?> order;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalDetails;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const AttributesCompanion({
    this.id = const Value.absent(),
    this.dataType = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.code = const Value.absent(),
    this.values = const Value.absent(),
    this.isActive = const Value.absent(),
    this.required = const Value.absent(),
    this.regex = const Value.absent(),
    this.order = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalDetails = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AttributesCompanion.insert({
    this.id = const Value.absent(),
    this.dataType = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.code = const Value.absent(),
    this.values = const Value.absent(),
    this.isActive = const Value.absent(),
    this.required = const Value.absent(),
    this.regex = const Value.absent(),
    this.order = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalDetails = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<Attribute> custom({
    Expression<String>? id,
    Expression<String>? dataType,
    Expression<String>? referenceId,
    Expression<String>? tenantId,
    Expression<String>? code,
    Expression<String>? values,
    Expression<bool>? isActive,
    Expression<bool>? required,
    Expression<String>? regex,
    Expression<int>? order,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalDetails,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (dataType != null) 'data_type': dataType,
      if (referenceId != null) 'reference_id': referenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (code != null) 'code': code,
      if (values != null) 'values': values,
      if (isActive != null) 'is_active': isActive,
      if (required != null) 'required': required,
      if (regex != null) 'regex': regex,
      if (order != null) 'order': order,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalDetails != null) 'additional_details': additionalDetails,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AttributesCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? dataType,
      Value<String?>? referenceId,
      Value<String?>? tenantId,
      Value<String?>? code,
      Value<String?>? values,
      Value<bool?>? isActive,
      Value<bool?>? required,
      Value<String?>? regex,
      Value<int?>? order,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalDetails,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return AttributesCompanion(
      id: id ?? this.id,
      dataType: dataType ?? this.dataType,
      referenceId: referenceId ?? this.referenceId,
      tenantId: tenantId ?? this.tenantId,
      code: code ?? this.code,
      values: values ?? this.values,
      isActive: isActive ?? this.isActive,
      required: required ?? this.required,
      regex: regex ?? this.regex,
      order: order ?? this.order,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalDetails: additionalDetails ?? this.additionalDetails,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (dataType.present) {
      map['data_type'] = Variable<String>(dataType.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (values.present) {
      map['values'] = Variable<String>(values.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (required.present) {
      map['required'] = Variable<bool>(required.value);
    }
    if (regex.present) {
      map['regex'] = Variable<String>(regex.value);
    }
    if (order.present) {
      map['order'] = Variable<int>(order.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalDetails.present) {
      map['additional_details'] = Variable<String>(additionalDetails.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AttributesCompanion(')
          ..write('id: $id, ')
          ..write('dataType: $dataType, ')
          ..write('referenceId: $referenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('code: $code, ')
          ..write('values: $values, ')
          ..write('isActive: $isActive, ')
          ..write('required: $required, ')
          ..write('regex: $regex, ')
          ..write('order: $order, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalDetails: $additionalDetails, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PgrServiceTable extends PgrService
    with TableInfo<$PgrServiceTable, PgrServiceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PgrServiceTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _activeMeta = const VerificationMeta('active');
  @override
  late final GeneratedColumn<bool> active = GeneratedColumn<bool>(
      'active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("active" IN (0, 1))'));
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _serviceCodeMeta =
      const VerificationMeta('serviceCode');
  @override
  late final GeneratedColumn<String> serviceCode = GeneratedColumn<String>(
      'service_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _serviceRequestIdMeta =
      const VerificationMeta('serviceRequestId');
  @override
  late final GeneratedColumn<String> serviceRequestId = GeneratedColumn<String>(
      'service_request_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _accountIdMeta =
      const VerificationMeta('accountId');
  @override
  late final GeneratedColumn<String> accountId = GeneratedColumn<String>(
      'account_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _applicationStatusMeta =
      const VerificationMeta('applicationStatus');
  @override
  late final GeneratedColumnWithTypeConverter<PgrServiceApplicationStatus, int>
      applicationStatus = GeneratedColumn<int>(
              'application_status', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<PgrServiceApplicationStatus>(
              $PgrServiceTable.$converterapplicationStatus);
  static const VerificationMeta _sourceMeta = const VerificationMeta('source');
  @override
  late final GeneratedColumn<String> source = GeneratedColumn<String>(
      'source', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        active,
        clientReferenceId,
        id,
        tenantId,
        serviceCode,
        description,
        serviceRequestId,
        accountId,
        applicationStatus,
        source,
        auditCreatedBy,
        auditCreatedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pgr_service';
  @override
  VerificationContext validateIntegrity(Insertable<PgrServiceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('active')) {
      context.handle(_activeMeta,
          active.isAcceptableOrUnknown(data['active']!, _activeMeta));
    } else if (isInserting) {
      context.missing(_activeMeta);
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('service_code')) {
      context.handle(
          _serviceCodeMeta,
          serviceCode.isAcceptableOrUnknown(
              data['service_code']!, _serviceCodeMeta));
    } else if (isInserting) {
      context.missing(_serviceCodeMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    } else if (isInserting) {
      context.missing(_descriptionMeta);
    }
    if (data.containsKey('service_request_id')) {
      context.handle(
          _serviceRequestIdMeta,
          serviceRequestId.isAcceptableOrUnknown(
              data['service_request_id']!, _serviceRequestIdMeta));
    }
    if (data.containsKey('account_id')) {
      context.handle(_accountIdMeta,
          accountId.isAcceptableOrUnknown(data['account_id']!, _accountIdMeta));
    }
    context.handle(_applicationStatusMeta, const VerificationResult.success());
    if (data.containsKey('source')) {
      context.handle(_sourceMeta,
          source.isAcceptableOrUnknown(data['source']!, _sourceMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    } else if (isInserting) {
      context.missing(_isDeletedMeta);
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    } else if (isInserting) {
      context.missing(_rowVersionMeta);
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {clientReferenceId, auditCreatedBy};
  @override
  PgrServiceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PgrServiceData(
      active: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}active'])!,
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      serviceCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}service_code'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description'])!,
      serviceRequestId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}service_request_id']),
      accountId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}account_id']),
      applicationStatus: $PgrServiceTable.$converterapplicationStatus.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.int, data['${effectivePrefix}application_status'])!),
      source: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}source']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version'])!,
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $PgrServiceTable createAlias(String alias) {
    return $PgrServiceTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<PgrServiceApplicationStatus, int, int>
      $converterapplicationStatus =
      const EnumIndexConverter<PgrServiceApplicationStatus>(
          PgrServiceApplicationStatus.values);
}

class PgrServiceData extends DataClass implements Insertable<PgrServiceData> {
  final bool active;
  final String clientReferenceId;
  final String? id;
  final String tenantId;
  final String serviceCode;
  final String description;
  final String? serviceRequestId;
  final String? accountId;
  final PgrServiceApplicationStatus applicationStatus;
  final String? source;
  final String? auditCreatedBy;
  final int? auditCreatedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool isDeleted;
  final int rowVersion;
  final String? additionalFields;
  const PgrServiceData(
      {required this.active,
      required this.clientReferenceId,
      this.id,
      required this.tenantId,
      required this.serviceCode,
      required this.description,
      this.serviceRequestId,
      this.accountId,
      required this.applicationStatus,
      this.source,
      this.auditCreatedBy,
      this.auditCreatedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.isDeleted,
      required this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['active'] = Variable<bool>(active);
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    map['tenant_id'] = Variable<String>(tenantId);
    map['service_code'] = Variable<String>(serviceCode);
    map['description'] = Variable<String>(description);
    if (!nullToAbsent || serviceRequestId != null) {
      map['service_request_id'] = Variable<String>(serviceRequestId);
    }
    if (!nullToAbsent || accountId != null) {
      map['account_id'] = Variable<String>(accountId);
    }
    {
      map['application_status'] = Variable<int>($PgrServiceTable
          .$converterapplicationStatus
          .toSql(applicationStatus));
    }
    if (!nullToAbsent || source != null) {
      map['source'] = Variable<String>(source);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['row_version'] = Variable<int>(rowVersion);
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  PgrServiceCompanion toCompanion(bool nullToAbsent) {
    return PgrServiceCompanion(
      active: Value(active),
      clientReferenceId: Value(clientReferenceId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: Value(tenantId),
      serviceCode: Value(serviceCode),
      description: Value(description),
      serviceRequestId: serviceRequestId == null && nullToAbsent
          ? const Value.absent()
          : Value(serviceRequestId),
      accountId: accountId == null && nullToAbsent
          ? const Value.absent()
          : Value(accountId),
      applicationStatus: Value(applicationStatus),
      source:
          source == null && nullToAbsent ? const Value.absent() : Value(source),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: Value(isDeleted),
      rowVersion: Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory PgrServiceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PgrServiceData(
      active: serializer.fromJson<bool>(json['active']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String>(json['tenantId']),
      serviceCode: serializer.fromJson<String>(json['serviceCode']),
      description: serializer.fromJson<String>(json['description']),
      serviceRequestId: serializer.fromJson<String?>(json['serviceRequestId']),
      accountId: serializer.fromJson<String?>(json['accountId']),
      applicationStatus: $PgrServiceTable.$converterapplicationStatus
          .fromJson(serializer.fromJson<int>(json['applicationStatus'])),
      source: serializer.fromJson<String?>(json['source']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      rowVersion: serializer.fromJson<int>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'active': serializer.toJson<bool>(active),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String>(tenantId),
      'serviceCode': serializer.toJson<String>(serviceCode),
      'description': serializer.toJson<String>(description),
      'serviceRequestId': serializer.toJson<String?>(serviceRequestId),
      'accountId': serializer.toJson<String?>(accountId),
      'applicationStatus': serializer.toJson<int>($PgrServiceTable
          .$converterapplicationStatus
          .toJson(applicationStatus)),
      'source': serializer.toJson<String?>(source),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'rowVersion': serializer.toJson<int>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  PgrServiceData copyWith(
          {bool? active,
          String? clientReferenceId,
          Value<String?> id = const Value.absent(),
          String? tenantId,
          String? serviceCode,
          String? description,
          Value<String?> serviceRequestId = const Value.absent(),
          Value<String?> accountId = const Value.absent(),
          PgrServiceApplicationStatus? applicationStatus,
          Value<String?> source = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          bool? isDeleted,
          int? rowVersion,
          Value<String?> additionalFields = const Value.absent()}) =>
      PgrServiceData(
        active: active ?? this.active,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        id: id.present ? id.value : this.id,
        tenantId: tenantId ?? this.tenantId,
        serviceCode: serviceCode ?? this.serviceCode,
        description: description ?? this.description,
        serviceRequestId: serviceRequestId.present
            ? serviceRequestId.value
            : this.serviceRequestId,
        accountId: accountId.present ? accountId.value : this.accountId,
        applicationStatus: applicationStatus ?? this.applicationStatus,
        source: source.present ? source.value : this.source,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted ?? this.isDeleted,
        rowVersion: rowVersion ?? this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('PgrServiceData(')
          ..write('active: $active, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('serviceCode: $serviceCode, ')
          ..write('description: $description, ')
          ..write('serviceRequestId: $serviceRequestId, ')
          ..write('accountId: $accountId, ')
          ..write('applicationStatus: $applicationStatus, ')
          ..write('source: $source, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      active,
      clientReferenceId,
      id,
      tenantId,
      serviceCode,
      description,
      serviceRequestId,
      accountId,
      applicationStatus,
      source,
      auditCreatedBy,
      auditCreatedTime,
      auditModifiedBy,
      auditModifiedTime,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PgrServiceData &&
          other.active == this.active &&
          other.clientReferenceId == this.clientReferenceId &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.serviceCode == this.serviceCode &&
          other.description == this.description &&
          other.serviceRequestId == this.serviceRequestId &&
          other.accountId == this.accountId &&
          other.applicationStatus == this.applicationStatus &&
          other.source == this.source &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class PgrServiceCompanion extends UpdateCompanion<PgrServiceData> {
  final Value<bool> active;
  final Value<String> clientReferenceId;
  final Value<String?> id;
  final Value<String> tenantId;
  final Value<String> serviceCode;
  final Value<String> description;
  final Value<String?> serviceRequestId;
  final Value<String?> accountId;
  final Value<PgrServiceApplicationStatus> applicationStatus;
  final Value<String?> source;
  final Value<String?> auditCreatedBy;
  final Value<int?> auditCreatedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool> isDeleted;
  final Value<int> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const PgrServiceCompanion({
    this.active = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.serviceCode = const Value.absent(),
    this.description = const Value.absent(),
    this.serviceRequestId = const Value.absent(),
    this.accountId = const Value.absent(),
    this.applicationStatus = const Value.absent(),
    this.source = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PgrServiceCompanion.insert({
    required bool active,
    required String clientReferenceId,
    this.id = const Value.absent(),
    required String tenantId,
    required String serviceCode,
    required String description,
    this.serviceRequestId = const Value.absent(),
    this.accountId = const Value.absent(),
    required PgrServiceApplicationStatus applicationStatus,
    this.source = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required bool isDeleted,
    required int rowVersion,
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : active = Value(active),
        clientReferenceId = Value(clientReferenceId),
        tenantId = Value(tenantId),
        serviceCode = Value(serviceCode),
        description = Value(description),
        applicationStatus = Value(applicationStatus),
        isDeleted = Value(isDeleted),
        rowVersion = Value(rowVersion);
  static Insertable<PgrServiceData> custom({
    Expression<bool>? active,
    Expression<String>? clientReferenceId,
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? serviceCode,
    Expression<String>? description,
    Expression<String>? serviceRequestId,
    Expression<String>? accountId,
    Expression<int>? applicationStatus,
    Expression<String>? source,
    Expression<String>? auditCreatedBy,
    Expression<int>? auditCreatedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (active != null) 'active': active,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (serviceCode != null) 'service_code': serviceCode,
      if (description != null) 'description': description,
      if (serviceRequestId != null) 'service_request_id': serviceRequestId,
      if (accountId != null) 'account_id': accountId,
      if (applicationStatus != null) 'application_status': applicationStatus,
      if (source != null) 'source': source,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PgrServiceCompanion copyWith(
      {Value<bool>? active,
      Value<String>? clientReferenceId,
      Value<String?>? id,
      Value<String>? tenantId,
      Value<String>? serviceCode,
      Value<String>? description,
      Value<String?>? serviceRequestId,
      Value<String?>? accountId,
      Value<PgrServiceApplicationStatus>? applicationStatus,
      Value<String?>? source,
      Value<String?>? auditCreatedBy,
      Value<int?>? auditCreatedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool>? isDeleted,
      Value<int>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return PgrServiceCompanion(
      active: active ?? this.active,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      serviceCode: serviceCode ?? this.serviceCode,
      description: description ?? this.description,
      serviceRequestId: serviceRequestId ?? this.serviceRequestId,
      accountId: accountId ?? this.accountId,
      applicationStatus: applicationStatus ?? this.applicationStatus,
      source: source ?? this.source,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (active.present) {
      map['active'] = Variable<bool>(active.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (serviceCode.present) {
      map['service_code'] = Variable<String>(serviceCode.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (serviceRequestId.present) {
      map['service_request_id'] = Variable<String>(serviceRequestId.value);
    }
    if (accountId.present) {
      map['account_id'] = Variable<String>(accountId.value);
    }
    if (applicationStatus.present) {
      map['application_status'] = Variable<int>($PgrServiceTable
          .$converterapplicationStatus
          .toSql(applicationStatus.value));
    }
    if (source.present) {
      map['source'] = Variable<String>(source.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PgrServiceCompanion(')
          ..write('active: $active, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('serviceCode: $serviceCode, ')
          ..write('description: $description, ')
          ..write('serviceRequestId: $serviceRequestId, ')
          ..write('accountId: $accountId, ')
          ..write('applicationStatus: $applicationStatus, ')
          ..write('source: $source, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PgrComplainantTable extends PgrComplainant
    with TableInfo<$PgrComplainantTable, PgrComplainantData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PgrComplainantTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _complaintClientReferenceIdMeta =
      const VerificationMeta('complaintClientReferenceId');
  @override
  late final GeneratedColumn<String> complaintClientReferenceId =
      GeneratedColumn<String>(
          'complaint_client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _mobileNumberMeta =
      const VerificationMeta('mobileNumber');
  @override
  late final GeneratedColumn<String> mobileNumber = GeneratedColumn<String>(
      'mobile_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _emailIdMeta =
      const VerificationMeta('emailId');
  @override
  late final GeneratedColumn<String> emailId = GeneratedColumn<String>(
      'email_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _activeMeta = const VerificationMeta('active');
  @override
  late final GeneratedColumn<bool> active = GeneratedColumn<bool>(
      'active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("active" IN (0, 1))'));
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        clientReferenceId,
        complaintClientReferenceId,
        userName,
        name,
        type,
        mobileNumber,
        emailId,
        tenantId,
        uuid,
        active,
        auditCreatedBy,
        auditCreatedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pgr_complainant';
  @override
  VerificationContext validateIntegrity(Insertable<PgrComplainantData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('complaint_client_reference_id')) {
      context.handle(
          _complaintClientReferenceIdMeta,
          complaintClientReferenceId.isAcceptableOrUnknown(
              data['complaint_client_reference_id']!,
              _complaintClientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_complaintClientReferenceIdMeta);
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('mobile_number')) {
      context.handle(
          _mobileNumberMeta,
          mobileNumber.isAcceptableOrUnknown(
              data['mobile_number']!, _mobileNumberMeta));
    }
    if (data.containsKey('email_id')) {
      context.handle(_emailIdMeta,
          emailId.isAcceptableOrUnknown(data['email_id']!, _emailIdMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    }
    if (data.containsKey('active')) {
      context.handle(_activeMeta,
          active.isAcceptableOrUnknown(data['active']!, _activeMeta));
    } else if (isInserting) {
      context.missing(_activeMeta);
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    } else if (isInserting) {
      context.missing(_isDeletedMeta);
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    } else if (isInserting) {
      context.missing(_rowVersionMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {clientReferenceId, auditCreatedBy};
  @override
  PgrComplainantData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PgrComplainantData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      complaintClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}complaint_client_reference_id'])!,
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      mobileNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mobile_number']),
      emailId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email_id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid']),
      active: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}active'])!,
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version'])!,
    );
  }

  @override
  $PgrComplainantTable createAlias(String alias) {
    return $PgrComplainantTable(attachedDatabase, alias);
  }
}

class PgrComplainantData extends DataClass
    implements Insertable<PgrComplainantData> {
  final int? id;
  final String clientReferenceId;
  final String complaintClientReferenceId;
  final String? userName;
  final String? name;
  final String? type;
  final String? mobileNumber;
  final String? emailId;
  final String tenantId;
  final String? uuid;
  final bool active;
  final String? auditCreatedBy;
  final int? auditCreatedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool isDeleted;
  final int rowVersion;
  const PgrComplainantData(
      {this.id,
      required this.clientReferenceId,
      required this.complaintClientReferenceId,
      this.userName,
      this.name,
      this.type,
      this.mobileNumber,
      this.emailId,
      required this.tenantId,
      this.uuid,
      required this.active,
      this.auditCreatedBy,
      this.auditCreatedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.isDeleted,
      required this.rowVersion});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    map['complaint_client_reference_id'] =
        Variable<String>(complaintClientReferenceId);
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || mobileNumber != null) {
      map['mobile_number'] = Variable<String>(mobileNumber);
    }
    if (!nullToAbsent || emailId != null) {
      map['email_id'] = Variable<String>(emailId);
    }
    map['tenant_id'] = Variable<String>(tenantId);
    if (!nullToAbsent || uuid != null) {
      map['uuid'] = Variable<String>(uuid);
    }
    map['active'] = Variable<bool>(active);
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['row_version'] = Variable<int>(rowVersion);
    return map;
  }

  PgrComplainantCompanion toCompanion(bool nullToAbsent) {
    return PgrComplainantCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      clientReferenceId: Value(clientReferenceId),
      complaintClientReferenceId: Value(complaintClientReferenceId),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      mobileNumber: mobileNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(mobileNumber),
      emailId: emailId == null && nullToAbsent
          ? const Value.absent()
          : Value(emailId),
      tenantId: Value(tenantId),
      uuid: uuid == null && nullToAbsent ? const Value.absent() : Value(uuid),
      active: Value(active),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: Value(isDeleted),
      rowVersion: Value(rowVersion),
    );
  }

  factory PgrComplainantData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PgrComplainantData(
      id: serializer.fromJson<int?>(json['id']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      complaintClientReferenceId:
          serializer.fromJson<String>(json['complaintClientReferenceId']),
      userName: serializer.fromJson<String?>(json['userName']),
      name: serializer.fromJson<String?>(json['name']),
      type: serializer.fromJson<String?>(json['type']),
      mobileNumber: serializer.fromJson<String?>(json['mobileNumber']),
      emailId: serializer.fromJson<String?>(json['emailId']),
      tenantId: serializer.fromJson<String>(json['tenantId']),
      uuid: serializer.fromJson<String?>(json['uuid']),
      active: serializer.fromJson<bool>(json['active']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      rowVersion: serializer.fromJson<int>(json['rowVersion']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'complaintClientReferenceId':
          serializer.toJson<String>(complaintClientReferenceId),
      'userName': serializer.toJson<String?>(userName),
      'name': serializer.toJson<String?>(name),
      'type': serializer.toJson<String?>(type),
      'mobileNumber': serializer.toJson<String?>(mobileNumber),
      'emailId': serializer.toJson<String?>(emailId),
      'tenantId': serializer.toJson<String>(tenantId),
      'uuid': serializer.toJson<String?>(uuid),
      'active': serializer.toJson<bool>(active),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'rowVersion': serializer.toJson<int>(rowVersion),
    };
  }

  PgrComplainantData copyWith(
          {Value<int?> id = const Value.absent(),
          String? clientReferenceId,
          String? complaintClientReferenceId,
          Value<String?> userName = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<String?> mobileNumber = const Value.absent(),
          Value<String?> emailId = const Value.absent(),
          String? tenantId,
          Value<String?> uuid = const Value.absent(),
          bool? active,
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          bool? isDeleted,
          int? rowVersion}) =>
      PgrComplainantData(
        id: id.present ? id.value : this.id,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        complaintClientReferenceId:
            complaintClientReferenceId ?? this.complaintClientReferenceId,
        userName: userName.present ? userName.value : this.userName,
        name: name.present ? name.value : this.name,
        type: type.present ? type.value : this.type,
        mobileNumber:
            mobileNumber.present ? mobileNumber.value : this.mobileNumber,
        emailId: emailId.present ? emailId.value : this.emailId,
        tenantId: tenantId ?? this.tenantId,
        uuid: uuid.present ? uuid.value : this.uuid,
        active: active ?? this.active,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted ?? this.isDeleted,
        rowVersion: rowVersion ?? this.rowVersion,
      );
  @override
  String toString() {
    return (StringBuffer('PgrComplainantData(')
          ..write('id: $id, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('complaintClientReferenceId: $complaintClientReferenceId, ')
          ..write('userName: $userName, ')
          ..write('name: $name, ')
          ..write('type: $type, ')
          ..write('mobileNumber: $mobileNumber, ')
          ..write('emailId: $emailId, ')
          ..write('tenantId: $tenantId, ')
          ..write('uuid: $uuid, ')
          ..write('active: $active, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      clientReferenceId,
      complaintClientReferenceId,
      userName,
      name,
      type,
      mobileNumber,
      emailId,
      tenantId,
      uuid,
      active,
      auditCreatedBy,
      auditCreatedTime,
      auditModifiedBy,
      auditModifiedTime,
      isDeleted,
      rowVersion);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PgrComplainantData &&
          other.id == this.id &&
          other.clientReferenceId == this.clientReferenceId &&
          other.complaintClientReferenceId == this.complaintClientReferenceId &&
          other.userName == this.userName &&
          other.name == this.name &&
          other.type == this.type &&
          other.mobileNumber == this.mobileNumber &&
          other.emailId == this.emailId &&
          other.tenantId == this.tenantId &&
          other.uuid == this.uuid &&
          other.active == this.active &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion);
}

class PgrComplainantCompanion extends UpdateCompanion<PgrComplainantData> {
  final Value<int?> id;
  final Value<String> clientReferenceId;
  final Value<String> complaintClientReferenceId;
  final Value<String?> userName;
  final Value<String?> name;
  final Value<String?> type;
  final Value<String?> mobileNumber;
  final Value<String?> emailId;
  final Value<String> tenantId;
  final Value<String?> uuid;
  final Value<bool> active;
  final Value<String?> auditCreatedBy;
  final Value<int?> auditCreatedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool> isDeleted;
  final Value<int> rowVersion;
  final Value<int> rowid;
  const PgrComplainantCompanion({
    this.id = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.complaintClientReferenceId = const Value.absent(),
    this.userName = const Value.absent(),
    this.name = const Value.absent(),
    this.type = const Value.absent(),
    this.mobileNumber = const Value.absent(),
    this.emailId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.uuid = const Value.absent(),
    this.active = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PgrComplainantCompanion.insert({
    this.id = const Value.absent(),
    required String clientReferenceId,
    required String complaintClientReferenceId,
    this.userName = const Value.absent(),
    this.name = const Value.absent(),
    this.type = const Value.absent(),
    this.mobileNumber = const Value.absent(),
    this.emailId = const Value.absent(),
    required String tenantId,
    this.uuid = const Value.absent(),
    required bool active,
    this.auditCreatedBy = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required bool isDeleted,
    required int rowVersion,
    this.rowid = const Value.absent(),
  })  : clientReferenceId = Value(clientReferenceId),
        complaintClientReferenceId = Value(complaintClientReferenceId),
        tenantId = Value(tenantId),
        active = Value(active),
        isDeleted = Value(isDeleted),
        rowVersion = Value(rowVersion);
  static Insertable<PgrComplainantData> custom({
    Expression<int>? id,
    Expression<String>? clientReferenceId,
    Expression<String>? complaintClientReferenceId,
    Expression<String>? userName,
    Expression<String>? name,
    Expression<String>? type,
    Expression<String>? mobileNumber,
    Expression<String>? emailId,
    Expression<String>? tenantId,
    Expression<String>? uuid,
    Expression<bool>? active,
    Expression<String>? auditCreatedBy,
    Expression<int>? auditCreatedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (complaintClientReferenceId != null)
        'complaint_client_reference_id': complaintClientReferenceId,
      if (userName != null) 'user_name': userName,
      if (name != null) 'name': name,
      if (type != null) 'type': type,
      if (mobileNumber != null) 'mobile_number': mobileNumber,
      if (emailId != null) 'email_id': emailId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (uuid != null) 'uuid': uuid,
      if (active != null) 'active': active,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PgrComplainantCompanion copyWith(
      {Value<int?>? id,
      Value<String>? clientReferenceId,
      Value<String>? complaintClientReferenceId,
      Value<String?>? userName,
      Value<String?>? name,
      Value<String?>? type,
      Value<String?>? mobileNumber,
      Value<String?>? emailId,
      Value<String>? tenantId,
      Value<String?>? uuid,
      Value<bool>? active,
      Value<String?>? auditCreatedBy,
      Value<int?>? auditCreatedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool>? isDeleted,
      Value<int>? rowVersion,
      Value<int>? rowid}) {
    return PgrComplainantCompanion(
      id: id ?? this.id,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      complaintClientReferenceId:
          complaintClientReferenceId ?? this.complaintClientReferenceId,
      userName: userName ?? this.userName,
      name: name ?? this.name,
      type: type ?? this.type,
      mobileNumber: mobileNumber ?? this.mobileNumber,
      emailId: emailId ?? this.emailId,
      tenantId: tenantId ?? this.tenantId,
      uuid: uuid ?? this.uuid,
      active: active ?? this.active,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (complaintClientReferenceId.present) {
      map['complaint_client_reference_id'] =
          Variable<String>(complaintClientReferenceId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (mobileNumber.present) {
      map['mobile_number'] = Variable<String>(mobileNumber.value);
    }
    if (emailId.present) {
      map['email_id'] = Variable<String>(emailId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (active.present) {
      map['active'] = Variable<bool>(active.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PgrComplainantCompanion(')
          ..write('id: $id, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('complaintClientReferenceId: $complaintClientReferenceId, ')
          ..write('userName: $userName, ')
          ..write('name: $name, ')
          ..write('type: $type, ')
          ..write('mobileNumber: $mobileNumber, ')
          ..write('emailId: $emailId, ')
          ..write('tenantId: $tenantId, ')
          ..write('uuid: $uuid, ')
          ..write('active: $active, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserTable extends User with TableInfo<$UserTable, UserData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _salutationMeta =
      const VerificationMeta('salutation');
  @override
  late final GeneratedColumn<String> salutation = GeneratedColumn<String>(
      'salutation', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _genderMeta = const VerificationMeta('gender');
  @override
  late final GeneratedColumn<String> gender = GeneratedColumn<String>(
      'gender', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _mobileNumberMeta =
      const VerificationMeta('mobileNumber');
  @override
  late final GeneratedColumn<String> mobileNumber = GeneratedColumn<String>(
      'mobile_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _emailIdMeta =
      const VerificationMeta('emailId');
  @override
  late final GeneratedColumn<String> emailId = GeneratedColumn<String>(
      'email_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _altContactNumberMeta =
      const VerificationMeta('altContactNumber');
  @override
  late final GeneratedColumn<String> altContactNumber = GeneratedColumn<String>(
      'alt_contact_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _panMeta = const VerificationMeta('pan');
  @override
  late final GeneratedColumn<String> pan = GeneratedColumn<String>(
      'pan', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _aadhaarNumberMeta =
      const VerificationMeta('aadhaarNumber');
  @override
  late final GeneratedColumn<String> aadhaarNumber = GeneratedColumn<String>(
      'aadhaar_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _permanentAddressMeta =
      const VerificationMeta('permanentAddress');
  @override
  late final GeneratedColumn<String> permanentAddress = GeneratedColumn<String>(
      'permanent_address', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _permanentCityMeta =
      const VerificationMeta('permanentCity');
  @override
  late final GeneratedColumn<String> permanentCity = GeneratedColumn<String>(
      'permanent_city', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _permanentPinCodeMeta =
      const VerificationMeta('permanentPinCode');
  @override
  late final GeneratedColumn<String> permanentPinCode = GeneratedColumn<String>(
      'permanent_pin_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _correspondenceAddressMeta =
      const VerificationMeta('correspondenceAddress');
  @override
  late final GeneratedColumn<String> correspondenceAddress =
      GeneratedColumn<String>('correspondence_address', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _correspondenceCityMeta =
      const VerificationMeta('correspondenceCity');
  @override
  late final GeneratedColumn<String> correspondenceCity =
      GeneratedColumn<String>('correspondence_city', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _correspondencePinCodeMeta =
      const VerificationMeta('correspondencePinCode');
  @override
  late final GeneratedColumn<String> correspondencePinCode =
      GeneratedColumn<String>('correspondence_pin_code', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _alternatemobilenumberMeta =
      const VerificationMeta('alternatemobilenumber');
  @override
  late final GeneratedColumn<String> alternatemobilenumber =
      GeneratedColumn<String>('alternatemobilenumber', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _activeMeta = const VerificationMeta('active');
  @override
  late final GeneratedColumn<bool> active = GeneratedColumn<bool>(
      'active', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("active" IN (0, 1))'));
  static const VerificationMeta _localeMeta = const VerificationMeta('locale');
  @override
  late final GeneratedColumn<String> locale = GeneratedColumn<String>(
      'locale', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _accountLockedMeta =
      const VerificationMeta('accountLocked');
  @override
  late final GeneratedColumn<bool> accountLocked = GeneratedColumn<bool>(
      'account_locked', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("account_locked" IN (0, 1))'));
  static const VerificationMeta _accountLockedDateMeta =
      const VerificationMeta('accountLockedDate');
  @override
  late final GeneratedColumn<int> accountLockedDate = GeneratedColumn<int>(
      'account_locked_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _fatherOrHusbandNameMeta =
      const VerificationMeta('fatherOrHusbandName');
  @override
  late final GeneratedColumn<String> fatherOrHusbandName =
      GeneratedColumn<String>('father_or_husband_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _relationshipMeta =
      const VerificationMeta('relationship');
  @override
  late final GeneratedColumn<String> relationship = GeneratedColumn<String>(
      'relationship', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _signatureMeta =
      const VerificationMeta('signature');
  @override
  late final GeneratedColumn<String> signature = GeneratedColumn<String>(
      'signature', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _bloodGroupMeta =
      const VerificationMeta('bloodGroup');
  @override
  late final GeneratedColumn<String> bloodGroup = GeneratedColumn<String>(
      'blood_group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _photoMeta = const VerificationMeta('photo');
  @override
  late final GeneratedColumn<String> photo = GeneratedColumn<String>(
      'photo', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _identificationMarkMeta =
      const VerificationMeta('identificationMark');
  @override
  late final GeneratedColumn<String> identificationMark =
      GeneratedColumn<String>('identification_mark', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  @override
  late final GeneratedColumn<int> createdBy = GeneratedColumn<int>(
      'created_by', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _lastModifiedByMeta =
      const VerificationMeta('lastModifiedBy');
  @override
  late final GeneratedColumn<String> lastModifiedBy = GeneratedColumn<String>(
      'last_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<String> createdDate = GeneratedColumn<String>(
      'created_date', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        userName,
        salutation,
        name,
        gender,
        mobileNumber,
        emailId,
        altContactNumber,
        pan,
        aadhaarNumber,
        permanentAddress,
        permanentCity,
        permanentPinCode,
        correspondenceAddress,
        correspondenceCity,
        correspondencePinCode,
        alternatemobilenumber,
        active,
        locale,
        type,
        accountLocked,
        accountLockedDate,
        fatherOrHusbandName,
        relationship,
        signature,
        bloodGroup,
        photo,
        identificationMark,
        createdBy,
        lastModifiedBy,
        tenantId,
        uuid,
        createdDate,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user';
  @override
  VerificationContext validateIntegrity(Insertable<UserData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    }
    if (data.containsKey('salutation')) {
      context.handle(
          _salutationMeta,
          salutation.isAcceptableOrUnknown(
              data['salutation']!, _salutationMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('gender')) {
      context.handle(_genderMeta,
          gender.isAcceptableOrUnknown(data['gender']!, _genderMeta));
    }
    if (data.containsKey('mobile_number')) {
      context.handle(
          _mobileNumberMeta,
          mobileNumber.isAcceptableOrUnknown(
              data['mobile_number']!, _mobileNumberMeta));
    }
    if (data.containsKey('email_id')) {
      context.handle(_emailIdMeta,
          emailId.isAcceptableOrUnknown(data['email_id']!, _emailIdMeta));
    }
    if (data.containsKey('alt_contact_number')) {
      context.handle(
          _altContactNumberMeta,
          altContactNumber.isAcceptableOrUnknown(
              data['alt_contact_number']!, _altContactNumberMeta));
    }
    if (data.containsKey('pan')) {
      context.handle(
          _panMeta, pan.isAcceptableOrUnknown(data['pan']!, _panMeta));
    }
    if (data.containsKey('aadhaar_number')) {
      context.handle(
          _aadhaarNumberMeta,
          aadhaarNumber.isAcceptableOrUnknown(
              data['aadhaar_number']!, _aadhaarNumberMeta));
    }
    if (data.containsKey('permanent_address')) {
      context.handle(
          _permanentAddressMeta,
          permanentAddress.isAcceptableOrUnknown(
              data['permanent_address']!, _permanentAddressMeta));
    }
    if (data.containsKey('permanent_city')) {
      context.handle(
          _permanentCityMeta,
          permanentCity.isAcceptableOrUnknown(
              data['permanent_city']!, _permanentCityMeta));
    }
    if (data.containsKey('permanent_pin_code')) {
      context.handle(
          _permanentPinCodeMeta,
          permanentPinCode.isAcceptableOrUnknown(
              data['permanent_pin_code']!, _permanentPinCodeMeta));
    }
    if (data.containsKey('correspondence_address')) {
      context.handle(
          _correspondenceAddressMeta,
          correspondenceAddress.isAcceptableOrUnknown(
              data['correspondence_address']!, _correspondenceAddressMeta));
    }
    if (data.containsKey('correspondence_city')) {
      context.handle(
          _correspondenceCityMeta,
          correspondenceCity.isAcceptableOrUnknown(
              data['correspondence_city']!, _correspondenceCityMeta));
    }
    if (data.containsKey('correspondence_pin_code')) {
      context.handle(
          _correspondencePinCodeMeta,
          correspondencePinCode.isAcceptableOrUnknown(
              data['correspondence_pin_code']!, _correspondencePinCodeMeta));
    }
    if (data.containsKey('alternatemobilenumber')) {
      context.handle(
          _alternatemobilenumberMeta,
          alternatemobilenumber.isAcceptableOrUnknown(
              data['alternatemobilenumber']!, _alternatemobilenumberMeta));
    }
    if (data.containsKey('active')) {
      context.handle(_activeMeta,
          active.isAcceptableOrUnknown(data['active']!, _activeMeta));
    }
    if (data.containsKey('locale')) {
      context.handle(_localeMeta,
          locale.isAcceptableOrUnknown(data['locale']!, _localeMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('account_locked')) {
      context.handle(
          _accountLockedMeta,
          accountLocked.isAcceptableOrUnknown(
              data['account_locked']!, _accountLockedMeta));
    }
    if (data.containsKey('account_locked_date')) {
      context.handle(
          _accountLockedDateMeta,
          accountLockedDate.isAcceptableOrUnknown(
              data['account_locked_date']!, _accountLockedDateMeta));
    }
    if (data.containsKey('father_or_husband_name')) {
      context.handle(
          _fatherOrHusbandNameMeta,
          fatherOrHusbandName.isAcceptableOrUnknown(
              data['father_or_husband_name']!, _fatherOrHusbandNameMeta));
    }
    if (data.containsKey('relationship')) {
      context.handle(
          _relationshipMeta,
          relationship.isAcceptableOrUnknown(
              data['relationship']!, _relationshipMeta));
    }
    if (data.containsKey('signature')) {
      context.handle(_signatureMeta,
          signature.isAcceptableOrUnknown(data['signature']!, _signatureMeta));
    }
    if (data.containsKey('blood_group')) {
      context.handle(
          _bloodGroupMeta,
          bloodGroup.isAcceptableOrUnknown(
              data['blood_group']!, _bloodGroupMeta));
    }
    if (data.containsKey('photo')) {
      context.handle(
          _photoMeta, photo.isAcceptableOrUnknown(data['photo']!, _photoMeta));
    }
    if (data.containsKey('identification_mark')) {
      context.handle(
          _identificationMarkMeta,
          identificationMark.isAcceptableOrUnknown(
              data['identification_mark']!, _identificationMarkMeta));
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    }
    if (data.containsKey('last_modified_by')) {
      context.handle(
          _lastModifiedByMeta,
          lastModifiedBy.isAcceptableOrUnknown(
              data['last_modified_by']!, _lastModifiedByMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid, auditCreatedBy};
  @override
  UserData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name']),
      salutation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}salutation']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      gender: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}gender']),
      mobileNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mobile_number']),
      emailId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email_id']),
      altContactNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}alt_contact_number']),
      pan: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}pan']),
      aadhaarNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}aadhaar_number']),
      permanentAddress: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}permanent_address']),
      permanentCity: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}permanent_city']),
      permanentPinCode: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}permanent_pin_code']),
      correspondenceAddress: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}correspondence_address']),
      correspondenceCity: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}correspondence_city']),
      correspondencePinCode: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}correspondence_pin_code']),
      alternatemobilenumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}alternatemobilenumber']),
      active: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}active']),
      locale: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}locale']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      accountLocked: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}account_locked']),
      accountLockedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}account_locked_date']),
      fatherOrHusbandName: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}father_or_husband_name']),
      relationship: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}relationship']),
      signature: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}signature']),
      bloodGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}blood_group']),
      photo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}photo']),
      identificationMark: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}identification_mark']),
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_by']),
      lastModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}last_modified_by']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_date']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $UserTable createAlias(String alias) {
    return $UserTable(attachedDatabase, alias);
  }
}

class UserData extends DataClass implements Insertable<UserData> {
  final String? id;
  final String? userName;
  final String? salutation;
  final String? name;
  final String? gender;
  final String? mobileNumber;
  final String? emailId;
  final String? altContactNumber;
  final String? pan;
  final String? aadhaarNumber;
  final String? permanentAddress;
  final String? permanentCity;
  final String? permanentPinCode;
  final String? correspondenceAddress;
  final String? correspondenceCity;
  final String? correspondencePinCode;
  final String? alternatemobilenumber;
  final bool? active;
  final String? locale;
  final String? type;
  final bool? accountLocked;
  final int? accountLockedDate;
  final String? fatherOrHusbandName;
  final String? relationship;
  final String? signature;
  final String? bloodGroup;
  final String? photo;
  final String? identificationMark;
  final int? createdBy;
  final String? lastModifiedBy;
  final String? tenantId;
  final String? uuid;
  final String? createdDate;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const UserData(
      {this.id,
      this.userName,
      this.salutation,
      this.name,
      this.gender,
      this.mobileNumber,
      this.emailId,
      this.altContactNumber,
      this.pan,
      this.aadhaarNumber,
      this.permanentAddress,
      this.permanentCity,
      this.permanentPinCode,
      this.correspondenceAddress,
      this.correspondenceCity,
      this.correspondencePinCode,
      this.alternatemobilenumber,
      this.active,
      this.locale,
      this.type,
      this.accountLocked,
      this.accountLockedDate,
      this.fatherOrHusbandName,
      this.relationship,
      this.signature,
      this.bloodGroup,
      this.photo,
      this.identificationMark,
      this.createdBy,
      this.lastModifiedBy,
      this.tenantId,
      this.uuid,
      this.createdDate,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || salutation != null) {
      map['salutation'] = Variable<String>(salutation);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || gender != null) {
      map['gender'] = Variable<String>(gender);
    }
    if (!nullToAbsent || mobileNumber != null) {
      map['mobile_number'] = Variable<String>(mobileNumber);
    }
    if (!nullToAbsent || emailId != null) {
      map['email_id'] = Variable<String>(emailId);
    }
    if (!nullToAbsent || altContactNumber != null) {
      map['alt_contact_number'] = Variable<String>(altContactNumber);
    }
    if (!nullToAbsent || pan != null) {
      map['pan'] = Variable<String>(pan);
    }
    if (!nullToAbsent || aadhaarNumber != null) {
      map['aadhaar_number'] = Variable<String>(aadhaarNumber);
    }
    if (!nullToAbsent || permanentAddress != null) {
      map['permanent_address'] = Variable<String>(permanentAddress);
    }
    if (!nullToAbsent || permanentCity != null) {
      map['permanent_city'] = Variable<String>(permanentCity);
    }
    if (!nullToAbsent || permanentPinCode != null) {
      map['permanent_pin_code'] = Variable<String>(permanentPinCode);
    }
    if (!nullToAbsent || correspondenceAddress != null) {
      map['correspondence_address'] = Variable<String>(correspondenceAddress);
    }
    if (!nullToAbsent || correspondenceCity != null) {
      map['correspondence_city'] = Variable<String>(correspondenceCity);
    }
    if (!nullToAbsent || correspondencePinCode != null) {
      map['correspondence_pin_code'] = Variable<String>(correspondencePinCode);
    }
    if (!nullToAbsent || alternatemobilenumber != null) {
      map['alternatemobilenumber'] = Variable<String>(alternatemobilenumber);
    }
    if (!nullToAbsent || active != null) {
      map['active'] = Variable<bool>(active);
    }
    if (!nullToAbsent || locale != null) {
      map['locale'] = Variable<String>(locale);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || accountLocked != null) {
      map['account_locked'] = Variable<bool>(accountLocked);
    }
    if (!nullToAbsent || accountLockedDate != null) {
      map['account_locked_date'] = Variable<int>(accountLockedDate);
    }
    if (!nullToAbsent || fatherOrHusbandName != null) {
      map['father_or_husband_name'] = Variable<String>(fatherOrHusbandName);
    }
    if (!nullToAbsent || relationship != null) {
      map['relationship'] = Variable<String>(relationship);
    }
    if (!nullToAbsent || signature != null) {
      map['signature'] = Variable<String>(signature);
    }
    if (!nullToAbsent || bloodGroup != null) {
      map['blood_group'] = Variable<String>(bloodGroup);
    }
    if (!nullToAbsent || photo != null) {
      map['photo'] = Variable<String>(photo);
    }
    if (!nullToAbsent || identificationMark != null) {
      map['identification_mark'] = Variable<String>(identificationMark);
    }
    if (!nullToAbsent || createdBy != null) {
      map['created_by'] = Variable<int>(createdBy);
    }
    if (!nullToAbsent || lastModifiedBy != null) {
      map['last_modified_by'] = Variable<String>(lastModifiedBy);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || uuid != null) {
      map['uuid'] = Variable<String>(uuid);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<String>(createdDate);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  UserCompanion toCompanion(bool nullToAbsent) {
    return UserCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      salutation: salutation == null && nullToAbsent
          ? const Value.absent()
          : Value(salutation),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      gender:
          gender == null && nullToAbsent ? const Value.absent() : Value(gender),
      mobileNumber: mobileNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(mobileNumber),
      emailId: emailId == null && nullToAbsent
          ? const Value.absent()
          : Value(emailId),
      altContactNumber: altContactNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(altContactNumber),
      pan: pan == null && nullToAbsent ? const Value.absent() : Value(pan),
      aadhaarNumber: aadhaarNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(aadhaarNumber),
      permanentAddress: permanentAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(permanentAddress),
      permanentCity: permanentCity == null && nullToAbsent
          ? const Value.absent()
          : Value(permanentCity),
      permanentPinCode: permanentPinCode == null && nullToAbsent
          ? const Value.absent()
          : Value(permanentPinCode),
      correspondenceAddress: correspondenceAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(correspondenceAddress),
      correspondenceCity: correspondenceCity == null && nullToAbsent
          ? const Value.absent()
          : Value(correspondenceCity),
      correspondencePinCode: correspondencePinCode == null && nullToAbsent
          ? const Value.absent()
          : Value(correspondencePinCode),
      alternatemobilenumber: alternatemobilenumber == null && nullToAbsent
          ? const Value.absent()
          : Value(alternatemobilenumber),
      active:
          active == null && nullToAbsent ? const Value.absent() : Value(active),
      locale:
          locale == null && nullToAbsent ? const Value.absent() : Value(locale),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      accountLocked: accountLocked == null && nullToAbsent
          ? const Value.absent()
          : Value(accountLocked),
      accountLockedDate: accountLockedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(accountLockedDate),
      fatherOrHusbandName: fatherOrHusbandName == null && nullToAbsent
          ? const Value.absent()
          : Value(fatherOrHusbandName),
      relationship: relationship == null && nullToAbsent
          ? const Value.absent()
          : Value(relationship),
      signature: signature == null && nullToAbsent
          ? const Value.absent()
          : Value(signature),
      bloodGroup: bloodGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(bloodGroup),
      photo:
          photo == null && nullToAbsent ? const Value.absent() : Value(photo),
      identificationMark: identificationMark == null && nullToAbsent
          ? const Value.absent()
          : Value(identificationMark),
      createdBy: createdBy == null && nullToAbsent
          ? const Value.absent()
          : Value(createdBy),
      lastModifiedBy: lastModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedBy),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      uuid: uuid == null && nullToAbsent ? const Value.absent() : Value(uuid),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory UserData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserData(
      id: serializer.fromJson<String?>(json['id']),
      userName: serializer.fromJson<String?>(json['userName']),
      salutation: serializer.fromJson<String?>(json['salutation']),
      name: serializer.fromJson<String?>(json['name']),
      gender: serializer.fromJson<String?>(json['gender']),
      mobileNumber: serializer.fromJson<String?>(json['mobileNumber']),
      emailId: serializer.fromJson<String?>(json['emailId']),
      altContactNumber: serializer.fromJson<String?>(json['altContactNumber']),
      pan: serializer.fromJson<String?>(json['pan']),
      aadhaarNumber: serializer.fromJson<String?>(json['aadhaarNumber']),
      permanentAddress: serializer.fromJson<String?>(json['permanentAddress']),
      permanentCity: serializer.fromJson<String?>(json['permanentCity']),
      permanentPinCode: serializer.fromJson<String?>(json['permanentPinCode']),
      correspondenceAddress:
          serializer.fromJson<String?>(json['correspondenceAddress']),
      correspondenceCity:
          serializer.fromJson<String?>(json['correspondenceCity']),
      correspondencePinCode:
          serializer.fromJson<String?>(json['correspondencePinCode']),
      alternatemobilenumber:
          serializer.fromJson<String?>(json['alternatemobilenumber']),
      active: serializer.fromJson<bool?>(json['active']),
      locale: serializer.fromJson<String?>(json['locale']),
      type: serializer.fromJson<String?>(json['type']),
      accountLocked: serializer.fromJson<bool?>(json['accountLocked']),
      accountLockedDate: serializer.fromJson<int?>(json['accountLockedDate']),
      fatherOrHusbandName:
          serializer.fromJson<String?>(json['fatherOrHusbandName']),
      relationship: serializer.fromJson<String?>(json['relationship']),
      signature: serializer.fromJson<String?>(json['signature']),
      bloodGroup: serializer.fromJson<String?>(json['bloodGroup']),
      photo: serializer.fromJson<String?>(json['photo']),
      identificationMark:
          serializer.fromJson<String?>(json['identificationMark']),
      createdBy: serializer.fromJson<int?>(json['createdBy']),
      lastModifiedBy: serializer.fromJson<String?>(json['lastModifiedBy']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      uuid: serializer.fromJson<String?>(json['uuid']),
      createdDate: serializer.fromJson<String?>(json['createdDate']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'userName': serializer.toJson<String?>(userName),
      'salutation': serializer.toJson<String?>(salutation),
      'name': serializer.toJson<String?>(name),
      'gender': serializer.toJson<String?>(gender),
      'mobileNumber': serializer.toJson<String?>(mobileNumber),
      'emailId': serializer.toJson<String?>(emailId),
      'altContactNumber': serializer.toJson<String?>(altContactNumber),
      'pan': serializer.toJson<String?>(pan),
      'aadhaarNumber': serializer.toJson<String?>(aadhaarNumber),
      'permanentAddress': serializer.toJson<String?>(permanentAddress),
      'permanentCity': serializer.toJson<String?>(permanentCity),
      'permanentPinCode': serializer.toJson<String?>(permanentPinCode),
      'correspondenceAddress':
          serializer.toJson<String?>(correspondenceAddress),
      'correspondenceCity': serializer.toJson<String?>(correspondenceCity),
      'correspondencePinCode':
          serializer.toJson<String?>(correspondencePinCode),
      'alternatemobilenumber':
          serializer.toJson<String?>(alternatemobilenumber),
      'active': serializer.toJson<bool?>(active),
      'locale': serializer.toJson<String?>(locale),
      'type': serializer.toJson<String?>(type),
      'accountLocked': serializer.toJson<bool?>(accountLocked),
      'accountLockedDate': serializer.toJson<int?>(accountLockedDate),
      'fatherOrHusbandName': serializer.toJson<String?>(fatherOrHusbandName),
      'relationship': serializer.toJson<String?>(relationship),
      'signature': serializer.toJson<String?>(signature),
      'bloodGroup': serializer.toJson<String?>(bloodGroup),
      'photo': serializer.toJson<String?>(photo),
      'identificationMark': serializer.toJson<String?>(identificationMark),
      'createdBy': serializer.toJson<int?>(createdBy),
      'lastModifiedBy': serializer.toJson<String?>(lastModifiedBy),
      'tenantId': serializer.toJson<String?>(tenantId),
      'uuid': serializer.toJson<String?>(uuid),
      'createdDate': serializer.toJson<String?>(createdDate),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  UserData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> userName = const Value.absent(),
          Value<String?> salutation = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<String?> gender = const Value.absent(),
          Value<String?> mobileNumber = const Value.absent(),
          Value<String?> emailId = const Value.absent(),
          Value<String?> altContactNumber = const Value.absent(),
          Value<String?> pan = const Value.absent(),
          Value<String?> aadhaarNumber = const Value.absent(),
          Value<String?> permanentAddress = const Value.absent(),
          Value<String?> permanentCity = const Value.absent(),
          Value<String?> permanentPinCode = const Value.absent(),
          Value<String?> correspondenceAddress = const Value.absent(),
          Value<String?> correspondenceCity = const Value.absent(),
          Value<String?> correspondencePinCode = const Value.absent(),
          Value<String?> alternatemobilenumber = const Value.absent(),
          Value<bool?> active = const Value.absent(),
          Value<String?> locale = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<bool?> accountLocked = const Value.absent(),
          Value<int?> accountLockedDate = const Value.absent(),
          Value<String?> fatherOrHusbandName = const Value.absent(),
          Value<String?> relationship = const Value.absent(),
          Value<String?> signature = const Value.absent(),
          Value<String?> bloodGroup = const Value.absent(),
          Value<String?> photo = const Value.absent(),
          Value<String?> identificationMark = const Value.absent(),
          Value<int?> createdBy = const Value.absent(),
          Value<String?> lastModifiedBy = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> uuid = const Value.absent(),
          Value<String?> createdDate = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      UserData(
        id: id.present ? id.value : this.id,
        userName: userName.present ? userName.value : this.userName,
        salutation: salutation.present ? salutation.value : this.salutation,
        name: name.present ? name.value : this.name,
        gender: gender.present ? gender.value : this.gender,
        mobileNumber:
            mobileNumber.present ? mobileNumber.value : this.mobileNumber,
        emailId: emailId.present ? emailId.value : this.emailId,
        altContactNumber: altContactNumber.present
            ? altContactNumber.value
            : this.altContactNumber,
        pan: pan.present ? pan.value : this.pan,
        aadhaarNumber:
            aadhaarNumber.present ? aadhaarNumber.value : this.aadhaarNumber,
        permanentAddress: permanentAddress.present
            ? permanentAddress.value
            : this.permanentAddress,
        permanentCity:
            permanentCity.present ? permanentCity.value : this.permanentCity,
        permanentPinCode: permanentPinCode.present
            ? permanentPinCode.value
            : this.permanentPinCode,
        correspondenceAddress: correspondenceAddress.present
            ? correspondenceAddress.value
            : this.correspondenceAddress,
        correspondenceCity: correspondenceCity.present
            ? correspondenceCity.value
            : this.correspondenceCity,
        correspondencePinCode: correspondencePinCode.present
            ? correspondencePinCode.value
            : this.correspondencePinCode,
        alternatemobilenumber: alternatemobilenumber.present
            ? alternatemobilenumber.value
            : this.alternatemobilenumber,
        active: active.present ? active.value : this.active,
        locale: locale.present ? locale.value : this.locale,
        type: type.present ? type.value : this.type,
        accountLocked:
            accountLocked.present ? accountLocked.value : this.accountLocked,
        accountLockedDate: accountLockedDate.present
            ? accountLockedDate.value
            : this.accountLockedDate,
        fatherOrHusbandName: fatherOrHusbandName.present
            ? fatherOrHusbandName.value
            : this.fatherOrHusbandName,
        relationship:
            relationship.present ? relationship.value : this.relationship,
        signature: signature.present ? signature.value : this.signature,
        bloodGroup: bloodGroup.present ? bloodGroup.value : this.bloodGroup,
        photo: photo.present ? photo.value : this.photo,
        identificationMark: identificationMark.present
            ? identificationMark.value
            : this.identificationMark,
        createdBy: createdBy.present ? createdBy.value : this.createdBy,
        lastModifiedBy:
            lastModifiedBy.present ? lastModifiedBy.value : this.lastModifiedBy,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        uuid: uuid.present ? uuid.value : this.uuid,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('UserData(')
          ..write('id: $id, ')
          ..write('userName: $userName, ')
          ..write('salutation: $salutation, ')
          ..write('name: $name, ')
          ..write('gender: $gender, ')
          ..write('mobileNumber: $mobileNumber, ')
          ..write('emailId: $emailId, ')
          ..write('altContactNumber: $altContactNumber, ')
          ..write('pan: $pan, ')
          ..write('aadhaarNumber: $aadhaarNumber, ')
          ..write('permanentAddress: $permanentAddress, ')
          ..write('permanentCity: $permanentCity, ')
          ..write('permanentPinCode: $permanentPinCode, ')
          ..write('correspondenceAddress: $correspondenceAddress, ')
          ..write('correspondenceCity: $correspondenceCity, ')
          ..write('correspondencePinCode: $correspondencePinCode, ')
          ..write('alternatemobilenumber: $alternatemobilenumber, ')
          ..write('active: $active, ')
          ..write('locale: $locale, ')
          ..write('type: $type, ')
          ..write('accountLocked: $accountLocked, ')
          ..write('accountLockedDate: $accountLockedDate, ')
          ..write('fatherOrHusbandName: $fatherOrHusbandName, ')
          ..write('relationship: $relationship, ')
          ..write('signature: $signature, ')
          ..write('bloodGroup: $bloodGroup, ')
          ..write('photo: $photo, ')
          ..write('identificationMark: $identificationMark, ')
          ..write('createdBy: $createdBy, ')
          ..write('lastModifiedBy: $lastModifiedBy, ')
          ..write('tenantId: $tenantId, ')
          ..write('uuid: $uuid, ')
          ..write('createdDate: $createdDate, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        userName,
        salutation,
        name,
        gender,
        mobileNumber,
        emailId,
        altContactNumber,
        pan,
        aadhaarNumber,
        permanentAddress,
        permanentCity,
        permanentPinCode,
        correspondenceAddress,
        correspondenceCity,
        correspondencePinCode,
        alternatemobilenumber,
        active,
        locale,
        type,
        accountLocked,
        accountLockedDate,
        fatherOrHusbandName,
        relationship,
        signature,
        bloodGroup,
        photo,
        identificationMark,
        createdBy,
        lastModifiedBy,
        tenantId,
        uuid,
        createdDate,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserData &&
          other.id == this.id &&
          other.userName == this.userName &&
          other.salutation == this.salutation &&
          other.name == this.name &&
          other.gender == this.gender &&
          other.mobileNumber == this.mobileNumber &&
          other.emailId == this.emailId &&
          other.altContactNumber == this.altContactNumber &&
          other.pan == this.pan &&
          other.aadhaarNumber == this.aadhaarNumber &&
          other.permanentAddress == this.permanentAddress &&
          other.permanentCity == this.permanentCity &&
          other.permanentPinCode == this.permanentPinCode &&
          other.correspondenceAddress == this.correspondenceAddress &&
          other.correspondenceCity == this.correspondenceCity &&
          other.correspondencePinCode == this.correspondencePinCode &&
          other.alternatemobilenumber == this.alternatemobilenumber &&
          other.active == this.active &&
          other.locale == this.locale &&
          other.type == this.type &&
          other.accountLocked == this.accountLocked &&
          other.accountLockedDate == this.accountLockedDate &&
          other.fatherOrHusbandName == this.fatherOrHusbandName &&
          other.relationship == this.relationship &&
          other.signature == this.signature &&
          other.bloodGroup == this.bloodGroup &&
          other.photo == this.photo &&
          other.identificationMark == this.identificationMark &&
          other.createdBy == this.createdBy &&
          other.lastModifiedBy == this.lastModifiedBy &&
          other.tenantId == this.tenantId &&
          other.uuid == this.uuid &&
          other.createdDate == this.createdDate &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class UserCompanion extends UpdateCompanion<UserData> {
  final Value<String?> id;
  final Value<String?> userName;
  final Value<String?> salutation;
  final Value<String?> name;
  final Value<String?> gender;
  final Value<String?> mobileNumber;
  final Value<String?> emailId;
  final Value<String?> altContactNumber;
  final Value<String?> pan;
  final Value<String?> aadhaarNumber;
  final Value<String?> permanentAddress;
  final Value<String?> permanentCity;
  final Value<String?> permanentPinCode;
  final Value<String?> correspondenceAddress;
  final Value<String?> correspondenceCity;
  final Value<String?> correspondencePinCode;
  final Value<String?> alternatemobilenumber;
  final Value<bool?> active;
  final Value<String?> locale;
  final Value<String?> type;
  final Value<bool?> accountLocked;
  final Value<int?> accountLockedDate;
  final Value<String?> fatherOrHusbandName;
  final Value<String?> relationship;
  final Value<String?> signature;
  final Value<String?> bloodGroup;
  final Value<String?> photo;
  final Value<String?> identificationMark;
  final Value<int?> createdBy;
  final Value<String?> lastModifiedBy;
  final Value<String?> tenantId;
  final Value<String?> uuid;
  final Value<String?> createdDate;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const UserCompanion({
    this.id = const Value.absent(),
    this.userName = const Value.absent(),
    this.salutation = const Value.absent(),
    this.name = const Value.absent(),
    this.gender = const Value.absent(),
    this.mobileNumber = const Value.absent(),
    this.emailId = const Value.absent(),
    this.altContactNumber = const Value.absent(),
    this.pan = const Value.absent(),
    this.aadhaarNumber = const Value.absent(),
    this.permanentAddress = const Value.absent(),
    this.permanentCity = const Value.absent(),
    this.permanentPinCode = const Value.absent(),
    this.correspondenceAddress = const Value.absent(),
    this.correspondenceCity = const Value.absent(),
    this.correspondencePinCode = const Value.absent(),
    this.alternatemobilenumber = const Value.absent(),
    this.active = const Value.absent(),
    this.locale = const Value.absent(),
    this.type = const Value.absent(),
    this.accountLocked = const Value.absent(),
    this.accountLockedDate = const Value.absent(),
    this.fatherOrHusbandName = const Value.absent(),
    this.relationship = const Value.absent(),
    this.signature = const Value.absent(),
    this.bloodGroup = const Value.absent(),
    this.photo = const Value.absent(),
    this.identificationMark = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.lastModifiedBy = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.uuid = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserCompanion.insert({
    this.id = const Value.absent(),
    this.userName = const Value.absent(),
    this.salutation = const Value.absent(),
    this.name = const Value.absent(),
    this.gender = const Value.absent(),
    this.mobileNumber = const Value.absent(),
    this.emailId = const Value.absent(),
    this.altContactNumber = const Value.absent(),
    this.pan = const Value.absent(),
    this.aadhaarNumber = const Value.absent(),
    this.permanentAddress = const Value.absent(),
    this.permanentCity = const Value.absent(),
    this.permanentPinCode = const Value.absent(),
    this.correspondenceAddress = const Value.absent(),
    this.correspondenceCity = const Value.absent(),
    this.correspondencePinCode = const Value.absent(),
    this.alternatemobilenumber = const Value.absent(),
    this.active = const Value.absent(),
    this.locale = const Value.absent(),
    this.type = const Value.absent(),
    this.accountLocked = const Value.absent(),
    this.accountLockedDate = const Value.absent(),
    this.fatherOrHusbandName = const Value.absent(),
    this.relationship = const Value.absent(),
    this.signature = const Value.absent(),
    this.bloodGroup = const Value.absent(),
    this.photo = const Value.absent(),
    this.identificationMark = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.lastModifiedBy = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.uuid = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<UserData> custom({
    Expression<String>? id,
    Expression<String>? userName,
    Expression<String>? salutation,
    Expression<String>? name,
    Expression<String>? gender,
    Expression<String>? mobileNumber,
    Expression<String>? emailId,
    Expression<String>? altContactNumber,
    Expression<String>? pan,
    Expression<String>? aadhaarNumber,
    Expression<String>? permanentAddress,
    Expression<String>? permanentCity,
    Expression<String>? permanentPinCode,
    Expression<String>? correspondenceAddress,
    Expression<String>? correspondenceCity,
    Expression<String>? correspondencePinCode,
    Expression<String>? alternatemobilenumber,
    Expression<bool>? active,
    Expression<String>? locale,
    Expression<String>? type,
    Expression<bool>? accountLocked,
    Expression<int>? accountLockedDate,
    Expression<String>? fatherOrHusbandName,
    Expression<String>? relationship,
    Expression<String>? signature,
    Expression<String>? bloodGroup,
    Expression<String>? photo,
    Expression<String>? identificationMark,
    Expression<int>? createdBy,
    Expression<String>? lastModifiedBy,
    Expression<String>? tenantId,
    Expression<String>? uuid,
    Expression<String>? createdDate,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userName != null) 'user_name': userName,
      if (salutation != null) 'salutation': salutation,
      if (name != null) 'name': name,
      if (gender != null) 'gender': gender,
      if (mobileNumber != null) 'mobile_number': mobileNumber,
      if (emailId != null) 'email_id': emailId,
      if (altContactNumber != null) 'alt_contact_number': altContactNumber,
      if (pan != null) 'pan': pan,
      if (aadhaarNumber != null) 'aadhaar_number': aadhaarNumber,
      if (permanentAddress != null) 'permanent_address': permanentAddress,
      if (permanentCity != null) 'permanent_city': permanentCity,
      if (permanentPinCode != null) 'permanent_pin_code': permanentPinCode,
      if (correspondenceAddress != null)
        'correspondence_address': correspondenceAddress,
      if (correspondenceCity != null) 'correspondence_city': correspondenceCity,
      if (correspondencePinCode != null)
        'correspondence_pin_code': correspondencePinCode,
      if (alternatemobilenumber != null)
        'alternatemobilenumber': alternatemobilenumber,
      if (active != null) 'active': active,
      if (locale != null) 'locale': locale,
      if (type != null) 'type': type,
      if (accountLocked != null) 'account_locked': accountLocked,
      if (accountLockedDate != null) 'account_locked_date': accountLockedDate,
      if (fatherOrHusbandName != null)
        'father_or_husband_name': fatherOrHusbandName,
      if (relationship != null) 'relationship': relationship,
      if (signature != null) 'signature': signature,
      if (bloodGroup != null) 'blood_group': bloodGroup,
      if (photo != null) 'photo': photo,
      if (identificationMark != null) 'identification_mark': identificationMark,
      if (createdBy != null) 'created_by': createdBy,
      if (lastModifiedBy != null) 'last_modified_by': lastModifiedBy,
      if (tenantId != null) 'tenant_id': tenantId,
      if (uuid != null) 'uuid': uuid,
      if (createdDate != null) 'created_date': createdDate,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? userName,
      Value<String?>? salutation,
      Value<String?>? name,
      Value<String?>? gender,
      Value<String?>? mobileNumber,
      Value<String?>? emailId,
      Value<String?>? altContactNumber,
      Value<String?>? pan,
      Value<String?>? aadhaarNumber,
      Value<String?>? permanentAddress,
      Value<String?>? permanentCity,
      Value<String?>? permanentPinCode,
      Value<String?>? correspondenceAddress,
      Value<String?>? correspondenceCity,
      Value<String?>? correspondencePinCode,
      Value<String?>? alternatemobilenumber,
      Value<bool?>? active,
      Value<String?>? locale,
      Value<String?>? type,
      Value<bool?>? accountLocked,
      Value<int?>? accountLockedDate,
      Value<String?>? fatherOrHusbandName,
      Value<String?>? relationship,
      Value<String?>? signature,
      Value<String?>? bloodGroup,
      Value<String?>? photo,
      Value<String?>? identificationMark,
      Value<int?>? createdBy,
      Value<String?>? lastModifiedBy,
      Value<String?>? tenantId,
      Value<String?>? uuid,
      Value<String?>? createdDate,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return UserCompanion(
      id: id ?? this.id,
      userName: userName ?? this.userName,
      salutation: salutation ?? this.salutation,
      name: name ?? this.name,
      gender: gender ?? this.gender,
      mobileNumber: mobileNumber ?? this.mobileNumber,
      emailId: emailId ?? this.emailId,
      altContactNumber: altContactNumber ?? this.altContactNumber,
      pan: pan ?? this.pan,
      aadhaarNumber: aadhaarNumber ?? this.aadhaarNumber,
      permanentAddress: permanentAddress ?? this.permanentAddress,
      permanentCity: permanentCity ?? this.permanentCity,
      permanentPinCode: permanentPinCode ?? this.permanentPinCode,
      correspondenceAddress:
          correspondenceAddress ?? this.correspondenceAddress,
      correspondenceCity: correspondenceCity ?? this.correspondenceCity,
      correspondencePinCode:
          correspondencePinCode ?? this.correspondencePinCode,
      alternatemobilenumber:
          alternatemobilenumber ?? this.alternatemobilenumber,
      active: active ?? this.active,
      locale: locale ?? this.locale,
      type: type ?? this.type,
      accountLocked: accountLocked ?? this.accountLocked,
      accountLockedDate: accountLockedDate ?? this.accountLockedDate,
      fatherOrHusbandName: fatherOrHusbandName ?? this.fatherOrHusbandName,
      relationship: relationship ?? this.relationship,
      signature: signature ?? this.signature,
      bloodGroup: bloodGroup ?? this.bloodGroup,
      photo: photo ?? this.photo,
      identificationMark: identificationMark ?? this.identificationMark,
      createdBy: createdBy ?? this.createdBy,
      lastModifiedBy: lastModifiedBy ?? this.lastModifiedBy,
      tenantId: tenantId ?? this.tenantId,
      uuid: uuid ?? this.uuid,
      createdDate: createdDate ?? this.createdDate,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (salutation.present) {
      map['salutation'] = Variable<String>(salutation.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (gender.present) {
      map['gender'] = Variable<String>(gender.value);
    }
    if (mobileNumber.present) {
      map['mobile_number'] = Variable<String>(mobileNumber.value);
    }
    if (emailId.present) {
      map['email_id'] = Variable<String>(emailId.value);
    }
    if (altContactNumber.present) {
      map['alt_contact_number'] = Variable<String>(altContactNumber.value);
    }
    if (pan.present) {
      map['pan'] = Variable<String>(pan.value);
    }
    if (aadhaarNumber.present) {
      map['aadhaar_number'] = Variable<String>(aadhaarNumber.value);
    }
    if (permanentAddress.present) {
      map['permanent_address'] = Variable<String>(permanentAddress.value);
    }
    if (permanentCity.present) {
      map['permanent_city'] = Variable<String>(permanentCity.value);
    }
    if (permanentPinCode.present) {
      map['permanent_pin_code'] = Variable<String>(permanentPinCode.value);
    }
    if (correspondenceAddress.present) {
      map['correspondence_address'] =
          Variable<String>(correspondenceAddress.value);
    }
    if (correspondenceCity.present) {
      map['correspondence_city'] = Variable<String>(correspondenceCity.value);
    }
    if (correspondencePinCode.present) {
      map['correspondence_pin_code'] =
          Variable<String>(correspondencePinCode.value);
    }
    if (alternatemobilenumber.present) {
      map['alternatemobilenumber'] =
          Variable<String>(alternatemobilenumber.value);
    }
    if (active.present) {
      map['active'] = Variable<bool>(active.value);
    }
    if (locale.present) {
      map['locale'] = Variable<String>(locale.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (accountLocked.present) {
      map['account_locked'] = Variable<bool>(accountLocked.value);
    }
    if (accountLockedDate.present) {
      map['account_locked_date'] = Variable<int>(accountLockedDate.value);
    }
    if (fatherOrHusbandName.present) {
      map['father_or_husband_name'] =
          Variable<String>(fatherOrHusbandName.value);
    }
    if (relationship.present) {
      map['relationship'] = Variable<String>(relationship.value);
    }
    if (signature.present) {
      map['signature'] = Variable<String>(signature.value);
    }
    if (bloodGroup.present) {
      map['blood_group'] = Variable<String>(bloodGroup.value);
    }
    if (photo.present) {
      map['photo'] = Variable<String>(photo.value);
    }
    if (identificationMark.present) {
      map['identification_mark'] = Variable<String>(identificationMark.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<int>(createdBy.value);
    }
    if (lastModifiedBy.present) {
      map['last_modified_by'] = Variable<String>(lastModifiedBy.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<String>(createdDate.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserCompanion(')
          ..write('id: $id, ')
          ..write('userName: $userName, ')
          ..write('salutation: $salutation, ')
          ..write('name: $name, ')
          ..write('gender: $gender, ')
          ..write('mobileNumber: $mobileNumber, ')
          ..write('emailId: $emailId, ')
          ..write('altContactNumber: $altContactNumber, ')
          ..write('pan: $pan, ')
          ..write('aadhaarNumber: $aadhaarNumber, ')
          ..write('permanentAddress: $permanentAddress, ')
          ..write('permanentCity: $permanentCity, ')
          ..write('permanentPinCode: $permanentPinCode, ')
          ..write('correspondenceAddress: $correspondenceAddress, ')
          ..write('correspondenceCity: $correspondenceCity, ')
          ..write('correspondencePinCode: $correspondencePinCode, ')
          ..write('alternatemobilenumber: $alternatemobilenumber, ')
          ..write('active: $active, ')
          ..write('locale: $locale, ')
          ..write('type: $type, ')
          ..write('accountLocked: $accountLocked, ')
          ..write('accountLockedDate: $accountLockedDate, ')
          ..write('fatherOrHusbandName: $fatherOrHusbandName, ')
          ..write('relationship: $relationship, ')
          ..write('signature: $signature, ')
          ..write('bloodGroup: $bloodGroup, ')
          ..write('photo: $photo, ')
          ..write('identificationMark: $identificationMark, ')
          ..write('createdBy: $createdBy, ')
          ..write('lastModifiedBy: $lastModifiedBy, ')
          ..write('tenantId: $tenantId, ')
          ..write('uuid: $uuid, ')
          ..write('createdDate: $createdDate, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DownsyncTable extends Downsync
    with TableInfo<$DownsyncTable, DownsyncData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DownsyncTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _localityMeta =
      const VerificationMeta('locality');
  @override
  late final GeneratedColumn<String> locality = GeneratedColumn<String>(
      'locality', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _offsetMeta = const VerificationMeta('offset');
  @override
  late final GeneratedColumn<int> offset = GeneratedColumn<int>(
      'offset', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _limitMeta = const VerificationMeta('limit');
  @override
  late final GeneratedColumn<int> limit = GeneratedColumn<int>(
      'limit', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _lastSyncedTimeMeta =
      const VerificationMeta('lastSyncedTime');
  @override
  late final GeneratedColumn<int> lastSyncedTime = GeneratedColumn<int>(
      'last_synced_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _totalCountMeta =
      const VerificationMeta('totalCount');
  @override
  late final GeneratedColumn<int> totalCount = GeneratedColumn<int>(
      'total_count', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _boundaryNameMeta =
      const VerificationMeta('boundaryName');
  @override
  late final GeneratedColumn<String> boundaryName = GeneratedColumn<String>(
      'boundary_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        locality,
        projectId,
        offset,
        limit,
        lastSyncedTime,
        totalCount,
        boundaryName,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'downsync';
  @override
  VerificationContext validateIntegrity(Insertable<DownsyncData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('locality')) {
      context.handle(_localityMeta,
          locality.isAcceptableOrUnknown(data['locality']!, _localityMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('offset')) {
      context.handle(_offsetMeta,
          offset.isAcceptableOrUnknown(data['offset']!, _offsetMeta));
    }
    if (data.containsKey('limit')) {
      context.handle(
          _limitMeta, limit.isAcceptableOrUnknown(data['limit']!, _limitMeta));
    }
    if (data.containsKey('last_synced_time')) {
      context.handle(
          _lastSyncedTimeMeta,
          lastSyncedTime.isAcceptableOrUnknown(
              data['last_synced_time']!, _lastSyncedTimeMeta));
    }
    if (data.containsKey('total_count')) {
      context.handle(
          _totalCountMeta,
          totalCount.isAcceptableOrUnknown(
              data['total_count']!, _totalCountMeta));
    }
    if (data.containsKey('boundary_name')) {
      context.handle(
          _boundaryNameMeta,
          boundaryName.isAcceptableOrUnknown(
              data['boundary_name']!, _boundaryNameMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {locality, auditCreatedBy};
  @override
  DownsyncData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DownsyncData(
      locality: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}locality']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      offset: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}offset']),
      limit: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}limit']),
      lastSyncedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}last_synced_time']),
      totalCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}total_count']),
      boundaryName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}boundary_name']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $DownsyncTable createAlias(String alias) {
    return $DownsyncTable(attachedDatabase, alias);
  }
}

class DownsyncData extends DataClass implements Insertable<DownsyncData> {
  final String? locality;
  final String? projectId;
  final int? offset;
  final int? limit;
  final int? lastSyncedTime;
  final int? totalCount;
  final String? boundaryName;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const DownsyncData(
      {this.locality,
      this.projectId,
      this.offset,
      this.limit,
      this.lastSyncedTime,
      this.totalCount,
      this.boundaryName,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || locality != null) {
      map['locality'] = Variable<String>(locality);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || offset != null) {
      map['offset'] = Variable<int>(offset);
    }
    if (!nullToAbsent || limit != null) {
      map['limit'] = Variable<int>(limit);
    }
    if (!nullToAbsent || lastSyncedTime != null) {
      map['last_synced_time'] = Variable<int>(lastSyncedTime);
    }
    if (!nullToAbsent || totalCount != null) {
      map['total_count'] = Variable<int>(totalCount);
    }
    if (!nullToAbsent || boundaryName != null) {
      map['boundary_name'] = Variable<String>(boundaryName);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  DownsyncCompanion toCompanion(bool nullToAbsent) {
    return DownsyncCompanion(
      locality: locality == null && nullToAbsent
          ? const Value.absent()
          : Value(locality),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      offset:
          offset == null && nullToAbsent ? const Value.absent() : Value(offset),
      limit:
          limit == null && nullToAbsent ? const Value.absent() : Value(limit),
      lastSyncedTime: lastSyncedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncedTime),
      totalCount: totalCount == null && nullToAbsent
          ? const Value.absent()
          : Value(totalCount),
      boundaryName: boundaryName == null && nullToAbsent
          ? const Value.absent()
          : Value(boundaryName),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory DownsyncData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DownsyncData(
      locality: serializer.fromJson<String?>(json['locality']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      offset: serializer.fromJson<int?>(json['offset']),
      limit: serializer.fromJson<int?>(json['limit']),
      lastSyncedTime: serializer.fromJson<int?>(json['lastSyncedTime']),
      totalCount: serializer.fromJson<int?>(json['totalCount']),
      boundaryName: serializer.fromJson<String?>(json['boundaryName']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'locality': serializer.toJson<String?>(locality),
      'projectId': serializer.toJson<String?>(projectId),
      'offset': serializer.toJson<int?>(offset),
      'limit': serializer.toJson<int?>(limit),
      'lastSyncedTime': serializer.toJson<int?>(lastSyncedTime),
      'totalCount': serializer.toJson<int?>(totalCount),
      'boundaryName': serializer.toJson<String?>(boundaryName),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  DownsyncData copyWith(
          {Value<String?> locality = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<int?> offset = const Value.absent(),
          Value<int?> limit = const Value.absent(),
          Value<int?> lastSyncedTime = const Value.absent(),
          Value<int?> totalCount = const Value.absent(),
          Value<String?> boundaryName = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      DownsyncData(
        locality: locality.present ? locality.value : this.locality,
        projectId: projectId.present ? projectId.value : this.projectId,
        offset: offset.present ? offset.value : this.offset,
        limit: limit.present ? limit.value : this.limit,
        lastSyncedTime:
            lastSyncedTime.present ? lastSyncedTime.value : this.lastSyncedTime,
        totalCount: totalCount.present ? totalCount.value : this.totalCount,
        boundaryName:
            boundaryName.present ? boundaryName.value : this.boundaryName,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('DownsyncData(')
          ..write('locality: $locality, ')
          ..write('projectId: $projectId, ')
          ..write('offset: $offset, ')
          ..write('limit: $limit, ')
          ..write('lastSyncedTime: $lastSyncedTime, ')
          ..write('totalCount: $totalCount, ')
          ..write('boundaryName: $boundaryName, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      locality,
      projectId,
      offset,
      limit,
      lastSyncedTime,
      totalCount,
      boundaryName,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DownsyncData &&
          other.locality == this.locality &&
          other.projectId == this.projectId &&
          other.offset == this.offset &&
          other.limit == this.limit &&
          other.lastSyncedTime == this.lastSyncedTime &&
          other.totalCount == this.totalCount &&
          other.boundaryName == this.boundaryName &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class DownsyncCompanion extends UpdateCompanion<DownsyncData> {
  final Value<String?> locality;
  final Value<String?> projectId;
  final Value<int?> offset;
  final Value<int?> limit;
  final Value<int?> lastSyncedTime;
  final Value<int?> totalCount;
  final Value<String?> boundaryName;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const DownsyncCompanion({
    this.locality = const Value.absent(),
    this.projectId = const Value.absent(),
    this.offset = const Value.absent(),
    this.limit = const Value.absent(),
    this.lastSyncedTime = const Value.absent(),
    this.totalCount = const Value.absent(),
    this.boundaryName = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DownsyncCompanion.insert({
    this.locality = const Value.absent(),
    this.projectId = const Value.absent(),
    this.offset = const Value.absent(),
    this.limit = const Value.absent(),
    this.lastSyncedTime = const Value.absent(),
    this.totalCount = const Value.absent(),
    this.boundaryName = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<DownsyncData> custom({
    Expression<String>? locality,
    Expression<String>? projectId,
    Expression<int>? offset,
    Expression<int>? limit,
    Expression<int>? lastSyncedTime,
    Expression<int>? totalCount,
    Expression<String>? boundaryName,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (locality != null) 'locality': locality,
      if (projectId != null) 'project_id': projectId,
      if (offset != null) 'offset': offset,
      if (limit != null) 'limit': limit,
      if (lastSyncedTime != null) 'last_synced_time': lastSyncedTime,
      if (totalCount != null) 'total_count': totalCount,
      if (boundaryName != null) 'boundary_name': boundaryName,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DownsyncCompanion copyWith(
      {Value<String?>? locality,
      Value<String?>? projectId,
      Value<int?>? offset,
      Value<int?>? limit,
      Value<int?>? lastSyncedTime,
      Value<int?>? totalCount,
      Value<String?>? boundaryName,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return DownsyncCompanion(
      locality: locality ?? this.locality,
      projectId: projectId ?? this.projectId,
      offset: offset ?? this.offset,
      limit: limit ?? this.limit,
      lastSyncedTime: lastSyncedTime ?? this.lastSyncedTime,
      totalCount: totalCount ?? this.totalCount,
      boundaryName: boundaryName ?? this.boundaryName,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (locality.present) {
      map['locality'] = Variable<String>(locality.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (offset.present) {
      map['offset'] = Variable<int>(offset.value);
    }
    if (limit.present) {
      map['limit'] = Variable<int>(limit.value);
    }
    if (lastSyncedTime.present) {
      map['last_synced_time'] = Variable<int>(lastSyncedTime.value);
    }
    if (totalCount.present) {
      map['total_count'] = Variable<int>(totalCount.value);
    }
    if (boundaryName.present) {
      map['boundary_name'] = Variable<String>(boundaryName.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DownsyncCompanion(')
          ..write('locality: $locality, ')
          ..write('projectId: $projectId, ')
          ..write('offset: $offset, ')
          ..write('limit: $limit, ')
          ..write('lastSyncedTime: $lastSyncedTime, ')
          ..write('totalCount: $totalCount, ')
          ..write('boundaryName: $boundaryName, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DownsyncCriteriaTable extends DownsyncCriteria
    with TableInfo<$DownsyncCriteriaTable, DownsyncCriteriaData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DownsyncCriteriaTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _localityMeta =
      const VerificationMeta('locality');
  @override
  late final GeneratedColumn<String> locality = GeneratedColumn<String>(
      'locality', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _offsetMeta = const VerificationMeta('offset');
  @override
  late final GeneratedColumn<int> offset = GeneratedColumn<int>(
      'offset', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _limitMeta = const VerificationMeta('limit');
  @override
  late final GeneratedColumn<int> limit = GeneratedColumn<int>(
      'limit', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastSyncedTimeMeta =
      const VerificationMeta('lastSyncedTime');
  @override
  late final GeneratedColumn<int> lastSyncedTime = GeneratedColumn<int>(
      'last_synced_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _totalCountMeta =
      const VerificationMeta('totalCount');
  @override
  late final GeneratedColumn<int> totalCount = GeneratedColumn<int>(
      'total_count', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        locality,
        tenantId,
        offset,
        limit,
        projectId,
        lastSyncedTime,
        totalCount,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'downsync_criteria';
  @override
  VerificationContext validateIntegrity(
      Insertable<DownsyncCriteriaData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('locality')) {
      context.handle(_localityMeta,
          locality.isAcceptableOrUnknown(data['locality']!, _localityMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('offset')) {
      context.handle(_offsetMeta,
          offset.isAcceptableOrUnknown(data['offset']!, _offsetMeta));
    }
    if (data.containsKey('limit')) {
      context.handle(
          _limitMeta, limit.isAcceptableOrUnknown(data['limit']!, _limitMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('last_synced_time')) {
      context.handle(
          _lastSyncedTimeMeta,
          lastSyncedTime.isAcceptableOrUnknown(
              data['last_synced_time']!, _lastSyncedTimeMeta));
    }
    if (data.containsKey('total_count')) {
      context.handle(
          _totalCountMeta,
          totalCount.isAcceptableOrUnknown(
              data['total_count']!, _totalCountMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  DownsyncCriteriaData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DownsyncCriteriaData(
      locality: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}locality']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      offset: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}offset']),
      limit: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}limit']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      lastSyncedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}last_synced_time']),
      totalCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}total_count']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $DownsyncCriteriaTable createAlias(String alias) {
    return $DownsyncCriteriaTable(attachedDatabase, alias);
  }
}

class DownsyncCriteriaData extends DataClass
    implements Insertable<DownsyncCriteriaData> {
  final String? locality;
  final String? tenantId;
  final int? offset;
  final int? limit;
  final String? projectId;
  final int? lastSyncedTime;
  final int? totalCount;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const DownsyncCriteriaData(
      {this.locality,
      this.tenantId,
      this.offset,
      this.limit,
      this.projectId,
      this.lastSyncedTime,
      this.totalCount,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || locality != null) {
      map['locality'] = Variable<String>(locality);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || offset != null) {
      map['offset'] = Variable<int>(offset);
    }
    if (!nullToAbsent || limit != null) {
      map['limit'] = Variable<int>(limit);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || lastSyncedTime != null) {
      map['last_synced_time'] = Variable<int>(lastSyncedTime);
    }
    if (!nullToAbsent || totalCount != null) {
      map['total_count'] = Variable<int>(totalCount);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  DownsyncCriteriaCompanion toCompanion(bool nullToAbsent) {
    return DownsyncCriteriaCompanion(
      locality: locality == null && nullToAbsent
          ? const Value.absent()
          : Value(locality),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      offset:
          offset == null && nullToAbsent ? const Value.absent() : Value(offset),
      limit:
          limit == null && nullToAbsent ? const Value.absent() : Value(limit),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      lastSyncedTime: lastSyncedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncedTime),
      totalCount: totalCount == null && nullToAbsent
          ? const Value.absent()
          : Value(totalCount),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory DownsyncCriteriaData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DownsyncCriteriaData(
      locality: serializer.fromJson<String?>(json['locality']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      offset: serializer.fromJson<int?>(json['offset']),
      limit: serializer.fromJson<int?>(json['limit']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      lastSyncedTime: serializer.fromJson<int?>(json['lastSyncedTime']),
      totalCount: serializer.fromJson<int?>(json['totalCount']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'locality': serializer.toJson<String?>(locality),
      'tenantId': serializer.toJson<String?>(tenantId),
      'offset': serializer.toJson<int?>(offset),
      'limit': serializer.toJson<int?>(limit),
      'projectId': serializer.toJson<String?>(projectId),
      'lastSyncedTime': serializer.toJson<int?>(lastSyncedTime),
      'totalCount': serializer.toJson<int?>(totalCount),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  DownsyncCriteriaData copyWith(
          {Value<String?> locality = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<int?> offset = const Value.absent(),
          Value<int?> limit = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<int?> lastSyncedTime = const Value.absent(),
          Value<int?> totalCount = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      DownsyncCriteriaData(
        locality: locality.present ? locality.value : this.locality,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        offset: offset.present ? offset.value : this.offset,
        limit: limit.present ? limit.value : this.limit,
        projectId: projectId.present ? projectId.value : this.projectId,
        lastSyncedTime:
            lastSyncedTime.present ? lastSyncedTime.value : this.lastSyncedTime,
        totalCount: totalCount.present ? totalCount.value : this.totalCount,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('DownsyncCriteriaData(')
          ..write('locality: $locality, ')
          ..write('tenantId: $tenantId, ')
          ..write('offset: $offset, ')
          ..write('limit: $limit, ')
          ..write('projectId: $projectId, ')
          ..write('lastSyncedTime: $lastSyncedTime, ')
          ..write('totalCount: $totalCount, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      locality,
      tenantId,
      offset,
      limit,
      projectId,
      lastSyncedTime,
      totalCount,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DownsyncCriteriaData &&
          other.locality == this.locality &&
          other.tenantId == this.tenantId &&
          other.offset == this.offset &&
          other.limit == this.limit &&
          other.projectId == this.projectId &&
          other.lastSyncedTime == this.lastSyncedTime &&
          other.totalCount == this.totalCount &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class DownsyncCriteriaCompanion extends UpdateCompanion<DownsyncCriteriaData> {
  final Value<String?> locality;
  final Value<String?> tenantId;
  final Value<int?> offset;
  final Value<int?> limit;
  final Value<String?> projectId;
  final Value<int?> lastSyncedTime;
  final Value<int?> totalCount;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const DownsyncCriteriaCompanion({
    this.locality = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.offset = const Value.absent(),
    this.limit = const Value.absent(),
    this.projectId = const Value.absent(),
    this.lastSyncedTime = const Value.absent(),
    this.totalCount = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DownsyncCriteriaCompanion.insert({
    this.locality = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.offset = const Value.absent(),
    this.limit = const Value.absent(),
    this.projectId = const Value.absent(),
    this.lastSyncedTime = const Value.absent(),
    this.totalCount = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<DownsyncCriteriaData> custom({
    Expression<String>? locality,
    Expression<String>? tenantId,
    Expression<int>? offset,
    Expression<int>? limit,
    Expression<String>? projectId,
    Expression<int>? lastSyncedTime,
    Expression<int>? totalCount,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (locality != null) 'locality': locality,
      if (tenantId != null) 'tenant_id': tenantId,
      if (offset != null) 'offset': offset,
      if (limit != null) 'limit': limit,
      if (projectId != null) 'project_id': projectId,
      if (lastSyncedTime != null) 'last_synced_time': lastSyncedTime,
      if (totalCount != null) 'total_count': totalCount,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DownsyncCriteriaCompanion copyWith(
      {Value<String?>? locality,
      Value<String?>? tenantId,
      Value<int?>? offset,
      Value<int?>? limit,
      Value<String?>? projectId,
      Value<int?>? lastSyncedTime,
      Value<int?>? totalCount,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return DownsyncCriteriaCompanion(
      locality: locality ?? this.locality,
      tenantId: tenantId ?? this.tenantId,
      offset: offset ?? this.offset,
      limit: limit ?? this.limit,
      projectId: projectId ?? this.projectId,
      lastSyncedTime: lastSyncedTime ?? this.lastSyncedTime,
      totalCount: totalCount ?? this.totalCount,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (locality.present) {
      map['locality'] = Variable<String>(locality.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (offset.present) {
      map['offset'] = Variable<int>(offset.value);
    }
    if (limit.present) {
      map['limit'] = Variable<int>(limit.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (lastSyncedTime.present) {
      map['last_synced_time'] = Variable<int>(lastSyncedTime.value);
    }
    if (totalCount.present) {
      map['total_count'] = Variable<int>(totalCount.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DownsyncCriteriaCompanion(')
          ..write('locality: $locality, ')
          ..write('tenantId: $tenantId, ')
          ..write('offset: $offset, ')
          ..write('limit: $limit, ')
          ..write('projectId: $projectId, ')
          ..write('lastSyncedTime: $lastSyncedTime, ')
          ..write('totalCount: $totalCount, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $HFReferralTable extends HFReferral
    with TableInfo<$HFReferralTable, HFReferralData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $HFReferralTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectFacilityIdMeta =
      const VerificationMeta('projectFacilityId');
  @override
  late final GeneratedColumn<String> projectFacilityId =
      GeneratedColumn<String>('project_facility_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _symptomSurveyIdMeta =
      const VerificationMeta('symptomSurveyId');
  @override
  late final GeneratedColumn<String> symptomSurveyId = GeneratedColumn<String>(
      'symptom_survey_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _beneficiaryIdMeta =
      const VerificationMeta('beneficiaryId');
  @override
  late final GeneratedColumn<String> beneficiaryId = GeneratedColumn<String>(
      'beneficiary_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referralCodeMeta =
      const VerificationMeta('referralCode');
  @override
  late final GeneratedColumn<String> referralCode = GeneratedColumn<String>(
      'referral_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nationalLevelIdMeta =
      const VerificationMeta('nationalLevelId');
  @override
  late final GeneratedColumn<String> nationalLevelId = GeneratedColumn<String>(
      'national_level_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _symptomMeta =
      const VerificationMeta('symptom');
  @override
  late final GeneratedColumn<String> symptom = GeneratedColumn<String>(
      'symptom', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        name,
        projectId,
        projectFacilityId,
        symptomSurveyId,
        beneficiaryId,
        referralCode,
        nationalLevelId,
        symptom,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'h_f_referral';
  @override
  VerificationContext validateIntegrity(Insertable<HFReferralData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('project_facility_id')) {
      context.handle(
          _projectFacilityIdMeta,
          projectFacilityId.isAcceptableOrUnknown(
              data['project_facility_id']!, _projectFacilityIdMeta));
    }
    if (data.containsKey('symptom_survey_id')) {
      context.handle(
          _symptomSurveyIdMeta,
          symptomSurveyId.isAcceptableOrUnknown(
              data['symptom_survey_id']!, _symptomSurveyIdMeta));
    }
    if (data.containsKey('beneficiary_id')) {
      context.handle(
          _beneficiaryIdMeta,
          beneficiaryId.isAcceptableOrUnknown(
              data['beneficiary_id']!, _beneficiaryIdMeta));
    }
    if (data.containsKey('referral_code')) {
      context.handle(
          _referralCodeMeta,
          referralCode.isAcceptableOrUnknown(
              data['referral_code']!, _referralCodeMeta));
    }
    if (data.containsKey('national_level_id')) {
      context.handle(
          _nationalLevelIdMeta,
          nationalLevelId.isAcceptableOrUnknown(
              data['national_level_id']!, _nationalLevelIdMeta));
    }
    if (data.containsKey('symptom')) {
      context.handle(_symptomMeta,
          symptom.isAcceptableOrUnknown(data['symptom']!, _symptomMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  HFReferralData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return HFReferralData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      projectFacilityId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}project_facility_id']),
      symptomSurveyId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}symptom_survey_id']),
      beneficiaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}beneficiary_id']),
      referralCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}referral_code']),
      nationalLevelId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}national_level_id']),
      symptom: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}symptom']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $HFReferralTable createAlias(String alias) {
    return $HFReferralTable(attachedDatabase, alias);
  }
}

class HFReferralData extends DataClass implements Insertable<HFReferralData> {
  final String? id;
  final String? tenantId;
  final String? name;
  final String? projectId;
  final String? projectFacilityId;
  final String? symptomSurveyId;
  final String? beneficiaryId;
  final String? referralCode;
  final String? nationalLevelId;
  final String? symptom;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const HFReferralData(
      {this.id,
      this.tenantId,
      this.name,
      this.projectId,
      this.projectFacilityId,
      this.symptomSurveyId,
      this.beneficiaryId,
      this.referralCode,
      this.nationalLevelId,
      this.symptom,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || projectFacilityId != null) {
      map['project_facility_id'] = Variable<String>(projectFacilityId);
    }
    if (!nullToAbsent || symptomSurveyId != null) {
      map['symptom_survey_id'] = Variable<String>(symptomSurveyId);
    }
    if (!nullToAbsent || beneficiaryId != null) {
      map['beneficiary_id'] = Variable<String>(beneficiaryId);
    }
    if (!nullToAbsent || referralCode != null) {
      map['referral_code'] = Variable<String>(referralCode);
    }
    if (!nullToAbsent || nationalLevelId != null) {
      map['national_level_id'] = Variable<String>(nationalLevelId);
    }
    if (!nullToAbsent || symptom != null) {
      map['symptom'] = Variable<String>(symptom);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  HFReferralCompanion toCompanion(bool nullToAbsent) {
    return HFReferralCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      projectFacilityId: projectFacilityId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectFacilityId),
      symptomSurveyId: symptomSurveyId == null && nullToAbsent
          ? const Value.absent()
          : Value(symptomSurveyId),
      beneficiaryId: beneficiaryId == null && nullToAbsent
          ? const Value.absent()
          : Value(beneficiaryId),
      referralCode: referralCode == null && nullToAbsent
          ? const Value.absent()
          : Value(referralCode),
      nationalLevelId: nationalLevelId == null && nullToAbsent
          ? const Value.absent()
          : Value(nationalLevelId),
      symptom: symptom == null && nullToAbsent
          ? const Value.absent()
          : Value(symptom),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory HFReferralData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return HFReferralData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      name: serializer.fromJson<String?>(json['name']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      projectFacilityId:
          serializer.fromJson<String?>(json['projectFacilityId']),
      symptomSurveyId: serializer.fromJson<String?>(json['symptomSurveyId']),
      beneficiaryId: serializer.fromJson<String?>(json['beneficiaryId']),
      referralCode: serializer.fromJson<String?>(json['referralCode']),
      nationalLevelId: serializer.fromJson<String?>(json['nationalLevelId']),
      symptom: serializer.fromJson<String?>(json['symptom']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String?>(tenantId),
      'name': serializer.toJson<String?>(name),
      'projectId': serializer.toJson<String?>(projectId),
      'projectFacilityId': serializer.toJson<String?>(projectFacilityId),
      'symptomSurveyId': serializer.toJson<String?>(symptomSurveyId),
      'beneficiaryId': serializer.toJson<String?>(beneficiaryId),
      'referralCode': serializer.toJson<String?>(referralCode),
      'nationalLevelId': serializer.toJson<String?>(nationalLevelId),
      'symptom': serializer.toJson<String?>(symptom),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  HFReferralData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> projectFacilityId = const Value.absent(),
          Value<String?> symptomSurveyId = const Value.absent(),
          Value<String?> beneficiaryId = const Value.absent(),
          Value<String?> referralCode = const Value.absent(),
          Value<String?> nationalLevelId = const Value.absent(),
          Value<String?> symptom = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      HFReferralData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        name: name.present ? name.value : this.name,
        projectId: projectId.present ? projectId.value : this.projectId,
        projectFacilityId: projectFacilityId.present
            ? projectFacilityId.value
            : this.projectFacilityId,
        symptomSurveyId: symptomSurveyId.present
            ? symptomSurveyId.value
            : this.symptomSurveyId,
        beneficiaryId:
            beneficiaryId.present ? beneficiaryId.value : this.beneficiaryId,
        referralCode:
            referralCode.present ? referralCode.value : this.referralCode,
        nationalLevelId: nationalLevelId.present
            ? nationalLevelId.value
            : this.nationalLevelId,
        symptom: symptom.present ? symptom.value : this.symptom,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('HFReferralData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('name: $name, ')
          ..write('projectId: $projectId, ')
          ..write('projectFacilityId: $projectFacilityId, ')
          ..write('symptomSurveyId: $symptomSurveyId, ')
          ..write('beneficiaryId: $beneficiaryId, ')
          ..write('referralCode: $referralCode, ')
          ..write('nationalLevelId: $nationalLevelId, ')
          ..write('symptom: $symptom, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        tenantId,
        name,
        projectId,
        projectFacilityId,
        symptomSurveyId,
        beneficiaryId,
        referralCode,
        nationalLevelId,
        symptom,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is HFReferralData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.name == this.name &&
          other.projectId == this.projectId &&
          other.projectFacilityId == this.projectFacilityId &&
          other.symptomSurveyId == this.symptomSurveyId &&
          other.beneficiaryId == this.beneficiaryId &&
          other.referralCode == this.referralCode &&
          other.nationalLevelId == this.nationalLevelId &&
          other.symptom == this.symptom &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class HFReferralCompanion extends UpdateCompanion<HFReferralData> {
  final Value<String?> id;
  final Value<String?> tenantId;
  final Value<String?> name;
  final Value<String?> projectId;
  final Value<String?> projectFacilityId;
  final Value<String?> symptomSurveyId;
  final Value<String?> beneficiaryId;
  final Value<String?> referralCode;
  final Value<String?> nationalLevelId;
  final Value<String?> symptom;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const HFReferralCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.name = const Value.absent(),
    this.projectId = const Value.absent(),
    this.projectFacilityId = const Value.absent(),
    this.symptomSurveyId = const Value.absent(),
    this.beneficiaryId = const Value.absent(),
    this.referralCode = const Value.absent(),
    this.nationalLevelId = const Value.absent(),
    this.symptom = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  HFReferralCompanion.insert({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.name = const Value.absent(),
    this.projectId = const Value.absent(),
    this.projectFacilityId = const Value.absent(),
    this.symptomSurveyId = const Value.absent(),
    this.beneficiaryId = const Value.absent(),
    this.referralCode = const Value.absent(),
    this.nationalLevelId = const Value.absent(),
    this.symptom = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<HFReferralData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? name,
    Expression<String>? projectId,
    Expression<String>? projectFacilityId,
    Expression<String>? symptomSurveyId,
    Expression<String>? beneficiaryId,
    Expression<String>? referralCode,
    Expression<String>? nationalLevelId,
    Expression<String>? symptom,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (name != null) 'name': name,
      if (projectId != null) 'project_id': projectId,
      if (projectFacilityId != null) 'project_facility_id': projectFacilityId,
      if (symptomSurveyId != null) 'symptom_survey_id': symptomSurveyId,
      if (beneficiaryId != null) 'beneficiary_id': beneficiaryId,
      if (referralCode != null) 'referral_code': referralCode,
      if (nationalLevelId != null) 'national_level_id': nationalLevelId,
      if (symptom != null) 'symptom': symptom,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  HFReferralCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? tenantId,
      Value<String?>? name,
      Value<String?>? projectId,
      Value<String?>? projectFacilityId,
      Value<String?>? symptomSurveyId,
      Value<String?>? beneficiaryId,
      Value<String?>? referralCode,
      Value<String?>? nationalLevelId,
      Value<String?>? symptom,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return HFReferralCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      name: name ?? this.name,
      projectId: projectId ?? this.projectId,
      projectFacilityId: projectFacilityId ?? this.projectFacilityId,
      symptomSurveyId: symptomSurveyId ?? this.symptomSurveyId,
      beneficiaryId: beneficiaryId ?? this.beneficiaryId,
      referralCode: referralCode ?? this.referralCode,
      nationalLevelId: nationalLevelId ?? this.nationalLevelId,
      symptom: symptom ?? this.symptom,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (projectFacilityId.present) {
      map['project_facility_id'] = Variable<String>(projectFacilityId.value);
    }
    if (symptomSurveyId.present) {
      map['symptom_survey_id'] = Variable<String>(symptomSurveyId.value);
    }
    if (beneficiaryId.present) {
      map['beneficiary_id'] = Variable<String>(beneficiaryId.value);
    }
    if (referralCode.present) {
      map['referral_code'] = Variable<String>(referralCode.value);
    }
    if (nationalLevelId.present) {
      map['national_level_id'] = Variable<String>(nationalLevelId.value);
    }
    if (symptom.present) {
      map['symptom'] = Variable<String>(symptom.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('HFReferralCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('name: $name, ')
          ..write('projectId: $projectId, ')
          ..write('projectFacilityId: $projectFacilityId, ')
          ..write('symptomSurveyId: $symptomSurveyId, ')
          ..write('beneficiaryId: $beneficiaryId, ')
          ..write('referralCode: $referralCode, ')
          ..write('nationalLevelId: $nationalLevelId, ')
          ..write('symptom: $symptom, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $HouseholdTable extends Household
    with TableInfo<$HouseholdTable, HouseholdData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $HouseholdTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _memberCountMeta =
      const VerificationMeta('memberCount');
  @override
  late final GeneratedColumn<int> memberCount = GeneratedColumn<int>(
      'member_count', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
      'latitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
      'longitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _householdTypeMeta =
      const VerificationMeta('householdType');
  @override
  late final GeneratedColumnWithTypeConverter<HouseholdType?, int>
      householdType = GeneratedColumn<int>('household_type', aliasedName, true,
              type: DriftSqlType.int, requiredDuringInsert: false)
          .withConverter<HouseholdType?>(
              $HouseholdTable.$converterhouseholdTypen);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        memberCount,
        latitude,
        longitude,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        householdType,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'household';
  @override
  VerificationContext validateIntegrity(Insertable<HouseholdData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('member_count')) {
      context.handle(
          _memberCountMeta,
          memberCount.isAcceptableOrUnknown(
              data['member_count']!, _memberCountMeta));
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    context.handle(_householdTypeMeta, const VerificationResult.success());
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  HouseholdData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return HouseholdData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      memberCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}member_count']),
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}latitude']),
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}longitude']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      householdType: $HouseholdTable.$converterhouseholdTypen.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.int, data['${effectivePrefix}household_type'])),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $HouseholdTable createAlias(String alias) {
    return $HouseholdTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<HouseholdType, int, int> $converterhouseholdType =
      const EnumIndexConverter<HouseholdType>(HouseholdType.values);
  static JsonTypeConverter2<HouseholdType?, int?, int?>
      $converterhouseholdTypen =
      JsonTypeConverter2.asNullable($converterhouseholdType);
}

class HouseholdData extends DataClass implements Insertable<HouseholdData> {
  final String? id;
  final int? memberCount;
  final double? latitude;
  final double? longitude;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final HouseholdType? householdType;
  final String? additionalFields;
  const HouseholdData(
      {this.id,
      this.memberCount,
      this.latitude,
      this.longitude,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.householdType,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || memberCount != null) {
      map['member_count'] = Variable<int>(memberCount);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || householdType != null) {
      map['household_type'] = Variable<int>(
          $HouseholdTable.$converterhouseholdTypen.toSql(householdType));
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  HouseholdCompanion toCompanion(bool nullToAbsent) {
    return HouseholdCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      memberCount: memberCount == null && nullToAbsent
          ? const Value.absent()
          : Value(memberCount),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      householdType: householdType == null && nullToAbsent
          ? const Value.absent()
          : Value(householdType),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory HouseholdData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return HouseholdData(
      id: serializer.fromJson<String?>(json['id']),
      memberCount: serializer.fromJson<int?>(json['memberCount']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      householdType: $HouseholdTable.$converterhouseholdTypen
          .fromJson(serializer.fromJson<int?>(json['householdType'])),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'memberCount': serializer.toJson<int?>(memberCount),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'householdType': serializer.toJson<int?>(
          $HouseholdTable.$converterhouseholdTypen.toJson(householdType)),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  HouseholdData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<int?> memberCount = const Value.absent(),
          Value<double?> latitude = const Value.absent(),
          Value<double?> longitude = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<HouseholdType?> householdType = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      HouseholdData(
        id: id.present ? id.value : this.id,
        memberCount: memberCount.present ? memberCount.value : this.memberCount,
        latitude: latitude.present ? latitude.value : this.latitude,
        longitude: longitude.present ? longitude.value : this.longitude,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        householdType:
            householdType.present ? householdType.value : this.householdType,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('HouseholdData(')
          ..write('id: $id, ')
          ..write('memberCount: $memberCount, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('householdType: $householdType, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      memberCount,
      latitude,
      longitude,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      householdType,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is HouseholdData &&
          other.id == this.id &&
          other.memberCount == this.memberCount &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.householdType == this.householdType &&
          other.additionalFields == this.additionalFields);
}

class HouseholdCompanion extends UpdateCompanion<HouseholdData> {
  final Value<String?> id;
  final Value<int?> memberCount;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<HouseholdType?> householdType;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const HouseholdCompanion({
    this.id = const Value.absent(),
    this.memberCount = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.householdType = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  HouseholdCompanion.insert({
    this.id = const Value.absent(),
    this.memberCount = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.householdType = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<HouseholdData> custom({
    Expression<String>? id,
    Expression<int>? memberCount,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? householdType,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (memberCount != null) 'member_count': memberCount,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (householdType != null) 'household_type': householdType,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  HouseholdCompanion copyWith(
      {Value<String?>? id,
      Value<int?>? memberCount,
      Value<double?>? latitude,
      Value<double?>? longitude,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<HouseholdType?>? householdType,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return HouseholdCompanion(
      id: id ?? this.id,
      memberCount: memberCount ?? this.memberCount,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      householdType: householdType ?? this.householdType,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (memberCount.present) {
      map['member_count'] = Variable<int>(memberCount.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (householdType.present) {
      map['household_type'] = Variable<int>(
          $HouseholdTable.$converterhouseholdTypen.toSql(householdType.value));
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('HouseholdCompanion(')
          ..write('id: $id, ')
          ..write('memberCount: $memberCount, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('householdType: $householdType, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $HouseholdMemberTable extends HouseholdMember
    with TableInfo<$HouseholdMemberTable, HouseholdMemberData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $HouseholdMemberTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _householdIdMeta =
      const VerificationMeta('householdId');
  @override
  late final GeneratedColumn<String> householdId = GeneratedColumn<String>(
      'household_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _householdClientReferenceIdMeta =
      const VerificationMeta('householdClientReferenceId');
  @override
  late final GeneratedColumn<String> householdClientReferenceId =
      GeneratedColumn<String>(
          'household_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _individualIdMeta =
      const VerificationMeta('individualId');
  @override
  late final GeneratedColumn<String> individualId = GeneratedColumn<String>(
      'individual_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _individualClientReferenceIdMeta =
      const VerificationMeta('individualClientReferenceId');
  @override
  late final GeneratedColumn<String> individualClientReferenceId =
      GeneratedColumn<String>(
          'individual_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isHeadOfHouseholdMeta =
      const VerificationMeta('isHeadOfHousehold');
  @override
  late final GeneratedColumn<bool> isHeadOfHousehold = GeneratedColumn<bool>(
      'is_head_of_household', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_head_of_household" IN (0, 1))'));
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        householdId,
        householdClientReferenceId,
        individualId,
        individualClientReferenceId,
        isHeadOfHousehold,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'household_member';
  @override
  VerificationContext validateIntegrity(
      Insertable<HouseholdMemberData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('household_id')) {
      context.handle(
          _householdIdMeta,
          householdId.isAcceptableOrUnknown(
              data['household_id']!, _householdIdMeta));
    }
    if (data.containsKey('household_client_reference_id')) {
      context.handle(
          _householdClientReferenceIdMeta,
          householdClientReferenceId.isAcceptableOrUnknown(
              data['household_client_reference_id']!,
              _householdClientReferenceIdMeta));
    }
    if (data.containsKey('individual_id')) {
      context.handle(
          _individualIdMeta,
          individualId.isAcceptableOrUnknown(
              data['individual_id']!, _individualIdMeta));
    }
    if (data.containsKey('individual_client_reference_id')) {
      context.handle(
          _individualClientReferenceIdMeta,
          individualClientReferenceId.isAcceptableOrUnknown(
              data['individual_client_reference_id']!,
              _individualClientReferenceIdMeta));
    }
    if (data.containsKey('is_head_of_household')) {
      context.handle(
          _isHeadOfHouseholdMeta,
          isHeadOfHousehold.isAcceptableOrUnknown(
              data['is_head_of_household']!, _isHeadOfHouseholdMeta));
    } else if (isInserting) {
      context.missing(_isHeadOfHouseholdMeta);
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  HouseholdMemberData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return HouseholdMemberData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      householdId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}household_id']),
      householdClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}household_client_reference_id']),
      individualId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}individual_id']),
      individualClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}individual_client_reference_id']),
      isHeadOfHousehold: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}is_head_of_household'])!,
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $HouseholdMemberTable createAlias(String alias) {
    return $HouseholdMemberTable(attachedDatabase, alias);
  }
}

class HouseholdMemberData extends DataClass
    implements Insertable<HouseholdMemberData> {
  final String? id;
  final String? householdId;
  final String? householdClientReferenceId;
  final String? individualId;
  final String? individualClientReferenceId;
  final bool isHeadOfHousehold;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const HouseholdMemberData(
      {this.id,
      this.householdId,
      this.householdClientReferenceId,
      this.individualId,
      this.individualClientReferenceId,
      required this.isHeadOfHousehold,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || householdId != null) {
      map['household_id'] = Variable<String>(householdId);
    }
    if (!nullToAbsent || householdClientReferenceId != null) {
      map['household_client_reference_id'] =
          Variable<String>(householdClientReferenceId);
    }
    if (!nullToAbsent || individualId != null) {
      map['individual_id'] = Variable<String>(individualId);
    }
    if (!nullToAbsent || individualClientReferenceId != null) {
      map['individual_client_reference_id'] =
          Variable<String>(individualClientReferenceId);
    }
    map['is_head_of_household'] = Variable<bool>(isHeadOfHousehold);
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  HouseholdMemberCompanion toCompanion(bool nullToAbsent) {
    return HouseholdMemberCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      householdId: householdId == null && nullToAbsent
          ? const Value.absent()
          : Value(householdId),
      householdClientReferenceId:
          householdClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(householdClientReferenceId),
      individualId: individualId == null && nullToAbsent
          ? const Value.absent()
          : Value(individualId),
      individualClientReferenceId:
          individualClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(individualClientReferenceId),
      isHeadOfHousehold: Value(isHeadOfHousehold),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory HouseholdMemberData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return HouseholdMemberData(
      id: serializer.fromJson<String?>(json['id']),
      householdId: serializer.fromJson<String?>(json['householdId']),
      householdClientReferenceId:
          serializer.fromJson<String?>(json['householdClientReferenceId']),
      individualId: serializer.fromJson<String?>(json['individualId']),
      individualClientReferenceId:
          serializer.fromJson<String?>(json['individualClientReferenceId']),
      isHeadOfHousehold: serializer.fromJson<bool>(json['isHeadOfHousehold']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'householdId': serializer.toJson<String?>(householdId),
      'householdClientReferenceId':
          serializer.toJson<String?>(householdClientReferenceId),
      'individualId': serializer.toJson<String?>(individualId),
      'individualClientReferenceId':
          serializer.toJson<String?>(individualClientReferenceId),
      'isHeadOfHousehold': serializer.toJson<bool>(isHeadOfHousehold),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  HouseholdMemberData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> householdId = const Value.absent(),
          Value<String?> householdClientReferenceId = const Value.absent(),
          Value<String?> individualId = const Value.absent(),
          Value<String?> individualClientReferenceId = const Value.absent(),
          bool? isHeadOfHousehold,
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      HouseholdMemberData(
        id: id.present ? id.value : this.id,
        householdId: householdId.present ? householdId.value : this.householdId,
        householdClientReferenceId: householdClientReferenceId.present
            ? householdClientReferenceId.value
            : this.householdClientReferenceId,
        individualId:
            individualId.present ? individualId.value : this.individualId,
        individualClientReferenceId: individualClientReferenceId.present
            ? individualClientReferenceId.value
            : this.individualClientReferenceId,
        isHeadOfHousehold: isHeadOfHousehold ?? this.isHeadOfHousehold,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('HouseholdMemberData(')
          ..write('id: $id, ')
          ..write('householdId: $householdId, ')
          ..write('householdClientReferenceId: $householdClientReferenceId, ')
          ..write('individualId: $individualId, ')
          ..write('individualClientReferenceId: $individualClientReferenceId, ')
          ..write('isHeadOfHousehold: $isHeadOfHousehold, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      householdId,
      householdClientReferenceId,
      individualId,
      individualClientReferenceId,
      isHeadOfHousehold,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is HouseholdMemberData &&
          other.id == this.id &&
          other.householdId == this.householdId &&
          other.householdClientReferenceId == this.householdClientReferenceId &&
          other.individualId == this.individualId &&
          other.individualClientReferenceId ==
              this.individualClientReferenceId &&
          other.isHeadOfHousehold == this.isHeadOfHousehold &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class HouseholdMemberCompanion extends UpdateCompanion<HouseholdMemberData> {
  final Value<String?> id;
  final Value<String?> householdId;
  final Value<String?> householdClientReferenceId;
  final Value<String?> individualId;
  final Value<String?> individualClientReferenceId;
  final Value<bool> isHeadOfHousehold;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const HouseholdMemberCompanion({
    this.id = const Value.absent(),
    this.householdId = const Value.absent(),
    this.householdClientReferenceId = const Value.absent(),
    this.individualId = const Value.absent(),
    this.individualClientReferenceId = const Value.absent(),
    this.isHeadOfHousehold = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  HouseholdMemberCompanion.insert({
    this.id = const Value.absent(),
    this.householdId = const Value.absent(),
    this.householdClientReferenceId = const Value.absent(),
    this.individualId = const Value.absent(),
    this.individualClientReferenceId = const Value.absent(),
    required bool isHeadOfHousehold,
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : isHeadOfHousehold = Value(isHeadOfHousehold),
        clientReferenceId = Value(clientReferenceId);
  static Insertable<HouseholdMemberData> custom({
    Expression<String>? id,
    Expression<String>? householdId,
    Expression<String>? householdClientReferenceId,
    Expression<String>? individualId,
    Expression<String>? individualClientReferenceId,
    Expression<bool>? isHeadOfHousehold,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (householdId != null) 'household_id': householdId,
      if (householdClientReferenceId != null)
        'household_client_reference_id': householdClientReferenceId,
      if (individualId != null) 'individual_id': individualId,
      if (individualClientReferenceId != null)
        'individual_client_reference_id': individualClientReferenceId,
      if (isHeadOfHousehold != null) 'is_head_of_household': isHeadOfHousehold,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  HouseholdMemberCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? householdId,
      Value<String?>? householdClientReferenceId,
      Value<String?>? individualId,
      Value<String?>? individualClientReferenceId,
      Value<bool>? isHeadOfHousehold,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return HouseholdMemberCompanion(
      id: id ?? this.id,
      householdId: householdId ?? this.householdId,
      householdClientReferenceId:
          householdClientReferenceId ?? this.householdClientReferenceId,
      individualId: individualId ?? this.individualId,
      individualClientReferenceId:
          individualClientReferenceId ?? this.individualClientReferenceId,
      isHeadOfHousehold: isHeadOfHousehold ?? this.isHeadOfHousehold,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (householdId.present) {
      map['household_id'] = Variable<String>(householdId.value);
    }
    if (householdClientReferenceId.present) {
      map['household_client_reference_id'] =
          Variable<String>(householdClientReferenceId.value);
    }
    if (individualId.present) {
      map['individual_id'] = Variable<String>(individualId.value);
    }
    if (individualClientReferenceId.present) {
      map['individual_client_reference_id'] =
          Variable<String>(individualClientReferenceId.value);
    }
    if (isHeadOfHousehold.present) {
      map['is_head_of_household'] = Variable<bool>(isHeadOfHousehold.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('HouseholdMemberCompanion(')
          ..write('id: $id, ')
          ..write('householdId: $householdId, ')
          ..write('householdClientReferenceId: $householdClientReferenceId, ')
          ..write('individualId: $individualId, ')
          ..write('individualClientReferenceId: $individualClientReferenceId, ')
          ..write('isHeadOfHousehold: $isHeadOfHousehold, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $HouseholdMemberRelationShipTable extends HouseholdMemberRelationShip
    with
        TableInfo<$HouseholdMemberRelationShipTable,
            HouseholdMemberRelationShipData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $HouseholdMemberRelationShipTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _selfIdMeta = const VerificationMeta('selfId');
  @override
  late final GeneratedColumn<String> selfId = GeneratedColumn<String>(
      'self_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _selfClientReferenceIdMeta =
      const VerificationMeta('selfClientReferenceId');
  @override
  late final GeneratedColumn<String> selfClientReferenceId =
      GeneratedColumn<String>('self_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _relativeIdMeta =
      const VerificationMeta('relativeId');
  @override
  late final GeneratedColumn<String> relativeId = GeneratedColumn<String>(
      'relative_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _relativeClientReferenceIdMeta =
      const VerificationMeta('relativeClientReferenceId');
  @override
  late final GeneratedColumn<String> relativeClientReferenceId =
      GeneratedColumn<String>('relative_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _relationshipTypeMeta =
      const VerificationMeta('relationshipType');
  @override
  late final GeneratedColumn<String> relationshipType = GeneratedColumn<String>(
      'relationship_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        selfId,
        selfClientReferenceId,
        relativeId,
        relativeClientReferenceId,
        relationshipType,
        clientReferenceId,
        tenantId,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'household_member_relation_ship';
  @override
  VerificationContext validateIntegrity(
      Insertable<HouseholdMemberRelationShipData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('self_id')) {
      context.handle(_selfIdMeta,
          selfId.isAcceptableOrUnknown(data['self_id']!, _selfIdMeta));
    }
    if (data.containsKey('self_client_reference_id')) {
      context.handle(
          _selfClientReferenceIdMeta,
          selfClientReferenceId.isAcceptableOrUnknown(
              data['self_client_reference_id']!, _selfClientReferenceIdMeta));
    }
    if (data.containsKey('relative_id')) {
      context.handle(
          _relativeIdMeta,
          relativeId.isAcceptableOrUnknown(
              data['relative_id']!, _relativeIdMeta));
    }
    if (data.containsKey('relative_client_reference_id')) {
      context.handle(
          _relativeClientReferenceIdMeta,
          relativeClientReferenceId.isAcceptableOrUnknown(
              data['relative_client_reference_id']!,
              _relativeClientReferenceIdMeta));
    }
    if (data.containsKey('relationship_type')) {
      context.handle(
          _relationshipTypeMeta,
          relationshipType.isAcceptableOrUnknown(
              data['relationship_type']!, _relationshipTypeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, clientReferenceId};
  @override
  HouseholdMemberRelationShipData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return HouseholdMemberRelationShipData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      selfId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}self_id']),
      selfClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}self_client_reference_id']),
      relativeId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}relative_id']),
      relativeClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}relative_client_reference_id']),
      relationshipType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}relationship_type']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $HouseholdMemberRelationShipTable createAlias(String alias) {
    return $HouseholdMemberRelationShipTable(attachedDatabase, alias);
  }
}

class HouseholdMemberRelationShipData extends DataClass
    implements Insertable<HouseholdMemberRelationShipData> {
  final String? id;
  final String? selfId;
  final String? selfClientReferenceId;
  final String? relativeId;
  final String? relativeClientReferenceId;
  final String? relationshipType;
  final String clientReferenceId;
  final String? tenantId;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const HouseholdMemberRelationShipData(
      {this.id,
      this.selfId,
      this.selfClientReferenceId,
      this.relativeId,
      this.relativeClientReferenceId,
      this.relationshipType,
      required this.clientReferenceId,
      this.tenantId,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || selfId != null) {
      map['self_id'] = Variable<String>(selfId);
    }
    if (!nullToAbsent || selfClientReferenceId != null) {
      map['self_client_reference_id'] = Variable<String>(selfClientReferenceId);
    }
    if (!nullToAbsent || relativeId != null) {
      map['relative_id'] = Variable<String>(relativeId);
    }
    if (!nullToAbsent || relativeClientReferenceId != null) {
      map['relative_client_reference_id'] =
          Variable<String>(relativeClientReferenceId);
    }
    if (!nullToAbsent || relationshipType != null) {
      map['relationship_type'] = Variable<String>(relationshipType);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  HouseholdMemberRelationShipCompanion toCompanion(bool nullToAbsent) {
    return HouseholdMemberRelationShipCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      selfId:
          selfId == null && nullToAbsent ? const Value.absent() : Value(selfId),
      selfClientReferenceId: selfClientReferenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(selfClientReferenceId),
      relativeId: relativeId == null && nullToAbsent
          ? const Value.absent()
          : Value(relativeId),
      relativeClientReferenceId:
          relativeClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(relativeClientReferenceId),
      relationshipType: relationshipType == null && nullToAbsent
          ? const Value.absent()
          : Value(relationshipType),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory HouseholdMemberRelationShipData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return HouseholdMemberRelationShipData(
      id: serializer.fromJson<String?>(json['id']),
      selfId: serializer.fromJson<String?>(json['selfId']),
      selfClientReferenceId:
          serializer.fromJson<String?>(json['selfClientReferenceId']),
      relativeId: serializer.fromJson<String?>(json['relativeId']),
      relativeClientReferenceId:
          serializer.fromJson<String?>(json['relativeClientReferenceId']),
      relationshipType: serializer.fromJson<String?>(json['relationshipType']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'selfId': serializer.toJson<String?>(selfId),
      'selfClientReferenceId':
          serializer.toJson<String?>(selfClientReferenceId),
      'relativeId': serializer.toJson<String?>(relativeId),
      'relativeClientReferenceId':
          serializer.toJson<String?>(relativeClientReferenceId),
      'relationshipType': serializer.toJson<String?>(relationshipType),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  HouseholdMemberRelationShipData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> selfId = const Value.absent(),
          Value<String?> selfClientReferenceId = const Value.absent(),
          Value<String?> relativeId = const Value.absent(),
          Value<String?> relativeClientReferenceId = const Value.absent(),
          Value<String?> relationshipType = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      HouseholdMemberRelationShipData(
        id: id.present ? id.value : this.id,
        selfId: selfId.present ? selfId.value : this.selfId,
        selfClientReferenceId: selfClientReferenceId.present
            ? selfClientReferenceId.value
            : this.selfClientReferenceId,
        relativeId: relativeId.present ? relativeId.value : this.relativeId,
        relativeClientReferenceId: relativeClientReferenceId.present
            ? relativeClientReferenceId.value
            : this.relativeClientReferenceId,
        relationshipType: relationshipType.present
            ? relationshipType.value
            : this.relationshipType,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('HouseholdMemberRelationShipData(')
          ..write('id: $id, ')
          ..write('selfId: $selfId, ')
          ..write('selfClientReferenceId: $selfClientReferenceId, ')
          ..write('relativeId: $relativeId, ')
          ..write('relativeClientReferenceId: $relativeClientReferenceId, ')
          ..write('relationshipType: $relationshipType, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      selfId,
      selfClientReferenceId,
      relativeId,
      relativeClientReferenceId,
      relationshipType,
      clientReferenceId,
      tenantId,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is HouseholdMemberRelationShipData &&
          other.id == this.id &&
          other.selfId == this.selfId &&
          other.selfClientReferenceId == this.selfClientReferenceId &&
          other.relativeId == this.relativeId &&
          other.relativeClientReferenceId == this.relativeClientReferenceId &&
          other.relationshipType == this.relationshipType &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class HouseholdMemberRelationShipCompanion
    extends UpdateCompanion<HouseholdMemberRelationShipData> {
  final Value<String?> id;
  final Value<String?> selfId;
  final Value<String?> selfClientReferenceId;
  final Value<String?> relativeId;
  final Value<String?> relativeClientReferenceId;
  final Value<String?> relationshipType;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const HouseholdMemberRelationShipCompanion({
    this.id = const Value.absent(),
    this.selfId = const Value.absent(),
    this.selfClientReferenceId = const Value.absent(),
    this.relativeId = const Value.absent(),
    this.relativeClientReferenceId = const Value.absent(),
    this.relationshipType = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  HouseholdMemberRelationShipCompanion.insert({
    this.id = const Value.absent(),
    this.selfId = const Value.absent(),
    this.selfClientReferenceId = const Value.absent(),
    this.relativeId = const Value.absent(),
    this.relativeClientReferenceId = const Value.absent(),
    this.relationshipType = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<HouseholdMemberRelationShipData> custom({
    Expression<String>? id,
    Expression<String>? selfId,
    Expression<String>? selfClientReferenceId,
    Expression<String>? relativeId,
    Expression<String>? relativeClientReferenceId,
    Expression<String>? relationshipType,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (selfId != null) 'self_id': selfId,
      if (selfClientReferenceId != null)
        'self_client_reference_id': selfClientReferenceId,
      if (relativeId != null) 'relative_id': relativeId,
      if (relativeClientReferenceId != null)
        'relative_client_reference_id': relativeClientReferenceId,
      if (relationshipType != null) 'relationship_type': relationshipType,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  HouseholdMemberRelationShipCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? selfId,
      Value<String?>? selfClientReferenceId,
      Value<String?>? relativeId,
      Value<String?>? relativeClientReferenceId,
      Value<String?>? relationshipType,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return HouseholdMemberRelationShipCompanion(
      id: id ?? this.id,
      selfId: selfId ?? this.selfId,
      selfClientReferenceId:
          selfClientReferenceId ?? this.selfClientReferenceId,
      relativeId: relativeId ?? this.relativeId,
      relativeClientReferenceId:
          relativeClientReferenceId ?? this.relativeClientReferenceId,
      relationshipType: relationshipType ?? this.relationshipType,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (selfId.present) {
      map['self_id'] = Variable<String>(selfId.value);
    }
    if (selfClientReferenceId.present) {
      map['self_client_reference_id'] =
          Variable<String>(selfClientReferenceId.value);
    }
    if (relativeId.present) {
      map['relative_id'] = Variable<String>(relativeId.value);
    }
    if (relativeClientReferenceId.present) {
      map['relative_client_reference_id'] =
          Variable<String>(relativeClientReferenceId.value);
    }
    if (relationshipType.present) {
      map['relationship_type'] = Variable<String>(relationshipType.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('HouseholdMemberRelationShipCompanion(')
          ..write('id: $id, ')
          ..write('selfId: $selfId, ')
          ..write('selfClientReferenceId: $selfClientReferenceId, ')
          ..write('relativeId: $relativeId, ')
          ..write('relativeClientReferenceId: $relativeClientReferenceId, ')
          ..write('relationshipType: $relationshipType, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TaskTable extends Task with TableInfo<$TaskTable, TaskData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TaskTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectBeneficiaryIdMeta =
      const VerificationMeta('projectBeneficiaryId');
  @override
  late final GeneratedColumn<String> projectBeneficiaryId =
      GeneratedColumn<String>('project_beneficiary_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectBeneficiaryClientReferenceIdMeta =
      const VerificationMeta('projectBeneficiaryClientReferenceId');
  @override
  late final GeneratedColumn<String> projectBeneficiaryClientReferenceId =
      GeneratedColumn<String>(
          'project_beneficiary_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
      'created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _plannedStartDateMeta =
      const VerificationMeta('plannedStartDate');
  @override
  late final GeneratedColumn<int> plannedStartDate = GeneratedColumn<int>(
      'planned_start_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _plannedEndDateMeta =
      const VerificationMeta('plannedEndDate');
  @override
  late final GeneratedColumn<int> plannedEndDate = GeneratedColumn<int>(
      'planned_end_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _actualStartDateMeta =
      const VerificationMeta('actualStartDate');
  @override
  late final GeneratedColumn<int> actualStartDate = GeneratedColumn<int>(
      'actual_start_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _actualEndDateMeta =
      const VerificationMeta('actualEndDate');
  @override
  late final GeneratedColumn<int> actualEndDate = GeneratedColumn<int>(
      'actual_end_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<int> createdDate = GeneratedColumn<int>(
      'created_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        projectId,
        projectBeneficiaryId,
        projectBeneficiaryClientReferenceId,
        createdBy,
        status,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        plannedStartDate,
        plannedEndDate,
        actualStartDate,
        actualEndDate,
        createdDate,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'task';
  @override
  VerificationContext validateIntegrity(Insertable<TaskData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('project_beneficiary_id')) {
      context.handle(
          _projectBeneficiaryIdMeta,
          projectBeneficiaryId.isAcceptableOrUnknown(
              data['project_beneficiary_id']!, _projectBeneficiaryIdMeta));
    }
    if (data.containsKey('project_beneficiary_client_reference_id')) {
      context.handle(
          _projectBeneficiaryClientReferenceIdMeta,
          projectBeneficiaryClientReferenceId.isAcceptableOrUnknown(
              data['project_beneficiary_client_reference_id']!,
              _projectBeneficiaryClientReferenceIdMeta));
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('planned_start_date')) {
      context.handle(
          _plannedStartDateMeta,
          plannedStartDate.isAcceptableOrUnknown(
              data['planned_start_date']!, _plannedStartDateMeta));
    }
    if (data.containsKey('planned_end_date')) {
      context.handle(
          _plannedEndDateMeta,
          plannedEndDate.isAcceptableOrUnknown(
              data['planned_end_date']!, _plannedEndDateMeta));
    }
    if (data.containsKey('actual_start_date')) {
      context.handle(
          _actualStartDateMeta,
          actualStartDate.isAcceptableOrUnknown(
              data['actual_start_date']!, _actualStartDateMeta));
    }
    if (data.containsKey('actual_end_date')) {
      context.handle(
          _actualEndDateMeta,
          actualEndDate.isAcceptableOrUnknown(
              data['actual_end_date']!, _actualEndDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  TaskData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TaskData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      projectBeneficiaryId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}project_beneficiary_id']),
      projectBeneficiaryClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}project_beneficiary_client_reference_id']),
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_by']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      plannedStartDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}planned_start_date']),
      plannedEndDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}planned_end_date']),
      actualStartDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}actual_start_date']),
      actualEndDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}actual_end_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_date']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $TaskTable createAlias(String alias) {
    return $TaskTable(attachedDatabase, alias);
  }
}

class TaskData extends DataClass implements Insertable<TaskData> {
  final String? id;
  final String? projectId;
  final String? projectBeneficiaryId;
  final String? projectBeneficiaryClientReferenceId;
  final String? createdBy;
  final String? status;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final int? plannedStartDate;
  final int? plannedEndDate;
  final int? actualStartDate;
  final int? actualEndDate;
  final int? createdDate;
  final String? additionalFields;
  const TaskData(
      {this.id,
      this.projectId,
      this.projectBeneficiaryId,
      this.projectBeneficiaryClientReferenceId,
      this.createdBy,
      this.status,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.plannedStartDate,
      this.plannedEndDate,
      this.actualStartDate,
      this.actualEndDate,
      this.createdDate,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || projectBeneficiaryId != null) {
      map['project_beneficiary_id'] = Variable<String>(projectBeneficiaryId);
    }
    if (!nullToAbsent || projectBeneficiaryClientReferenceId != null) {
      map['project_beneficiary_client_reference_id'] =
          Variable<String>(projectBeneficiaryClientReferenceId);
    }
    if (!nullToAbsent || createdBy != null) {
      map['created_by'] = Variable<String>(createdBy);
    }
    if (!nullToAbsent || status != null) {
      map['status'] = Variable<String>(status);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || plannedStartDate != null) {
      map['planned_start_date'] = Variable<int>(plannedStartDate);
    }
    if (!nullToAbsent || plannedEndDate != null) {
      map['planned_end_date'] = Variable<int>(plannedEndDate);
    }
    if (!nullToAbsent || actualStartDate != null) {
      map['actual_start_date'] = Variable<int>(actualStartDate);
    }
    if (!nullToAbsent || actualEndDate != null) {
      map['actual_end_date'] = Variable<int>(actualEndDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<int>(createdDate);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  TaskCompanion toCompanion(bool nullToAbsent) {
    return TaskCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      projectBeneficiaryId: projectBeneficiaryId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectBeneficiaryId),
      projectBeneficiaryClientReferenceId:
          projectBeneficiaryClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(projectBeneficiaryClientReferenceId),
      createdBy: createdBy == null && nullToAbsent
          ? const Value.absent()
          : Value(createdBy),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      plannedStartDate: plannedStartDate == null && nullToAbsent
          ? const Value.absent()
          : Value(plannedStartDate),
      plannedEndDate: plannedEndDate == null && nullToAbsent
          ? const Value.absent()
          : Value(plannedEndDate),
      actualStartDate: actualStartDate == null && nullToAbsent
          ? const Value.absent()
          : Value(actualStartDate),
      actualEndDate: actualEndDate == null && nullToAbsent
          ? const Value.absent()
          : Value(actualEndDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory TaskData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TaskData(
      id: serializer.fromJson<String?>(json['id']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      projectBeneficiaryId:
          serializer.fromJson<String?>(json['projectBeneficiaryId']),
      projectBeneficiaryClientReferenceId: serializer
          .fromJson<String?>(json['projectBeneficiaryClientReferenceId']),
      createdBy: serializer.fromJson<String?>(json['createdBy']),
      status: serializer.fromJson<String?>(json['status']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      plannedStartDate: serializer.fromJson<int?>(json['plannedStartDate']),
      plannedEndDate: serializer.fromJson<int?>(json['plannedEndDate']),
      actualStartDate: serializer.fromJson<int?>(json['actualStartDate']),
      actualEndDate: serializer.fromJson<int?>(json['actualEndDate']),
      createdDate: serializer.fromJson<int?>(json['createdDate']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'projectId': serializer.toJson<String?>(projectId),
      'projectBeneficiaryId': serializer.toJson<String?>(projectBeneficiaryId),
      'projectBeneficiaryClientReferenceId':
          serializer.toJson<String?>(projectBeneficiaryClientReferenceId),
      'createdBy': serializer.toJson<String?>(createdBy),
      'status': serializer.toJson<String?>(status),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'plannedStartDate': serializer.toJson<int?>(plannedStartDate),
      'plannedEndDate': serializer.toJson<int?>(plannedEndDate),
      'actualStartDate': serializer.toJson<int?>(actualStartDate),
      'actualEndDate': serializer.toJson<int?>(actualEndDate),
      'createdDate': serializer.toJson<int?>(createdDate),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  TaskData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> projectBeneficiaryId = const Value.absent(),
          Value<String?> projectBeneficiaryClientReferenceId =
              const Value.absent(),
          Value<String?> createdBy = const Value.absent(),
          Value<String?> status = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<int?> plannedStartDate = const Value.absent(),
          Value<int?> plannedEndDate = const Value.absent(),
          Value<int?> actualStartDate = const Value.absent(),
          Value<int?> actualEndDate = const Value.absent(),
          Value<int?> createdDate = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      TaskData(
        id: id.present ? id.value : this.id,
        projectId: projectId.present ? projectId.value : this.projectId,
        projectBeneficiaryId: projectBeneficiaryId.present
            ? projectBeneficiaryId.value
            : this.projectBeneficiaryId,
        projectBeneficiaryClientReferenceId:
            projectBeneficiaryClientReferenceId.present
                ? projectBeneficiaryClientReferenceId.value
                : this.projectBeneficiaryClientReferenceId,
        createdBy: createdBy.present ? createdBy.value : this.createdBy,
        status: status.present ? status.value : this.status,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        plannedStartDate: plannedStartDate.present
            ? plannedStartDate.value
            : this.plannedStartDate,
        plannedEndDate:
            plannedEndDate.present ? plannedEndDate.value : this.plannedEndDate,
        actualStartDate: actualStartDate.present
            ? actualStartDate.value
            : this.actualStartDate,
        actualEndDate:
            actualEndDate.present ? actualEndDate.value : this.actualEndDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('TaskData(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('projectBeneficiaryId: $projectBeneficiaryId, ')
          ..write(
              'projectBeneficiaryClientReferenceId: $projectBeneficiaryClientReferenceId, ')
          ..write('createdBy: $createdBy, ')
          ..write('status: $status, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('plannedStartDate: $plannedStartDate, ')
          ..write('plannedEndDate: $plannedEndDate, ')
          ..write('actualStartDate: $actualStartDate, ')
          ..write('actualEndDate: $actualEndDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        projectId,
        projectBeneficiaryId,
        projectBeneficiaryClientReferenceId,
        createdBy,
        status,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        plannedStartDate,
        plannedEndDate,
        actualStartDate,
        actualEndDate,
        createdDate,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TaskData &&
          other.id == this.id &&
          other.projectId == this.projectId &&
          other.projectBeneficiaryId == this.projectBeneficiaryId &&
          other.projectBeneficiaryClientReferenceId ==
              this.projectBeneficiaryClientReferenceId &&
          other.createdBy == this.createdBy &&
          other.status == this.status &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.plannedStartDate == this.plannedStartDate &&
          other.plannedEndDate == this.plannedEndDate &&
          other.actualStartDate == this.actualStartDate &&
          other.actualEndDate == this.actualEndDate &&
          other.createdDate == this.createdDate &&
          other.additionalFields == this.additionalFields);
}

class TaskCompanion extends UpdateCompanion<TaskData> {
  final Value<String?> id;
  final Value<String?> projectId;
  final Value<String?> projectBeneficiaryId;
  final Value<String?> projectBeneficiaryClientReferenceId;
  final Value<String?> createdBy;
  final Value<String?> status;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int?> plannedStartDate;
  final Value<int?> plannedEndDate;
  final Value<int?> actualStartDate;
  final Value<int?> actualEndDate;
  final Value<int?> createdDate;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const TaskCompanion({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.projectBeneficiaryId = const Value.absent(),
    this.projectBeneficiaryClientReferenceId = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.status = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.plannedStartDate = const Value.absent(),
    this.plannedEndDate = const Value.absent(),
    this.actualStartDate = const Value.absent(),
    this.actualEndDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TaskCompanion.insert({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.projectBeneficiaryId = const Value.absent(),
    this.projectBeneficiaryClientReferenceId = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.status = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.plannedStartDate = const Value.absent(),
    this.plannedEndDate = const Value.absent(),
    this.actualStartDate = const Value.absent(),
    this.actualEndDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<TaskData> custom({
    Expression<String>? id,
    Expression<String>? projectId,
    Expression<String>? projectBeneficiaryId,
    Expression<String>? projectBeneficiaryClientReferenceId,
    Expression<String>? createdBy,
    Expression<String>? status,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? plannedStartDate,
    Expression<int>? plannedEndDate,
    Expression<int>? actualStartDate,
    Expression<int>? actualEndDate,
    Expression<int>? createdDate,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (projectId != null) 'project_id': projectId,
      if (projectBeneficiaryId != null)
        'project_beneficiary_id': projectBeneficiaryId,
      if (projectBeneficiaryClientReferenceId != null)
        'project_beneficiary_client_reference_id':
            projectBeneficiaryClientReferenceId,
      if (createdBy != null) 'created_by': createdBy,
      if (status != null) 'status': status,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (plannedStartDate != null) 'planned_start_date': plannedStartDate,
      if (plannedEndDate != null) 'planned_end_date': plannedEndDate,
      if (actualStartDate != null) 'actual_start_date': actualStartDate,
      if (actualEndDate != null) 'actual_end_date': actualEndDate,
      if (createdDate != null) 'created_date': createdDate,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TaskCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? projectId,
      Value<String?>? projectBeneficiaryId,
      Value<String?>? projectBeneficiaryClientReferenceId,
      Value<String?>? createdBy,
      Value<String?>? status,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int?>? plannedStartDate,
      Value<int?>? plannedEndDate,
      Value<int?>? actualStartDate,
      Value<int?>? actualEndDate,
      Value<int?>? createdDate,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return TaskCompanion(
      id: id ?? this.id,
      projectId: projectId ?? this.projectId,
      projectBeneficiaryId: projectBeneficiaryId ?? this.projectBeneficiaryId,
      projectBeneficiaryClientReferenceId:
          projectBeneficiaryClientReferenceId ??
              this.projectBeneficiaryClientReferenceId,
      createdBy: createdBy ?? this.createdBy,
      status: status ?? this.status,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      plannedStartDate: plannedStartDate ?? this.plannedStartDate,
      plannedEndDate: plannedEndDate ?? this.plannedEndDate,
      actualStartDate: actualStartDate ?? this.actualStartDate,
      actualEndDate: actualEndDate ?? this.actualEndDate,
      createdDate: createdDate ?? this.createdDate,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (projectBeneficiaryId.present) {
      map['project_beneficiary_id'] =
          Variable<String>(projectBeneficiaryId.value);
    }
    if (projectBeneficiaryClientReferenceId.present) {
      map['project_beneficiary_client_reference_id'] =
          Variable<String>(projectBeneficiaryClientReferenceId.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (plannedStartDate.present) {
      map['planned_start_date'] = Variable<int>(plannedStartDate.value);
    }
    if (plannedEndDate.present) {
      map['planned_end_date'] = Variable<int>(plannedEndDate.value);
    }
    if (actualStartDate.present) {
      map['actual_start_date'] = Variable<int>(actualStartDate.value);
    }
    if (actualEndDate.present) {
      map['actual_end_date'] = Variable<int>(actualEndDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<int>(createdDate.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TaskCompanion(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('projectBeneficiaryId: $projectBeneficiaryId, ')
          ..write(
              'projectBeneficiaryClientReferenceId: $projectBeneficiaryClientReferenceId, ')
          ..write('createdBy: $createdBy, ')
          ..write('status: $status, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('plannedStartDate: $plannedStartDate, ')
          ..write('plannedEndDate: $plannedEndDate, ')
          ..write('actualStartDate: $actualStartDate, ')
          ..write('actualEndDate: $actualEndDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TaskResourceTable extends TaskResource
    with TableInfo<$TaskResourceTable, TaskResourceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TaskResourceTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _taskclientReferenceIdMeta =
      const VerificationMeta('taskclientReferenceId');
  @override
  late final GeneratedColumn<String> taskclientReferenceId =
      GeneratedColumn<String>('taskclient_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _taskIdMeta = const VerificationMeta('taskId');
  @override
  late final GeneratedColumn<String> taskId = GeneratedColumn<String>(
      'task_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _productVariantIdMeta =
      const VerificationMeta('productVariantId');
  @override
  late final GeneratedColumn<String> productVariantId = GeneratedColumn<String>(
      'product_variant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  @override
  late final GeneratedColumn<String> quantity = GeneratedColumn<String>(
      'quantity', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeliveredMeta =
      const VerificationMeta('isDelivered');
  @override
  late final GeneratedColumn<bool> isDelivered = GeneratedColumn<bool>(
      'is_delivered', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_delivered" IN (0, 1))'));
  static const VerificationMeta _deliveryCommentMeta =
      const VerificationMeta('deliveryComment');
  @override
  late final GeneratedColumn<String> deliveryComment = GeneratedColumn<String>(
      'delivery_comment', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        clientReferenceId,
        taskclientReferenceId,
        taskId,
        id,
        productVariantId,
        quantity,
        isDelivered,
        deliveryComment,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'task_resource';
  @override
  VerificationContext validateIntegrity(Insertable<TaskResourceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('taskclient_reference_id')) {
      context.handle(
          _taskclientReferenceIdMeta,
          taskclientReferenceId.isAcceptableOrUnknown(
              data['taskclient_reference_id']!, _taskclientReferenceIdMeta));
    }
    if (data.containsKey('task_id')) {
      context.handle(_taskIdMeta,
          taskId.isAcceptableOrUnknown(data['task_id']!, _taskIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('product_variant_id')) {
      context.handle(
          _productVariantIdMeta,
          productVariantId.isAcceptableOrUnknown(
              data['product_variant_id']!, _productVariantIdMeta));
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    }
    if (data.containsKey('is_delivered')) {
      context.handle(
          _isDeliveredMeta,
          isDelivered.isAcceptableOrUnknown(
              data['is_delivered']!, _isDeliveredMeta));
    }
    if (data.containsKey('delivery_comment')) {
      context.handle(
          _deliveryCommentMeta,
          deliveryComment.isAcceptableOrUnknown(
              data['delivery_comment']!, _deliveryCommentMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {clientReferenceId, auditCreatedBy};
  @override
  TaskResourceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TaskResourceData(
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      taskclientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}taskclient_reference_id']),
      taskId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}task_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      productVariantId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}product_variant_id']),
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}quantity']),
      isDelivered: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_delivered']),
      deliveryComment: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}delivery_comment']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $TaskResourceTable createAlias(String alias) {
    return $TaskResourceTable(attachedDatabase, alias);
  }
}

class TaskResourceData extends DataClass
    implements Insertable<TaskResourceData> {
  final String clientReferenceId;
  final String? taskclientReferenceId;
  final String? taskId;
  final String? id;
  final String? productVariantId;
  final String? quantity;
  final bool? isDelivered;
  final String? deliveryComment;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const TaskResourceData(
      {required this.clientReferenceId,
      this.taskclientReferenceId,
      this.taskId,
      this.id,
      this.productVariantId,
      this.quantity,
      this.isDelivered,
      this.deliveryComment,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || taskclientReferenceId != null) {
      map['taskclient_reference_id'] = Variable<String>(taskclientReferenceId);
    }
    if (!nullToAbsent || taskId != null) {
      map['task_id'] = Variable<String>(taskId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || productVariantId != null) {
      map['product_variant_id'] = Variable<String>(productVariantId);
    }
    if (!nullToAbsent || quantity != null) {
      map['quantity'] = Variable<String>(quantity);
    }
    if (!nullToAbsent || isDelivered != null) {
      map['is_delivered'] = Variable<bool>(isDelivered);
    }
    if (!nullToAbsent || deliveryComment != null) {
      map['delivery_comment'] = Variable<String>(deliveryComment);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  TaskResourceCompanion toCompanion(bool nullToAbsent) {
    return TaskResourceCompanion(
      clientReferenceId: Value(clientReferenceId),
      taskclientReferenceId: taskclientReferenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(taskclientReferenceId),
      taskId:
          taskId == null && nullToAbsent ? const Value.absent() : Value(taskId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      productVariantId: productVariantId == null && nullToAbsent
          ? const Value.absent()
          : Value(productVariantId),
      quantity: quantity == null && nullToAbsent
          ? const Value.absent()
          : Value(quantity),
      isDelivered: isDelivered == null && nullToAbsent
          ? const Value.absent()
          : Value(isDelivered),
      deliveryComment: deliveryComment == null && nullToAbsent
          ? const Value.absent()
          : Value(deliveryComment),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory TaskResourceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TaskResourceData(
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      taskclientReferenceId:
          serializer.fromJson<String?>(json['taskclientReferenceId']),
      taskId: serializer.fromJson<String?>(json['taskId']),
      id: serializer.fromJson<String?>(json['id']),
      productVariantId: serializer.fromJson<String?>(json['productVariantId']),
      quantity: serializer.fromJson<String?>(json['quantity']),
      isDelivered: serializer.fromJson<bool?>(json['isDelivered']),
      deliveryComment: serializer.fromJson<String?>(json['deliveryComment']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'taskclientReferenceId':
          serializer.toJson<String?>(taskclientReferenceId),
      'taskId': serializer.toJson<String?>(taskId),
      'id': serializer.toJson<String?>(id),
      'productVariantId': serializer.toJson<String?>(productVariantId),
      'quantity': serializer.toJson<String?>(quantity),
      'isDelivered': serializer.toJson<bool?>(isDelivered),
      'deliveryComment': serializer.toJson<String?>(deliveryComment),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  TaskResourceData copyWith(
          {String? clientReferenceId,
          Value<String?> taskclientReferenceId = const Value.absent(),
          Value<String?> taskId = const Value.absent(),
          Value<String?> id = const Value.absent(),
          Value<String?> productVariantId = const Value.absent(),
          Value<String?> quantity = const Value.absent(),
          Value<bool?> isDelivered = const Value.absent(),
          Value<String?> deliveryComment = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      TaskResourceData(
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        taskclientReferenceId: taskclientReferenceId.present
            ? taskclientReferenceId.value
            : this.taskclientReferenceId,
        taskId: taskId.present ? taskId.value : this.taskId,
        id: id.present ? id.value : this.id,
        productVariantId: productVariantId.present
            ? productVariantId.value
            : this.productVariantId,
        quantity: quantity.present ? quantity.value : this.quantity,
        isDelivered: isDelivered.present ? isDelivered.value : this.isDelivered,
        deliveryComment: deliveryComment.present
            ? deliveryComment.value
            : this.deliveryComment,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('TaskResourceData(')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('taskclientReferenceId: $taskclientReferenceId, ')
          ..write('taskId: $taskId, ')
          ..write('id: $id, ')
          ..write('productVariantId: $productVariantId, ')
          ..write('quantity: $quantity, ')
          ..write('isDelivered: $isDelivered, ')
          ..write('deliveryComment: $deliveryComment, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        clientReferenceId,
        taskclientReferenceId,
        taskId,
        id,
        productVariantId,
        quantity,
        isDelivered,
        deliveryComment,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TaskResourceData &&
          other.clientReferenceId == this.clientReferenceId &&
          other.taskclientReferenceId == this.taskclientReferenceId &&
          other.taskId == this.taskId &&
          other.id == this.id &&
          other.productVariantId == this.productVariantId &&
          other.quantity == this.quantity &&
          other.isDelivered == this.isDelivered &&
          other.deliveryComment == this.deliveryComment &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class TaskResourceCompanion extends UpdateCompanion<TaskResourceData> {
  final Value<String> clientReferenceId;
  final Value<String?> taskclientReferenceId;
  final Value<String?> taskId;
  final Value<String?> id;
  final Value<String?> productVariantId;
  final Value<String?> quantity;
  final Value<bool?> isDelivered;
  final Value<String?> deliveryComment;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const TaskResourceCompanion({
    this.clientReferenceId = const Value.absent(),
    this.taskclientReferenceId = const Value.absent(),
    this.taskId = const Value.absent(),
    this.id = const Value.absent(),
    this.productVariantId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.isDelivered = const Value.absent(),
    this.deliveryComment = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TaskResourceCompanion.insert({
    required String clientReferenceId,
    this.taskclientReferenceId = const Value.absent(),
    this.taskId = const Value.absent(),
    this.id = const Value.absent(),
    this.productVariantId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.isDelivered = const Value.absent(),
    this.deliveryComment = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<TaskResourceData> custom({
    Expression<String>? clientReferenceId,
    Expression<String>? taskclientReferenceId,
    Expression<String>? taskId,
    Expression<String>? id,
    Expression<String>? productVariantId,
    Expression<String>? quantity,
    Expression<bool>? isDelivered,
    Expression<String>? deliveryComment,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (taskclientReferenceId != null)
        'taskclient_reference_id': taskclientReferenceId,
      if (taskId != null) 'task_id': taskId,
      if (id != null) 'id': id,
      if (productVariantId != null) 'product_variant_id': productVariantId,
      if (quantity != null) 'quantity': quantity,
      if (isDelivered != null) 'is_delivered': isDelivered,
      if (deliveryComment != null) 'delivery_comment': deliveryComment,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TaskResourceCompanion copyWith(
      {Value<String>? clientReferenceId,
      Value<String?>? taskclientReferenceId,
      Value<String?>? taskId,
      Value<String?>? id,
      Value<String?>? productVariantId,
      Value<String?>? quantity,
      Value<bool?>? isDelivered,
      Value<String?>? deliveryComment,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return TaskResourceCompanion(
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      taskclientReferenceId:
          taskclientReferenceId ?? this.taskclientReferenceId,
      taskId: taskId ?? this.taskId,
      id: id ?? this.id,
      productVariantId: productVariantId ?? this.productVariantId,
      quantity: quantity ?? this.quantity,
      isDelivered: isDelivered ?? this.isDelivered,
      deliveryComment: deliveryComment ?? this.deliveryComment,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (taskclientReferenceId.present) {
      map['taskclient_reference_id'] =
          Variable<String>(taskclientReferenceId.value);
    }
    if (taskId.present) {
      map['task_id'] = Variable<String>(taskId.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (productVariantId.present) {
      map['product_variant_id'] = Variable<String>(productVariantId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<String>(quantity.value);
    }
    if (isDelivered.present) {
      map['is_delivered'] = Variable<bool>(isDelivered.value);
    }
    if (deliveryComment.present) {
      map['delivery_comment'] = Variable<String>(deliveryComment.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TaskResourceCompanion(')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('taskclientReferenceId: $taskclientReferenceId, ')
          ..write('taskId: $taskId, ')
          ..write('id: $id, ')
          ..write('productVariantId: $productVariantId, ')
          ..write('quantity: $quantity, ')
          ..write('isDelivered: $isDelivered, ')
          ..write('deliveryComment: $deliveryComment, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SideEffectTable extends SideEffect
    with TableInfo<$SideEffectTable, SideEffectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SideEffectTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _taskClientReferenceIdMeta =
      const VerificationMeta('taskClientReferenceId');
  @override
  late final GeneratedColumn<String> taskClientReferenceId =
      GeneratedColumn<String>('task_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectBeneficiaryClientReferenceIdMeta =
      const VerificationMeta('projectBeneficiaryClientReferenceId');
  @override
  late final GeneratedColumn<String> projectBeneficiaryClientReferenceId =
      GeneratedColumn<String>(
          'project_beneficiary_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _reAttemptsMeta =
      const VerificationMeta('reAttempts');
  @override
  late final GeneratedColumn<int> reAttempts = GeneratedColumn<int>(
      're_attempts', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _symptomsMeta =
      const VerificationMeta('symptoms');
  @override
  late final GeneratedColumn<String> symptoms = GeneratedColumn<String>(
      'symptoms', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        projectId,
        taskClientReferenceId,
        projectBeneficiaryClientReferenceId,
        reAttempts,
        symptoms,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'side_effect';
  @override
  VerificationContext validateIntegrity(Insertable<SideEffectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('task_client_reference_id')) {
      context.handle(
          _taskClientReferenceIdMeta,
          taskClientReferenceId.isAcceptableOrUnknown(
              data['task_client_reference_id']!, _taskClientReferenceIdMeta));
    }
    if (data.containsKey('project_beneficiary_client_reference_id')) {
      context.handle(
          _projectBeneficiaryClientReferenceIdMeta,
          projectBeneficiaryClientReferenceId.isAcceptableOrUnknown(
              data['project_beneficiary_client_reference_id']!,
              _projectBeneficiaryClientReferenceIdMeta));
    }
    if (data.containsKey('re_attempts')) {
      context.handle(
          _reAttemptsMeta,
          reAttempts.isAcceptableOrUnknown(
              data['re_attempts']!, _reAttemptsMeta));
    }
    if (data.containsKey('symptoms')) {
      context.handle(_symptomsMeta,
          symptoms.isAcceptableOrUnknown(data['symptoms']!, _symptomsMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  SideEffectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SideEffectData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      taskClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}task_client_reference_id']),
      projectBeneficiaryClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}project_beneficiary_client_reference_id']),
      reAttempts: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}re_attempts']),
      symptoms: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}symptoms']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $SideEffectTable createAlias(String alias) {
    return $SideEffectTable(attachedDatabase, alias);
  }
}

class SideEffectData extends DataClass implements Insertable<SideEffectData> {
  final String? id;
  final String? projectId;
  final String? taskClientReferenceId;
  final String? projectBeneficiaryClientReferenceId;
  final int? reAttempts;
  final String? symptoms;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const SideEffectData(
      {this.id,
      this.projectId,
      this.taskClientReferenceId,
      this.projectBeneficiaryClientReferenceId,
      this.reAttempts,
      this.symptoms,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || taskClientReferenceId != null) {
      map['task_client_reference_id'] = Variable<String>(taskClientReferenceId);
    }
    if (!nullToAbsent || projectBeneficiaryClientReferenceId != null) {
      map['project_beneficiary_client_reference_id'] =
          Variable<String>(projectBeneficiaryClientReferenceId);
    }
    if (!nullToAbsent || reAttempts != null) {
      map['re_attempts'] = Variable<int>(reAttempts);
    }
    if (!nullToAbsent || symptoms != null) {
      map['symptoms'] = Variable<String>(symptoms);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  SideEffectCompanion toCompanion(bool nullToAbsent) {
    return SideEffectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      taskClientReferenceId: taskClientReferenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(taskClientReferenceId),
      projectBeneficiaryClientReferenceId:
          projectBeneficiaryClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(projectBeneficiaryClientReferenceId),
      reAttempts: reAttempts == null && nullToAbsent
          ? const Value.absent()
          : Value(reAttempts),
      symptoms: symptoms == null && nullToAbsent
          ? const Value.absent()
          : Value(symptoms),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory SideEffectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SideEffectData(
      id: serializer.fromJson<String?>(json['id']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      taskClientReferenceId:
          serializer.fromJson<String?>(json['taskClientReferenceId']),
      projectBeneficiaryClientReferenceId: serializer
          .fromJson<String?>(json['projectBeneficiaryClientReferenceId']),
      reAttempts: serializer.fromJson<int?>(json['reAttempts']),
      symptoms: serializer.fromJson<String?>(json['symptoms']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'projectId': serializer.toJson<String?>(projectId),
      'taskClientReferenceId':
          serializer.toJson<String?>(taskClientReferenceId),
      'projectBeneficiaryClientReferenceId':
          serializer.toJson<String?>(projectBeneficiaryClientReferenceId),
      'reAttempts': serializer.toJson<int?>(reAttempts),
      'symptoms': serializer.toJson<String?>(symptoms),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  SideEffectData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> taskClientReferenceId = const Value.absent(),
          Value<String?> projectBeneficiaryClientReferenceId =
              const Value.absent(),
          Value<int?> reAttempts = const Value.absent(),
          Value<String?> symptoms = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      SideEffectData(
        id: id.present ? id.value : this.id,
        projectId: projectId.present ? projectId.value : this.projectId,
        taskClientReferenceId: taskClientReferenceId.present
            ? taskClientReferenceId.value
            : this.taskClientReferenceId,
        projectBeneficiaryClientReferenceId:
            projectBeneficiaryClientReferenceId.present
                ? projectBeneficiaryClientReferenceId.value
                : this.projectBeneficiaryClientReferenceId,
        reAttempts: reAttempts.present ? reAttempts.value : this.reAttempts,
        symptoms: symptoms.present ? symptoms.value : this.symptoms,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('SideEffectData(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('taskClientReferenceId: $taskClientReferenceId, ')
          ..write(
              'projectBeneficiaryClientReferenceId: $projectBeneficiaryClientReferenceId, ')
          ..write('reAttempts: $reAttempts, ')
          ..write('symptoms: $symptoms, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      projectId,
      taskClientReferenceId,
      projectBeneficiaryClientReferenceId,
      reAttempts,
      symptoms,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SideEffectData &&
          other.id == this.id &&
          other.projectId == this.projectId &&
          other.taskClientReferenceId == this.taskClientReferenceId &&
          other.projectBeneficiaryClientReferenceId ==
              this.projectBeneficiaryClientReferenceId &&
          other.reAttempts == this.reAttempts &&
          other.symptoms == this.symptoms &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class SideEffectCompanion extends UpdateCompanion<SideEffectData> {
  final Value<String?> id;
  final Value<String?> projectId;
  final Value<String?> taskClientReferenceId;
  final Value<String?> projectBeneficiaryClientReferenceId;
  final Value<int?> reAttempts;
  final Value<String?> symptoms;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const SideEffectCompanion({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.taskClientReferenceId = const Value.absent(),
    this.projectBeneficiaryClientReferenceId = const Value.absent(),
    this.reAttempts = const Value.absent(),
    this.symptoms = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SideEffectCompanion.insert({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.taskClientReferenceId = const Value.absent(),
    this.projectBeneficiaryClientReferenceId = const Value.absent(),
    this.reAttempts = const Value.absent(),
    this.symptoms = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<SideEffectData> custom({
    Expression<String>? id,
    Expression<String>? projectId,
    Expression<String>? taskClientReferenceId,
    Expression<String>? projectBeneficiaryClientReferenceId,
    Expression<int>? reAttempts,
    Expression<String>? symptoms,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (projectId != null) 'project_id': projectId,
      if (taskClientReferenceId != null)
        'task_client_reference_id': taskClientReferenceId,
      if (projectBeneficiaryClientReferenceId != null)
        'project_beneficiary_client_reference_id':
            projectBeneficiaryClientReferenceId,
      if (reAttempts != null) 're_attempts': reAttempts,
      if (symptoms != null) 'symptoms': symptoms,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SideEffectCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? projectId,
      Value<String?>? taskClientReferenceId,
      Value<String?>? projectBeneficiaryClientReferenceId,
      Value<int?>? reAttempts,
      Value<String?>? symptoms,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return SideEffectCompanion(
      id: id ?? this.id,
      projectId: projectId ?? this.projectId,
      taskClientReferenceId:
          taskClientReferenceId ?? this.taskClientReferenceId,
      projectBeneficiaryClientReferenceId:
          projectBeneficiaryClientReferenceId ??
              this.projectBeneficiaryClientReferenceId,
      reAttempts: reAttempts ?? this.reAttempts,
      symptoms: symptoms ?? this.symptoms,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (taskClientReferenceId.present) {
      map['task_client_reference_id'] =
          Variable<String>(taskClientReferenceId.value);
    }
    if (projectBeneficiaryClientReferenceId.present) {
      map['project_beneficiary_client_reference_id'] =
          Variable<String>(projectBeneficiaryClientReferenceId.value);
    }
    if (reAttempts.present) {
      map['re_attempts'] = Variable<int>(reAttempts.value);
    }
    if (symptoms.present) {
      map['symptoms'] = Variable<String>(symptoms.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SideEffectCompanion(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('taskClientReferenceId: $taskClientReferenceId, ')
          ..write(
              'projectBeneficiaryClientReferenceId: $projectBeneficiaryClientReferenceId, ')
          ..write('reAttempts: $reAttempts, ')
          ..write('symptoms: $symptoms, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ReferralTable extends Referral
    with TableInfo<$ReferralTable, ReferralData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ReferralTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectBeneficiaryClientReferenceIdMeta =
      const VerificationMeta('projectBeneficiaryClientReferenceId');
  @override
  late final GeneratedColumn<String> projectBeneficiaryClientReferenceId =
      GeneratedColumn<String>(
          'project_beneficiary_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referrerIdMeta =
      const VerificationMeta('referrerId');
  @override
  late final GeneratedColumn<String> referrerId = GeneratedColumn<String>(
      'referrer_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _recipientTypeMeta =
      const VerificationMeta('recipientType');
  @override
  late final GeneratedColumn<String> recipientType = GeneratedColumn<String>(
      'recipient_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _recipientIdMeta =
      const VerificationMeta('recipientId');
  @override
  late final GeneratedColumn<String> recipientId = GeneratedColumn<String>(
      'recipient_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _reasonsMeta =
      const VerificationMeta('reasons');
  @override
  late final GeneratedColumn<String> reasons = GeneratedColumn<String>(
      'reasons', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        projectId,
        projectBeneficiaryClientReferenceId,
        referrerId,
        recipientType,
        recipientId,
        reasons,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'referral';
  @override
  VerificationContext validateIntegrity(Insertable<ReferralData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('project_beneficiary_client_reference_id')) {
      context.handle(
          _projectBeneficiaryClientReferenceIdMeta,
          projectBeneficiaryClientReferenceId.isAcceptableOrUnknown(
              data['project_beneficiary_client_reference_id']!,
              _projectBeneficiaryClientReferenceIdMeta));
    }
    if (data.containsKey('referrer_id')) {
      context.handle(
          _referrerIdMeta,
          referrerId.isAcceptableOrUnknown(
              data['referrer_id']!, _referrerIdMeta));
    }
    if (data.containsKey('recipient_type')) {
      context.handle(
          _recipientTypeMeta,
          recipientType.isAcceptableOrUnknown(
              data['recipient_type']!, _recipientTypeMeta));
    }
    if (data.containsKey('recipient_id')) {
      context.handle(
          _recipientIdMeta,
          recipientId.isAcceptableOrUnknown(
              data['recipient_id']!, _recipientIdMeta));
    }
    if (data.containsKey('reasons')) {
      context.handle(_reasonsMeta,
          reasons.isAcceptableOrUnknown(data['reasons']!, _reasonsMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  ReferralData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ReferralData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      projectBeneficiaryClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}project_beneficiary_client_reference_id']),
      referrerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}referrer_id']),
      recipientType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}recipient_type']),
      recipientId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}recipient_id']),
      reasons: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reasons']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ReferralTable createAlias(String alias) {
    return $ReferralTable(attachedDatabase, alias);
  }
}

class ReferralData extends DataClass implements Insertable<ReferralData> {
  final String? id;
  final String? projectId;
  final String? projectBeneficiaryClientReferenceId;
  final String? referrerId;
  final String? recipientType;
  final String? recipientId;
  final String? reasons;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ReferralData(
      {this.id,
      this.projectId,
      this.projectBeneficiaryClientReferenceId,
      this.referrerId,
      this.recipientType,
      this.recipientId,
      this.reasons,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || projectBeneficiaryClientReferenceId != null) {
      map['project_beneficiary_client_reference_id'] =
          Variable<String>(projectBeneficiaryClientReferenceId);
    }
    if (!nullToAbsent || referrerId != null) {
      map['referrer_id'] = Variable<String>(referrerId);
    }
    if (!nullToAbsent || recipientType != null) {
      map['recipient_type'] = Variable<String>(recipientType);
    }
    if (!nullToAbsent || recipientId != null) {
      map['recipient_id'] = Variable<String>(recipientId);
    }
    if (!nullToAbsent || reasons != null) {
      map['reasons'] = Variable<String>(reasons);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ReferralCompanion toCompanion(bool nullToAbsent) {
    return ReferralCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      projectBeneficiaryClientReferenceId:
          projectBeneficiaryClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(projectBeneficiaryClientReferenceId),
      referrerId: referrerId == null && nullToAbsent
          ? const Value.absent()
          : Value(referrerId),
      recipientType: recipientType == null && nullToAbsent
          ? const Value.absent()
          : Value(recipientType),
      recipientId: recipientId == null && nullToAbsent
          ? const Value.absent()
          : Value(recipientId),
      reasons: reasons == null && nullToAbsent
          ? const Value.absent()
          : Value(reasons),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ReferralData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ReferralData(
      id: serializer.fromJson<String?>(json['id']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      projectBeneficiaryClientReferenceId: serializer
          .fromJson<String?>(json['projectBeneficiaryClientReferenceId']),
      referrerId: serializer.fromJson<String?>(json['referrerId']),
      recipientType: serializer.fromJson<String?>(json['recipientType']),
      recipientId: serializer.fromJson<String?>(json['recipientId']),
      reasons: serializer.fromJson<String?>(json['reasons']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'projectId': serializer.toJson<String?>(projectId),
      'projectBeneficiaryClientReferenceId':
          serializer.toJson<String?>(projectBeneficiaryClientReferenceId),
      'referrerId': serializer.toJson<String?>(referrerId),
      'recipientType': serializer.toJson<String?>(recipientType),
      'recipientId': serializer.toJson<String?>(recipientId),
      'reasons': serializer.toJson<String?>(reasons),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ReferralData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> projectBeneficiaryClientReferenceId =
              const Value.absent(),
          Value<String?> referrerId = const Value.absent(),
          Value<String?> recipientType = const Value.absent(),
          Value<String?> recipientId = const Value.absent(),
          Value<String?> reasons = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ReferralData(
        id: id.present ? id.value : this.id,
        projectId: projectId.present ? projectId.value : this.projectId,
        projectBeneficiaryClientReferenceId:
            projectBeneficiaryClientReferenceId.present
                ? projectBeneficiaryClientReferenceId.value
                : this.projectBeneficiaryClientReferenceId,
        referrerId: referrerId.present ? referrerId.value : this.referrerId,
        recipientType:
            recipientType.present ? recipientType.value : this.recipientType,
        recipientId: recipientId.present ? recipientId.value : this.recipientId,
        reasons: reasons.present ? reasons.value : this.reasons,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ReferralData(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write(
              'projectBeneficiaryClientReferenceId: $projectBeneficiaryClientReferenceId, ')
          ..write('referrerId: $referrerId, ')
          ..write('recipientType: $recipientType, ')
          ..write('recipientId: $recipientId, ')
          ..write('reasons: $reasons, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        projectId,
        projectBeneficiaryClientReferenceId,
        referrerId,
        recipientType,
        recipientId,
        reasons,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ReferralData &&
          other.id == this.id &&
          other.projectId == this.projectId &&
          other.projectBeneficiaryClientReferenceId ==
              this.projectBeneficiaryClientReferenceId &&
          other.referrerId == this.referrerId &&
          other.recipientType == this.recipientType &&
          other.recipientId == this.recipientId &&
          other.reasons == this.reasons &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ReferralCompanion extends UpdateCompanion<ReferralData> {
  final Value<String?> id;
  final Value<String?> projectId;
  final Value<String?> projectBeneficiaryClientReferenceId;
  final Value<String?> referrerId;
  final Value<String?> recipientType;
  final Value<String?> recipientId;
  final Value<String?> reasons;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ReferralCompanion({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.projectBeneficiaryClientReferenceId = const Value.absent(),
    this.referrerId = const Value.absent(),
    this.recipientType = const Value.absent(),
    this.recipientId = const Value.absent(),
    this.reasons = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ReferralCompanion.insert({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.projectBeneficiaryClientReferenceId = const Value.absent(),
    this.referrerId = const Value.absent(),
    this.recipientType = const Value.absent(),
    this.recipientId = const Value.absent(),
    this.reasons = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<ReferralData> custom({
    Expression<String>? id,
    Expression<String>? projectId,
    Expression<String>? projectBeneficiaryClientReferenceId,
    Expression<String>? referrerId,
    Expression<String>? recipientType,
    Expression<String>? recipientId,
    Expression<String>? reasons,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (projectId != null) 'project_id': projectId,
      if (projectBeneficiaryClientReferenceId != null)
        'project_beneficiary_client_reference_id':
            projectBeneficiaryClientReferenceId,
      if (referrerId != null) 'referrer_id': referrerId,
      if (recipientType != null) 'recipient_type': recipientType,
      if (recipientId != null) 'recipient_id': recipientId,
      if (reasons != null) 'reasons': reasons,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ReferralCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? projectId,
      Value<String?>? projectBeneficiaryClientReferenceId,
      Value<String?>? referrerId,
      Value<String?>? recipientType,
      Value<String?>? recipientId,
      Value<String?>? reasons,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ReferralCompanion(
      id: id ?? this.id,
      projectId: projectId ?? this.projectId,
      projectBeneficiaryClientReferenceId:
          projectBeneficiaryClientReferenceId ??
              this.projectBeneficiaryClientReferenceId,
      referrerId: referrerId ?? this.referrerId,
      recipientType: recipientType ?? this.recipientType,
      recipientId: recipientId ?? this.recipientId,
      reasons: reasons ?? this.reasons,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (projectBeneficiaryClientReferenceId.present) {
      map['project_beneficiary_client_reference_id'] =
          Variable<String>(projectBeneficiaryClientReferenceId.value);
    }
    if (referrerId.present) {
      map['referrer_id'] = Variable<String>(referrerId.value);
    }
    if (recipientType.present) {
      map['recipient_type'] = Variable<String>(recipientType.value);
    }
    if (recipientId.present) {
      map['recipient_id'] = Variable<String>(recipientId.value);
    }
    if (reasons.present) {
      map['reasons'] = Variable<String>(reasons.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ReferralCompanion(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write(
              'projectBeneficiaryClientReferenceId: $projectBeneficiaryClientReferenceId, ')
          ..write('referrerId: $referrerId, ')
          ..write('recipientType: $recipientType, ')
          ..write('recipientId: $recipientId, ')
          ..write('reasons: $reasons, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LocalizationTable extends Localization
    with TableInfo<$LocalizationTable, LocalizationData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LocalizationTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _localeMeta = const VerificationMeta('locale');
  @override
  late final GeneratedColumn<String> locale = GeneratedColumn<String>(
      'locale', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 255),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 255),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _messageMeta =
      const VerificationMeta('message');
  @override
  late final GeneratedColumn<String> message = GeneratedColumn<String>(
      'message', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 500),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _moduleMeta = const VerificationMeta('module');
  @override
  late final GeneratedColumn<String> module = GeneratedColumn<String>(
      'module', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 255),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [locale, code, message, module];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'localization';
  @override
  VerificationContext validateIntegrity(Insertable<LocalizationData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('locale')) {
      context.handle(_localeMeta,
          locale.isAcceptableOrUnknown(data['locale']!, _localeMeta));
    } else if (isInserting) {
      context.missing(_localeMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('message')) {
      context.handle(_messageMeta,
          message.isAcceptableOrUnknown(data['message']!, _messageMeta));
    } else if (isInserting) {
      context.missing(_messageMeta);
    }
    if (data.containsKey('module')) {
      context.handle(_moduleMeta,
          module.isAcceptableOrUnknown(data['module']!, _moduleMeta));
    } else if (isInserting) {
      context.missing(_moduleMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => const {};
  @override
  LocalizationData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LocalizationData(
      locale: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}locale'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      message: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}message'])!,
      module: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}module'])!,
    );
  }

  @override
  $LocalizationTable createAlias(String alias) {
    return $LocalizationTable(attachedDatabase, alias);
  }
}

class LocalizationData extends DataClass
    implements Insertable<LocalizationData> {
  final String locale;
  final String code;
  final String message;
  final String module;
  const LocalizationData(
      {required this.locale,
      required this.code,
      required this.message,
      required this.module});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['locale'] = Variable<String>(locale);
    map['code'] = Variable<String>(code);
    map['message'] = Variable<String>(message);
    map['module'] = Variable<String>(module);
    return map;
  }

  LocalizationCompanion toCompanion(bool nullToAbsent) {
    return LocalizationCompanion(
      locale: Value(locale),
      code: Value(code),
      message: Value(message),
      module: Value(module),
    );
  }

  factory LocalizationData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LocalizationData(
      locale: serializer.fromJson<String>(json['locale']),
      code: serializer.fromJson<String>(json['code']),
      message: serializer.fromJson<String>(json['message']),
      module: serializer.fromJson<String>(json['module']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'locale': serializer.toJson<String>(locale),
      'code': serializer.toJson<String>(code),
      'message': serializer.toJson<String>(message),
      'module': serializer.toJson<String>(module),
    };
  }

  LocalizationData copyWith(
          {String? locale, String? code, String? message, String? module}) =>
      LocalizationData(
        locale: locale ?? this.locale,
        code: code ?? this.code,
        message: message ?? this.message,
        module: module ?? this.module,
      );
  @override
  String toString() {
    return (StringBuffer('LocalizationData(')
          ..write('locale: $locale, ')
          ..write('code: $code, ')
          ..write('message: $message, ')
          ..write('module: $module')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(locale, code, message, module);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LocalizationData &&
          other.locale == this.locale &&
          other.code == this.code &&
          other.message == this.message &&
          other.module == this.module);
}

class LocalizationCompanion extends UpdateCompanion<LocalizationData> {
  final Value<String> locale;
  final Value<String> code;
  final Value<String> message;
  final Value<String> module;
  final Value<int> rowid;
  const LocalizationCompanion({
    this.locale = const Value.absent(),
    this.code = const Value.absent(),
    this.message = const Value.absent(),
    this.module = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  LocalizationCompanion.insert({
    required String locale,
    required String code,
    required String message,
    required String module,
    this.rowid = const Value.absent(),
  })  : locale = Value(locale),
        code = Value(code),
        message = Value(message),
        module = Value(module);
  static Insertable<LocalizationData> custom({
    Expression<String>? locale,
    Expression<String>? code,
    Expression<String>? message,
    Expression<String>? module,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (locale != null) 'locale': locale,
      if (code != null) 'code': code,
      if (message != null) 'message': message,
      if (module != null) 'module': module,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LocalizationCompanion copyWith(
      {Value<String>? locale,
      Value<String>? code,
      Value<String>? message,
      Value<String>? module,
      Value<int>? rowid}) {
    return LocalizationCompanion(
      locale: locale ?? this.locale,
      code: code ?? this.code,
      message: message ?? this.message,
      module: module ?? this.module,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (locale.present) {
      map['locale'] = Variable<String>(locale.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (message.present) {
      map['message'] = Variable<String>(message.value);
    }
    if (module.present) {
      map['module'] = Variable<String>(module.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LocalizationCompanion(')
          ..write('locale: $locale, ')
          ..write('code: $code, ')
          ..write('message: $message, ')
          ..write('module: $module, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserActionTable extends UserAction
    with TableInfo<$UserActionTable, UserActionData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserActionTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<String> latitude = GeneratedColumn<String>(
      'latitude', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<String> longitude = GeneratedColumn<String>(
      'longitude', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _locationAccuracyMeta =
      const VerificationMeta('locationAccuracy');
  @override
  late final GeneratedColumn<String> locationAccuracy = GeneratedColumn<String>(
      'location_accuracy', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isSyncMeta = const VerificationMeta('isSync');
  @override
  late final GeneratedColumn<bool> isSync = GeneratedColumn<bool>(
      'is_sync', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_sync" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<int> timestamp = GeneratedColumn<int>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _boundaryCodeMeta =
      const VerificationMeta('boundaryCode');
  @override
  late final GeneratedColumn<String> boundaryCode = GeneratedColumn<String>(
      'boundary_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
      'action', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _beneficiaryTagMeta =
      const VerificationMeta('beneficiaryTag');
  @override
  late final GeneratedColumn<String> beneficiaryTag = GeneratedColumn<String>(
      'beneficiary_tag', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _resourceTagMeta =
      const VerificationMeta('resourceTag');
  @override
  late final GeneratedColumn<String> resourceTag = GeneratedColumn<String>(
      'resource_tag', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        latitude,
        longitude,
        locationAccuracy,
        clientReferenceId,
        isSync,
        timestamp,
        nonRecoverableError,
        tenantId,
        rowVersion,
        projectId,
        boundaryCode,
        action,
        beneficiaryTag,
        resourceTag,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        auditCreatedBy,
        isDeleted,
        id,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_action';
  @override
  VerificationContext validateIntegrity(Insertable<UserActionData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    } else if (isInserting) {
      context.missing(_latitudeMeta);
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    } else if (isInserting) {
      context.missing(_longitudeMeta);
    }
    if (data.containsKey('location_accuracy')) {
      context.handle(
          _locationAccuracyMeta,
          locationAccuracy.isAcceptableOrUnknown(
              data['location_accuracy']!, _locationAccuracyMeta));
    } else if (isInserting) {
      context.missing(_locationAccuracyMeta);
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('is_sync')) {
      context.handle(_isSyncMeta,
          isSync.isAcceptableOrUnknown(data['is_sync']!, _isSyncMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    } else if (isInserting) {
      context.missing(_projectIdMeta);
    }
    if (data.containsKey('boundary_code')) {
      context.handle(
          _boundaryCodeMeta,
          boundaryCode.isAcceptableOrUnknown(
              data['boundary_code']!, _boundaryCodeMeta));
    } else if (isInserting) {
      context.missing(_boundaryCodeMeta);
    }
    if (data.containsKey('action')) {
      context.handle(_actionMeta,
          action.isAcceptableOrUnknown(data['action']!, _actionMeta));
    } else if (isInserting) {
      context.missing(_actionMeta);
    }
    if (data.containsKey('beneficiary_tag')) {
      context.handle(
          _beneficiaryTagMeta,
          beneficiaryTag.isAcceptableOrUnknown(
              data['beneficiary_tag']!, _beneficiaryTagMeta));
    }
    if (data.containsKey('resource_tag')) {
      context.handle(
          _resourceTagMeta,
          resourceTag.isAcceptableOrUnknown(
              data['resource_tag']!, _resourceTagMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {clientReferenceId};
  @override
  UserActionData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserActionData(
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}latitude'])!,
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}longitude'])!,
      locationAccuracy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}location_accuracy'])!,
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      isSync: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_sync'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}timestamp'])!,
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id'])!,
      boundaryCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}boundary_code'])!,
      action: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action'])!,
      beneficiaryTag: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}beneficiary_tag']),
      resourceTag: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}resource_tag']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $UserActionTable createAlias(String alias) {
    return $UserActionTable(attachedDatabase, alias);
  }
}

class UserActionData extends DataClass implements Insertable<UserActionData> {
  final String latitude;
  final String longitude;
  final String locationAccuracy;
  final String clientReferenceId;
  final bool isSync;
  final int timestamp;
  final bool? nonRecoverableError;
  final String? tenantId;
  final int? rowVersion;
  final String projectId;
  final String boundaryCode;
  final String action;
  final String? beneficiaryTag;
  final String? resourceTag;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? auditCreatedBy;
  final bool? isDeleted;
  final String? id;
  final String? additionalFields;
  const UserActionData(
      {required this.latitude,
      required this.longitude,
      required this.locationAccuracy,
      required this.clientReferenceId,
      required this.isSync,
      required this.timestamp,
      this.nonRecoverableError,
      this.tenantId,
      this.rowVersion,
      required this.projectId,
      required this.boundaryCode,
      required this.action,
      this.beneficiaryTag,
      this.resourceTag,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.auditCreatedBy,
      this.isDeleted,
      this.id,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['latitude'] = Variable<String>(latitude);
    map['longitude'] = Variable<String>(longitude);
    map['location_accuracy'] = Variable<String>(locationAccuracy);
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    map['is_sync'] = Variable<bool>(isSync);
    map['timestamp'] = Variable<int>(timestamp);
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    map['project_id'] = Variable<String>(projectId);
    map['boundary_code'] = Variable<String>(boundaryCode);
    map['action'] = Variable<String>(action);
    if (!nullToAbsent || beneficiaryTag != null) {
      map['beneficiary_tag'] = Variable<String>(beneficiaryTag);
    }
    if (!nullToAbsent || resourceTag != null) {
      map['resource_tag'] = Variable<String>(resourceTag);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  UserActionCompanion toCompanion(bool nullToAbsent) {
    return UserActionCompanion(
      latitude: Value(latitude),
      longitude: Value(longitude),
      locationAccuracy: Value(locationAccuracy),
      clientReferenceId: Value(clientReferenceId),
      isSync: Value(isSync),
      timestamp: Value(timestamp),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      projectId: Value(projectId),
      boundaryCode: Value(boundaryCode),
      action: Value(action),
      beneficiaryTag: beneficiaryTag == null && nullToAbsent
          ? const Value.absent()
          : Value(beneficiaryTag),
      resourceTag: resourceTag == null && nullToAbsent
          ? const Value.absent()
          : Value(resourceTag),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory UserActionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserActionData(
      latitude: serializer.fromJson<String>(json['latitude']),
      longitude: serializer.fromJson<String>(json['longitude']),
      locationAccuracy: serializer.fromJson<String>(json['locationAccuracy']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      isSync: serializer.fromJson<bool>(json['isSync']),
      timestamp: serializer.fromJson<int>(json['timestamp']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      projectId: serializer.fromJson<String>(json['projectId']),
      boundaryCode: serializer.fromJson<String>(json['boundaryCode']),
      action: serializer.fromJson<String>(json['action']),
      beneficiaryTag: serializer.fromJson<String?>(json['beneficiaryTag']),
      resourceTag: serializer.fromJson<String?>(json['resourceTag']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      id: serializer.fromJson<String?>(json['id']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'latitude': serializer.toJson<String>(latitude),
      'longitude': serializer.toJson<String>(longitude),
      'locationAccuracy': serializer.toJson<String>(locationAccuracy),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'isSync': serializer.toJson<bool>(isSync),
      'timestamp': serializer.toJson<int>(timestamp),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'tenantId': serializer.toJson<String?>(tenantId),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'projectId': serializer.toJson<String>(projectId),
      'boundaryCode': serializer.toJson<String>(boundaryCode),
      'action': serializer.toJson<String>(action),
      'beneficiaryTag': serializer.toJson<String?>(beneficiaryTag),
      'resourceTag': serializer.toJson<String?>(resourceTag),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'id': serializer.toJson<String?>(id),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  UserActionData copyWith(
          {String? latitude,
          String? longitude,
          String? locationAccuracy,
          String? clientReferenceId,
          bool? isSync,
          int? timestamp,
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          String? projectId,
          String? boundaryCode,
          String? action,
          Value<String?> beneficiaryTag = const Value.absent(),
          Value<String?> resourceTag = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<String?> id = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      UserActionData(
        latitude: latitude ?? this.latitude,
        longitude: longitude ?? this.longitude,
        locationAccuracy: locationAccuracy ?? this.locationAccuracy,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        isSync: isSync ?? this.isSync,
        timestamp: timestamp ?? this.timestamp,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        projectId: projectId ?? this.projectId,
        boundaryCode: boundaryCode ?? this.boundaryCode,
        action: action ?? this.action,
        beneficiaryTag:
            beneficiaryTag.present ? beneficiaryTag.value : this.beneficiaryTag,
        resourceTag: resourceTag.present ? resourceTag.value : this.resourceTag,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        id: id.present ? id.value : this.id,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('UserActionData(')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('locationAccuracy: $locationAccuracy, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isSync: $isSync, ')
          ..write('timestamp: $timestamp, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('tenantId: $tenantId, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('projectId: $projectId, ')
          ..write('boundaryCode: $boundaryCode, ')
          ..write('action: $action, ')
          ..write('beneficiaryTag: $beneficiaryTag, ')
          ..write('resourceTag: $resourceTag, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('id: $id, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        latitude,
        longitude,
        locationAccuracy,
        clientReferenceId,
        isSync,
        timestamp,
        nonRecoverableError,
        tenantId,
        rowVersion,
        projectId,
        boundaryCode,
        action,
        beneficiaryTag,
        resourceTag,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        auditCreatedBy,
        isDeleted,
        id,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserActionData &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.locationAccuracy == this.locationAccuracy &&
          other.clientReferenceId == this.clientReferenceId &&
          other.isSync == this.isSync &&
          other.timestamp == this.timestamp &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.tenantId == this.tenantId &&
          other.rowVersion == this.rowVersion &&
          other.projectId == this.projectId &&
          other.boundaryCode == this.boundaryCode &&
          other.action == this.action &&
          other.beneficiaryTag == this.beneficiaryTag &&
          other.resourceTag == this.resourceTag &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.isDeleted == this.isDeleted &&
          other.id == this.id &&
          other.additionalFields == this.additionalFields);
}

class UserActionCompanion extends UpdateCompanion<UserActionData> {
  final Value<String> latitude;
  final Value<String> longitude;
  final Value<String> locationAccuracy;
  final Value<String> clientReferenceId;
  final Value<bool> isSync;
  final Value<int> timestamp;
  final Value<bool?> nonRecoverableError;
  final Value<String?> tenantId;
  final Value<int?> rowVersion;
  final Value<String> projectId;
  final Value<String> boundaryCode;
  final Value<String> action;
  final Value<String?> beneficiaryTag;
  final Value<String?> resourceTag;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> auditCreatedBy;
  final Value<bool?> isDeleted;
  final Value<String?> id;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const UserActionCompanion({
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.locationAccuracy = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.isSync = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.projectId = const Value.absent(),
    this.boundaryCode = const Value.absent(),
    this.action = const Value.absent(),
    this.beneficiaryTag = const Value.absent(),
    this.resourceTag = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.id = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserActionCompanion.insert({
    required String latitude,
    required String longitude,
    required String locationAccuracy,
    required String clientReferenceId,
    this.isSync = const Value.absent(),
    required int timestamp,
    this.nonRecoverableError = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.rowVersion = const Value.absent(),
    required String projectId,
    required String boundaryCode,
    required String action,
    this.beneficiaryTag = const Value.absent(),
    this.resourceTag = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.id = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : latitude = Value(latitude),
        longitude = Value(longitude),
        locationAccuracy = Value(locationAccuracy),
        clientReferenceId = Value(clientReferenceId),
        timestamp = Value(timestamp),
        projectId = Value(projectId),
        boundaryCode = Value(boundaryCode),
        action = Value(action);
  static Insertable<UserActionData> custom({
    Expression<String>? latitude,
    Expression<String>? longitude,
    Expression<String>? locationAccuracy,
    Expression<String>? clientReferenceId,
    Expression<bool>? isSync,
    Expression<int>? timestamp,
    Expression<bool>? nonRecoverableError,
    Expression<String>? tenantId,
    Expression<int>? rowVersion,
    Expression<String>? projectId,
    Expression<String>? boundaryCode,
    Expression<String>? action,
    Expression<String>? beneficiaryTag,
    Expression<String>? resourceTag,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? auditCreatedBy,
    Expression<bool>? isDeleted,
    Expression<String>? id,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (locationAccuracy != null) 'location_accuracy': locationAccuracy,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (isSync != null) 'is_sync': isSync,
      if (timestamp != null) 'timestamp': timestamp,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (tenantId != null) 'tenant_id': tenantId,
      if (rowVersion != null) 'row_version': rowVersion,
      if (projectId != null) 'project_id': projectId,
      if (boundaryCode != null) 'boundary_code': boundaryCode,
      if (action != null) 'action': action,
      if (beneficiaryTag != null) 'beneficiary_tag': beneficiaryTag,
      if (resourceTag != null) 'resource_tag': resourceTag,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (id != null) 'id': id,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserActionCompanion copyWith(
      {Value<String>? latitude,
      Value<String>? longitude,
      Value<String>? locationAccuracy,
      Value<String>? clientReferenceId,
      Value<bool>? isSync,
      Value<int>? timestamp,
      Value<bool?>? nonRecoverableError,
      Value<String?>? tenantId,
      Value<int?>? rowVersion,
      Value<String>? projectId,
      Value<String>? boundaryCode,
      Value<String>? action,
      Value<String?>? beneficiaryTag,
      Value<String?>? resourceTag,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? auditCreatedBy,
      Value<bool?>? isDeleted,
      Value<String?>? id,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return UserActionCompanion(
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      locationAccuracy: locationAccuracy ?? this.locationAccuracy,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      isSync: isSync ?? this.isSync,
      timestamp: timestamp ?? this.timestamp,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      tenantId: tenantId ?? this.tenantId,
      rowVersion: rowVersion ?? this.rowVersion,
      projectId: projectId ?? this.projectId,
      boundaryCode: boundaryCode ?? this.boundaryCode,
      action: action ?? this.action,
      beneficiaryTag: beneficiaryTag ?? this.beneficiaryTag,
      resourceTag: resourceTag ?? this.resourceTag,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      isDeleted: isDeleted ?? this.isDeleted,
      id: id ?? this.id,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (latitude.present) {
      map['latitude'] = Variable<String>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<String>(longitude.value);
    }
    if (locationAccuracy.present) {
      map['location_accuracy'] = Variable<String>(locationAccuracy.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (isSync.present) {
      map['is_sync'] = Variable<bool>(isSync.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<int>(timestamp.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (boundaryCode.present) {
      map['boundary_code'] = Variable<String>(boundaryCode.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (beneficiaryTag.present) {
      map['beneficiary_tag'] = Variable<String>(beneficiaryTag.value);
    }
    if (resourceTag.present) {
      map['resource_tag'] = Variable<String>(resourceTag.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserActionCompanion(')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('locationAccuracy: $locationAccuracy, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isSync: $isSync, ')
          ..write('timestamp: $timestamp, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('tenantId: $tenantId, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('projectId: $projectId, ')
          ..write('boundaryCode: $boundaryCode, ')
          ..write('action: $action, ')
          ..write('beneficiaryTag: $beneficiaryTag, ')
          ..write('resourceTag: $resourceTag, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('id: $id, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UniqueIdPoolTable extends UniqueIdPool
    with TableInfo<$UniqueIdPoolTable, UniqueIdPoolData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UniqueIdPoolTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _deviceUuidMeta =
      const VerificationMeta('deviceUuid');
  @override
  late final GeneratedColumn<String> deviceUuid = GeneratedColumn<String>(
      'device_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userUuidMeta =
      const VerificationMeta('userUuid');
  @override
  late final GeneratedColumn<String> userUuid = GeneratedColumn<String>(
      'user_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        deviceUuid,
        userUuid,
        status,
        auditCreatedTime,
        auditModifiedBy,
        auditCreatedBy,
        auditModifiedTime,
        tenantId,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'unique_id_pool';
  @override
  VerificationContext validateIntegrity(Insertable<UniqueIdPoolData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('device_uuid')) {
      context.handle(
          _deviceUuidMeta,
          deviceUuid.isAcceptableOrUnknown(
              data['device_uuid']!, _deviceUuidMeta));
    }
    if (data.containsKey('user_uuid')) {
      context.handle(_userUuidMeta,
          userUuid.isAcceptableOrUnknown(data['user_uuid']!, _userUuidMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UniqueIdPoolData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UniqueIdPoolData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      deviceUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_uuid']),
      userUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_uuid']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $UniqueIdPoolTable createAlias(String alias) {
    return $UniqueIdPoolTable(attachedDatabase, alias);
  }
}

class UniqueIdPoolData extends DataClass
    implements Insertable<UniqueIdPoolData> {
  final String id;
  final String? deviceUuid;
  final String? userUuid;
  final String? status;
  final int? auditCreatedTime;
  final String? auditModifiedBy;
  final String? auditCreatedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final int? rowVersion;
  final String? additionalFields;
  const UniqueIdPoolData(
      {required this.id,
      this.deviceUuid,
      this.userUuid,
      this.status,
      this.auditCreatedTime,
      this.auditModifiedBy,
      this.auditCreatedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || deviceUuid != null) {
      map['device_uuid'] = Variable<String>(deviceUuid);
    }
    if (!nullToAbsent || userUuid != null) {
      map['user_uuid'] = Variable<String>(userUuid);
    }
    if (!nullToAbsent || status != null) {
      map['status'] = Variable<String>(status);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  UniqueIdPoolCompanion toCompanion(bool nullToAbsent) {
    return UniqueIdPoolCompanion(
      id: Value(id),
      deviceUuid: deviceUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceUuid),
      userUuid: userUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(userUuid),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory UniqueIdPoolData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UniqueIdPoolData(
      id: serializer.fromJson<String>(json['id']),
      deviceUuid: serializer.fromJson<String?>(json['deviceUuid']),
      userUuid: serializer.fromJson<String?>(json['userUuid']),
      status: serializer.fromJson<String?>(json['status']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'deviceUuid': serializer.toJson<String?>(deviceUuid),
      'userUuid': serializer.toJson<String?>(userUuid),
      'status': serializer.toJson<String?>(status),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  UniqueIdPoolData copyWith(
          {String? id,
          Value<String?> deviceUuid = const Value.absent(),
          Value<String?> userUuid = const Value.absent(),
          Value<String?> status = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      UniqueIdPoolData(
        id: id ?? this.id,
        deviceUuid: deviceUuid.present ? deviceUuid.value : this.deviceUuid,
        userUuid: userUuid.present ? userUuid.value : this.userUuid,
        status: status.present ? status.value : this.status,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('UniqueIdPoolData(')
          ..write('id: $id, ')
          ..write('deviceUuid: $deviceUuid, ')
          ..write('userUuid: $userUuid, ')
          ..write('status: $status, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      deviceUuid,
      userUuid,
      status,
      auditCreatedTime,
      auditModifiedBy,
      auditCreatedBy,
      auditModifiedTime,
      tenantId,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UniqueIdPoolData &&
          other.id == this.id &&
          other.deviceUuid == this.deviceUuid &&
          other.userUuid == this.userUuid &&
          other.status == this.status &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class UniqueIdPoolCompanion extends UpdateCompanion<UniqueIdPoolData> {
  final Value<String> id;
  final Value<String?> deviceUuid;
  final Value<String?> userUuid;
  final Value<String?> status;
  final Value<int?> auditCreatedTime;
  final Value<String?> auditModifiedBy;
  final Value<String?> auditCreatedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const UniqueIdPoolCompanion({
    this.id = const Value.absent(),
    this.deviceUuid = const Value.absent(),
    this.userUuid = const Value.absent(),
    this.status = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UniqueIdPoolCompanion.insert({
    required String id,
    this.deviceUuid = const Value.absent(),
    this.userUuid = const Value.absent(),
    this.status = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<UniqueIdPoolData> custom({
    Expression<String>? id,
    Expression<String>? deviceUuid,
    Expression<String>? userUuid,
    Expression<String>? status,
    Expression<int>? auditCreatedTime,
    Expression<String>? auditModifiedBy,
    Expression<String>? auditCreatedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (deviceUuid != null) 'device_uuid': deviceUuid,
      if (userUuid != null) 'user_uuid': userUuid,
      if (status != null) 'status': status,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UniqueIdPoolCompanion copyWith(
      {Value<String>? id,
      Value<String?>? deviceUuid,
      Value<String?>? userUuid,
      Value<String?>? status,
      Value<int?>? auditCreatedTime,
      Value<String?>? auditModifiedBy,
      Value<String?>? auditCreatedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return UniqueIdPoolCompanion(
      id: id ?? this.id,
      deviceUuid: deviceUuid ?? this.deviceUuid,
      userUuid: userUuid ?? this.userUuid,
      status: status ?? this.status,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (deviceUuid.present) {
      map['device_uuid'] = Variable<String>(deviceUuid.value);
    }
    if (userUuid.present) {
      map['user_uuid'] = Variable<String>(userUuid.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UniqueIdPoolCompanion(')
          ..write('id: $id, ')
          ..write('deviceUuid: $deviceUuid, ')
          ..write('userUuid: $userUuid, ')
          ..write('status: $status, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$LocalSqlDataStore extends GeneratedDatabase {
  _$LocalSqlDataStore(QueryExecutor e) : super(e);
  _$LocalSqlDataStoreManager get managers => _$LocalSqlDataStoreManager(this);
  late final $AttendanceRegisterTable attendanceRegister =
      $AttendanceRegisterTable(this);
  late final $AttendanceTable attendance = $AttendanceTable(this);
  late final $AttendeeTable attendee = $AttendeeTable(this);
  late final $AddressTable address = $AddressTable(this);
  late final $NameTable name = $NameTable(this);
  late final $BoundaryTable boundary = $BoundaryTable(this);
  late final $DocumentTable document = $DocumentTable(this);
  late final $FacilityTable facility = $FacilityTable(this);
  late final $ProductTable product = $ProductTable(this);
  late final $ProductVariantTable productVariant = $ProductVariantTable(this);
  late final $ProjectTable project = $ProjectTable(this);
  late final $ProjectBeneficiaryTable projectBeneficiary =
      $ProjectBeneficiaryTable(this);
  late final $ProjectFacilityTable projectFacility =
      $ProjectFacilityTable(this);
  late final $ProjectProductVariantTable projectProductVariant =
      $ProjectProductVariantTable(this);
  late final $ProjectResourceTable projectResource =
      $ProjectResourceTable(this);
  late final $ProjectStaffTable projectStaff = $ProjectStaffTable(this);
  late final $ProjectTypeTable projectType = $ProjectTypeTable(this);
  late final $IndividualTable individual = $IndividualTable(this);
  late final $IdentifierTable identifier = $IdentifierTable(this);
  late final $StockTable stock = $StockTable(this);
  late final $StockReconciliationTable stockReconciliation =
      $StockReconciliationTable(this);
  late final $TargetTable target = $TargetTable(this);
  late final $ServiceTable service = $ServiceTable(this);
  late final $ServiceAttributesTable serviceAttributes =
      $ServiceAttributesTable(this);
  late final $ServiceDefinitionTable serviceDefinition =
      $ServiceDefinitionTable(this);
  late final $LocalityTable locality = $LocalityTable(this);
  late final $StaffTable staff = $StaffTable(this);
  late final $AttributesTable attributes = $AttributesTable(this);
  late final $PgrServiceTable pgrService = $PgrServiceTable(this);
  late final $PgrComplainantTable pgrComplainant = $PgrComplainantTable(this);
  late final $UserTable user = $UserTable(this);
  late final $DownsyncTable downsync = $DownsyncTable(this);
  late final $DownsyncCriteriaTable downsyncCriteria =
      $DownsyncCriteriaTable(this);
  late final $HFReferralTable hFReferral = $HFReferralTable(this);
  late final $HouseholdTable household = $HouseholdTable(this);
  late final $HouseholdMemberTable householdMember =
      $HouseholdMemberTable(this);
  late final $HouseholdMemberRelationShipTable householdMemberRelationShip =
      $HouseholdMemberRelationShipTable(this);
  late final $TaskTable task = $TaskTable(this);
  late final $TaskResourceTable taskResource = $TaskResourceTable(this);
  late final $SideEffectTable sideEffect = $SideEffectTable(this);
  late final $ReferralTable referral = $ReferralTable(this);
  late final $LocalizationTable localization = $LocalizationTable(this);
  late final $UserActionTable userAction = $UserActionTable(this);
  late final $UniqueIdPoolTable uniqueIdPool = $UniqueIdPoolTable(this);
  late final Index attendanceClientref = Index('attendance_clientref',
      'CREATE INDEX attendance_clientref ON attendance (client_reference_id)');
  late final Index attendanceIndividualid = Index('attendance_individualid',
      'CREATE INDEX attendance_individualid ON attendance (individual_id)');
  late final Index projectClinetref = Index('project_clinetref',
      'CREATE INDEX project_clinetref ON project_beneficiary (client_reference_id)');
  late final Index projectProjectid = Index('project_projectid',
      'CREATE INDEX project_projectid ON project_beneficiary (project_id)');
  late final Index projectProjectbeneficiaryclientref = Index(
      'project_projectbeneficiaryclientref',
      'CREATE INDEX project_projectbeneficiaryclientref ON project_beneficiary (beneficiary_client_reference_id)');
  late final Index stockClientref = Index('stock_clientref',
      'CREATE INDEX stock_clientref ON stock (client_reference_id)');
  late final Index stockProductvariantid = Index('stock_productvariantid',
      'CREATE INDEX stock_productvariantid ON stock (product_variant_id)');
  late final Index stockFacilityid = Index('stock_facilityid',
      'CREATE INDEX stock_facilityid ON stock (facility_id)');
  late final Index stockreconClientref = Index('stockrecon_clientref',
      'CREATE INDEX stockrecon_clientref ON stock_reconciliation (client_reference_id)');
  late final Index stockreconFacilityid = Index('stockrecon_facilityid',
      'CREATE INDEX stockrecon_facilityid ON stock_reconciliation (facility_id)');
  late final Index stockreconProductvariantid = Index(
      'stockrecon_productvariantid',
      'CREATE INDEX stockrecon_productvariantid ON stock_reconciliation (product_variant_id)');
  late final Index hfreferralClientref = Index('hfreferral_clientref',
      'CREATE INDEX hfreferral_clientref ON h_f_referral (client_reference_id)');
  late final Index hfreferralProjectid = Index('hfreferral_projectid',
      'CREATE INDEX hfreferral_projectid ON h_f_referral (project_id)');
  late final Index householdmemberClinetref = Index('householdmember_clinetref',
      'CREATE INDEX householdmember_clinetref ON household_member (client_reference_id)');
  late final Index householdClientref = Index('household_clientref',
      'CREATE INDEX household_clientref ON household_member (household_client_reference_id)');
  late final Index householdmemberIndividualid = Index(
      'householdmember_individualid',
      'CREATE INDEX householdmember_individualid ON household_member (individual_client_reference_id)');
  late final Index taskClinetref = Index('task_clinetref',
      'CREATE INDEX task_clinetref ON task (client_reference_id)');
  late final Index taskProjectid = Index(
      'task_projectid', 'CREATE INDEX task_projectid ON task (project_id)');
  late final Index taskProjectbeneficiaryid = Index('task_projectbeneficiaryid',
      'CREATE INDEX task_projectbeneficiaryid ON task (project_beneficiary_id)');
  late final Index taskProjectbeneficiaryclientref = Index(
      'task_projectbeneficiaryclientref',
      'CREATE INDEX task_projectbeneficiaryclientref ON task (project_beneficiary_client_reference_id)');
  late final Index taskresourceclinetref = Index('taskresourceclinetref',
      'CREATE INDEX taskresourceclinetref ON task_resource (client_reference_id)');
  late final Index taskresourceTaskclientref = Index(
      'taskresource_taskclientref',
      'CREATE INDEX taskresource_taskclientref ON task_resource (taskclient_reference_id)');
  late final Index taskresourceProductvariantid = Index(
      'taskresource_productvariantid',
      'CREATE INDEX taskresource_productvariantid ON task_resource (product_variant_id)');
  late final Index sideeffectClinetref = Index('sideeffect_clinetref',
      'CREATE INDEX sideeffect_clinetref ON side_effect (client_reference_id)');
  late final Index sideeffectProjectid = Index('sideeffect_projectid',
      'CREATE INDEX sideeffect_projectid ON side_effect (project_id)');
  late final Index sideeffectTaskclientref = Index('sideeffect_taskclientref',
      'CREATE INDEX sideeffect_taskclientref ON side_effect (task_client_reference_id)');
  late final Index referralClinetref = Index('referral_clinetref',
      'CREATE INDEX referral_clinetref ON referral (client_reference_id)');
  late final Index referralProjectid = Index('referral_projectid',
      'CREATE INDEX referral_projectid ON referral (project_id)');
  late final Index referralProjectbeneficiaryclientref = Index(
      'referral_projectbeneficiaryclientref',
      'CREATE INDEX referral_projectbeneficiaryclientref ON referral (project_beneficiary_client_reference_id)');
  late final Index localizationModule = Index('localization_module',
      'CREATE INDEX localization_module ON localization (module)');
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        attendanceRegister,
        attendance,
        attendee,
        address,
        name,
        boundary,
        document,
        facility,
        product,
        productVariant,
        project,
        projectBeneficiary,
        projectFacility,
        projectProductVariant,
        projectResource,
        projectStaff,
        projectType,
        individual,
        identifier,
        stock,
        stockReconciliation,
        target,
        service,
        serviceAttributes,
        serviceDefinition,
        locality,
        staff,
        attributes,
        pgrService,
        pgrComplainant,
        user,
        downsync,
        downsyncCriteria,
        hFReferral,
        household,
        householdMember,
        householdMemberRelationShip,
        task,
        taskResource,
        sideEffect,
        referral,
        localization,
        userAction,
        uniqueIdPool,
        attendanceClientref,
        attendanceIndividualid,
        projectClinetref,
        projectProjectid,
        projectProjectbeneficiaryclientref,
        stockClientref,
        stockProductvariantid,
        stockFacilityid,
        stockreconClientref,
        stockreconFacilityid,
        stockreconProductvariantid,
        hfreferralClientref,
        hfreferralProjectid,
        householdmemberClinetref,
        householdClientref,
        householdmemberIndividualid,
        taskClinetref,
        taskProjectid,
        taskProjectbeneficiaryid,
        taskProjectbeneficiaryclientref,
        taskresourceclinetref,
        taskresourceTaskclientref,
        taskresourceProductvariantid,
        sideeffectClinetref,
        sideeffectProjectid,
        sideeffectTaskclientref,
        referralClinetref,
        referralProjectid,
        referralProjectbeneficiaryclientref,
        localizationModule
      ];
}

typedef $$AttendanceRegisterTableInsertCompanionBuilder
    = AttendanceRegisterCompanion Function({
  Value<String?> id,
  required String tenantId,
  required String registerNumber,
  required String name,
  required String referenceId,
  required String localityCode,
  required String serviceCode,
  required String status,
  Value<int?> startDate,
  Value<int?> endDate,
  Value<String?> additionalFields,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<int> rowid,
});
typedef $$AttendanceRegisterTableUpdateCompanionBuilder
    = AttendanceRegisterCompanion Function({
  Value<String?> id,
  Value<String> tenantId,
  Value<String> registerNumber,
  Value<String> name,
  Value<String> referenceId,
  Value<String> localityCode,
  Value<String> serviceCode,
  Value<String> status,
  Value<int?> startDate,
  Value<int?> endDate,
  Value<String?> additionalFields,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<int> rowid,
});

class $$AttendanceRegisterTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $AttendanceRegisterTable,
    AttendanceRegisterData,
    $$AttendanceRegisterTableFilterComposer,
    $$AttendanceRegisterTableOrderingComposer,
    $$AttendanceRegisterTableProcessedTableManager,
    $$AttendanceRegisterTableInsertCompanionBuilder,
    $$AttendanceRegisterTableUpdateCompanionBuilder> {
  $$AttendanceRegisterTableTableManager(
      _$LocalSqlDataStore db, $AttendanceRegisterTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$AttendanceRegisterTableFilterComposer(ComposerState(db, table)),
          orderingComposer: $$AttendanceRegisterTableOrderingComposer(
              ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$AttendanceRegisterTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String> tenantId = const Value.absent(),
            Value<String> registerNumber = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String> referenceId = const Value.absent(),
            Value<String> localityCode = const Value.absent(),
            Value<String> serviceCode = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int?> startDate = const Value.absent(),
            Value<int?> endDate = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AttendanceRegisterCompanion(
            id: id,
            tenantId: tenantId,
            registerNumber: registerNumber,
            name: name,
            referenceId: referenceId,
            localityCode: localityCode,
            serviceCode: serviceCode,
            status: status,
            startDate: startDate,
            endDate: endDate,
            additionalFields: additionalFields,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            required String tenantId,
            required String registerNumber,
            required String name,
            required String referenceId,
            required String localityCode,
            required String serviceCode,
            required String status,
            Value<int?> startDate = const Value.absent(),
            Value<int?> endDate = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AttendanceRegisterCompanion.insert(
            id: id,
            tenantId: tenantId,
            registerNumber: registerNumber,
            name: name,
            referenceId: referenceId,
            localityCode: localityCode,
            serviceCode: serviceCode,
            status: status,
            startDate: startDate,
            endDate: endDate,
            additionalFields: additionalFields,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            rowid: rowid,
          ),
        ));
}

class $$AttendanceRegisterTableProcessedTableManager
    extends ProcessedTableManager<
        _$LocalSqlDataStore,
        $AttendanceRegisterTable,
        AttendanceRegisterData,
        $$AttendanceRegisterTableFilterComposer,
        $$AttendanceRegisterTableOrderingComposer,
        $$AttendanceRegisterTableProcessedTableManager,
        $$AttendanceRegisterTableInsertCompanionBuilder,
        $$AttendanceRegisterTableUpdateCompanionBuilder> {
  $$AttendanceRegisterTableProcessedTableManager(super.$state);
}

class $$AttendanceRegisterTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $AttendanceRegisterTable> {
  $$AttendanceRegisterTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get registerNumber => $state.composableBuilder(
      column: $state.table.registerNumber,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get localityCode => $state.composableBuilder(
      column: $state.table.localityCode,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get serviceCode => $state.composableBuilder(
      column: $state.table.serviceCode,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get status => $state.composableBuilder(
      column: $state.table.status,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get startDate => $state.composableBuilder(
      column: $state.table.startDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get endDate => $state.composableBuilder(
      column: $state.table.endDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$AttendanceRegisterTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $AttendanceRegisterTable> {
  $$AttendanceRegisterTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get registerNumber => $state.composableBuilder(
      column: $state.table.registerNumber,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get localityCode => $state.composableBuilder(
      column: $state.table.localityCode,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get serviceCode => $state.composableBuilder(
      column: $state.table.serviceCode,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get status => $state.composableBuilder(
      column: $state.table.status,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get startDate => $state.composableBuilder(
      column: $state.table.startDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get endDate => $state.composableBuilder(
      column: $state.table.endDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$AttendanceTableInsertCompanionBuilder = AttendanceCompanion Function({
  Value<String?> id,
  Value<String?> clientReferenceId,
  required String tenantId,
  required String registerId,
  required String individualId,
  Value<int?> time,
  Value<String?> status,
  Value<String?> type,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditCreatedBy,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<bool?> uploadToServer,
  Value<int> rowid,
});
typedef $$AttendanceTableUpdateCompanionBuilder = AttendanceCompanion Function({
  Value<String?> id,
  Value<String?> clientReferenceId,
  Value<String> tenantId,
  Value<String> registerId,
  Value<String> individualId,
  Value<int?> time,
  Value<String?> status,
  Value<String?> type,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditCreatedBy,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<bool?> uploadToServer,
  Value<int> rowid,
});

class $$AttendanceTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $AttendanceTable,
    AttendanceData,
    $$AttendanceTableFilterComposer,
    $$AttendanceTableOrderingComposer,
    $$AttendanceTableProcessedTableManager,
    $$AttendanceTableInsertCompanionBuilder,
    $$AttendanceTableUpdateCompanionBuilder> {
  $$AttendanceTableTableManager(_$LocalSqlDataStore db, $AttendanceTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$AttendanceTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$AttendanceTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$AttendanceTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> clientReferenceId = const Value.absent(),
            Value<String> tenantId = const Value.absent(),
            Value<String> registerId = const Value.absent(),
            Value<String> individualId = const Value.absent(),
            Value<int?> time = const Value.absent(),
            Value<String?> status = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<bool?> uploadToServer = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AttendanceCompanion(
            id: id,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            registerId: registerId,
            individualId: individualId,
            time: time,
            status: status,
            type: type,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditCreatedBy: auditCreatedBy,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            uploadToServer: uploadToServer,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> clientReferenceId = const Value.absent(),
            required String tenantId,
            required String registerId,
            required String individualId,
            Value<int?> time = const Value.absent(),
            Value<String?> status = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<bool?> uploadToServer = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AttendanceCompanion.insert(
            id: id,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            registerId: registerId,
            individualId: individualId,
            time: time,
            status: status,
            type: type,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditCreatedBy: auditCreatedBy,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            uploadToServer: uploadToServer,
            rowid: rowid,
          ),
        ));
}

class $$AttendanceTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $AttendanceTable,
    AttendanceData,
    $$AttendanceTableFilterComposer,
    $$AttendanceTableOrderingComposer,
    $$AttendanceTableProcessedTableManager,
    $$AttendanceTableInsertCompanionBuilder,
    $$AttendanceTableUpdateCompanionBuilder> {
  $$AttendanceTableProcessedTableManager(super.$state);
}

class $$AttendanceTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $AttendanceTable> {
  $$AttendanceTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get registerId => $state.composableBuilder(
      column: $state.table.registerId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get individualId => $state.composableBuilder(
      column: $state.table.individualId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get time => $state.composableBuilder(
      column: $state.table.time,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get status => $state.composableBuilder(
      column: $state.table.status,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get type => $state.composableBuilder(
      column: $state.table.type,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get uploadToServer => $state.composableBuilder(
      column: $state.table.uploadToServer,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$AttendanceTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $AttendanceTable> {
  $$AttendanceTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get registerId => $state.composableBuilder(
      column: $state.table.registerId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get individualId => $state.composableBuilder(
      column: $state.table.individualId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get time => $state.composableBuilder(
      column: $state.table.time,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get status => $state.composableBuilder(
      column: $state.table.status,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get type => $state.composableBuilder(
      column: $state.table.type,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get uploadToServer => $state.composableBuilder(
      column: $state.table.uploadToServer,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$AttendeeTableInsertCompanionBuilder = AttendeeCompanion Function({
  Value<String?> id,
  required String tenantId,
  required String registerId,
  required String individualId,
  Value<int?> status,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditCreatedBy,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<int?> enrollmentDate,
  Value<int?> denrollmentDate,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<String?> tag,
  Value<int> rowid,
});
typedef $$AttendeeTableUpdateCompanionBuilder = AttendeeCompanion Function({
  Value<String?> id,
  Value<String> tenantId,
  Value<String> registerId,
  Value<String> individualId,
  Value<int?> status,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditCreatedBy,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<int?> enrollmentDate,
  Value<int?> denrollmentDate,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<String?> tag,
  Value<int> rowid,
});

class $$AttendeeTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $AttendeeTable,
    AttendeeData,
    $$AttendeeTableFilterComposer,
    $$AttendeeTableOrderingComposer,
    $$AttendeeTableProcessedTableManager,
    $$AttendeeTableInsertCompanionBuilder,
    $$AttendeeTableUpdateCompanionBuilder> {
  $$AttendeeTableTableManager(_$LocalSqlDataStore db, $AttendeeTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$AttendeeTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$AttendeeTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$AttendeeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String> tenantId = const Value.absent(),
            Value<String> registerId = const Value.absent(),
            Value<String> individualId = const Value.absent(),
            Value<int?> status = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<int?> enrollmentDate = const Value.absent(),
            Value<int?> denrollmentDate = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<String?> tag = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AttendeeCompanion(
            id: id,
            tenantId: tenantId,
            registerId: registerId,
            individualId: individualId,
            status: status,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditCreatedBy: auditCreatedBy,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            enrollmentDate: enrollmentDate,
            denrollmentDate: denrollmentDate,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            tag: tag,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            required String tenantId,
            required String registerId,
            required String individualId,
            Value<int?> status = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<int?> enrollmentDate = const Value.absent(),
            Value<int?> denrollmentDate = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<String?> tag = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AttendeeCompanion.insert(
            id: id,
            tenantId: tenantId,
            registerId: registerId,
            individualId: individualId,
            status: status,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditCreatedBy: auditCreatedBy,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            enrollmentDate: enrollmentDate,
            denrollmentDate: denrollmentDate,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            tag: tag,
            rowid: rowid,
          ),
        ));
}

class $$AttendeeTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $AttendeeTable,
    AttendeeData,
    $$AttendeeTableFilterComposer,
    $$AttendeeTableOrderingComposer,
    $$AttendeeTableProcessedTableManager,
    $$AttendeeTableInsertCompanionBuilder,
    $$AttendeeTableUpdateCompanionBuilder> {
  $$AttendeeTableProcessedTableManager(super.$state);
}

class $$AttendeeTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $AttendeeTable> {
  $$AttendeeTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get registerId => $state.composableBuilder(
      column: $state.table.registerId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get individualId => $state.composableBuilder(
      column: $state.table.individualId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get status => $state.composableBuilder(
      column: $state.table.status,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get enrollmentDate => $state.composableBuilder(
      column: $state.table.enrollmentDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get denrollmentDate => $state.composableBuilder(
      column: $state.table.denrollmentDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tag => $state.composableBuilder(
      column: $state.table.tag,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$AttendeeTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $AttendeeTable> {
  $$AttendeeTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get registerId => $state.composableBuilder(
      column: $state.table.registerId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get individualId => $state.composableBuilder(
      column: $state.table.individualId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get status => $state.composableBuilder(
      column: $state.table.status,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get enrollmentDate => $state.composableBuilder(
      column: $state.table.enrollmentDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get denrollmentDate => $state.composableBuilder(
      column: $state.table.denrollmentDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tag => $state.composableBuilder(
      column: $state.table.tag,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$AddressTableInsertCompanionBuilder = AddressCompanion Function({
  Value<String?> id,
  Value<String?> relatedClientReferenceId,
  Value<String?> doorNo,
  Value<double?> latitude,
  Value<double?> longitude,
  Value<double?> locationAccuracy,
  Value<String?> addressLine1,
  Value<String?> addressLine2,
  Value<String?> landmark,
  Value<String?> city,
  Value<String?> pincode,
  Value<String?> buildingName,
  Value<String?> street,
  Value<String?> boundaryType,
  Value<String?> boundary,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> localityBoundaryCode,
  Value<String?> localityBoundaryName,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<AddressType?> type,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$AddressTableUpdateCompanionBuilder = AddressCompanion Function({
  Value<String?> id,
  Value<String?> relatedClientReferenceId,
  Value<String?> doorNo,
  Value<double?> latitude,
  Value<double?> longitude,
  Value<double?> locationAccuracy,
  Value<String?> addressLine1,
  Value<String?> addressLine2,
  Value<String?> landmark,
  Value<String?> city,
  Value<String?> pincode,
  Value<String?> buildingName,
  Value<String?> street,
  Value<String?> boundaryType,
  Value<String?> boundary,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> localityBoundaryCode,
  Value<String?> localityBoundaryName,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<AddressType?> type,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$AddressTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $AddressTable,
    Addres,
    $$AddressTableFilterComposer,
    $$AddressTableOrderingComposer,
    $$AddressTableProcessedTableManager,
    $$AddressTableInsertCompanionBuilder,
    $$AddressTableUpdateCompanionBuilder> {
  $$AddressTableTableManager(_$LocalSqlDataStore db, $AddressTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$AddressTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$AddressTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) => $$AddressTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> relatedClientReferenceId = const Value.absent(),
            Value<String?> doorNo = const Value.absent(),
            Value<double?> latitude = const Value.absent(),
            Value<double?> longitude = const Value.absent(),
            Value<double?> locationAccuracy = const Value.absent(),
            Value<String?> addressLine1 = const Value.absent(),
            Value<String?> addressLine2 = const Value.absent(),
            Value<String?> landmark = const Value.absent(),
            Value<String?> city = const Value.absent(),
            Value<String?> pincode = const Value.absent(),
            Value<String?> buildingName = const Value.absent(),
            Value<String?> street = const Value.absent(),
            Value<String?> boundaryType = const Value.absent(),
            Value<String?> boundary = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> localityBoundaryCode = const Value.absent(),
            Value<String?> localityBoundaryName = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<AddressType?> type = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AddressCompanion(
            id: id,
            relatedClientReferenceId: relatedClientReferenceId,
            doorNo: doorNo,
            latitude: latitude,
            longitude: longitude,
            locationAccuracy: locationAccuracy,
            addressLine1: addressLine1,
            addressLine2: addressLine2,
            landmark: landmark,
            city: city,
            pincode: pincode,
            buildingName: buildingName,
            street: street,
            boundaryType: boundaryType,
            boundary: boundary,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            localityBoundaryCode: localityBoundaryCode,
            localityBoundaryName: localityBoundaryName,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            type: type,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> relatedClientReferenceId = const Value.absent(),
            Value<String?> doorNo = const Value.absent(),
            Value<double?> latitude = const Value.absent(),
            Value<double?> longitude = const Value.absent(),
            Value<double?> locationAccuracy = const Value.absent(),
            Value<String?> addressLine1 = const Value.absent(),
            Value<String?> addressLine2 = const Value.absent(),
            Value<String?> landmark = const Value.absent(),
            Value<String?> city = const Value.absent(),
            Value<String?> pincode = const Value.absent(),
            Value<String?> buildingName = const Value.absent(),
            Value<String?> street = const Value.absent(),
            Value<String?> boundaryType = const Value.absent(),
            Value<String?> boundary = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> localityBoundaryCode = const Value.absent(),
            Value<String?> localityBoundaryName = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<AddressType?> type = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AddressCompanion.insert(
            id: id,
            relatedClientReferenceId: relatedClientReferenceId,
            doorNo: doorNo,
            latitude: latitude,
            longitude: longitude,
            locationAccuracy: locationAccuracy,
            addressLine1: addressLine1,
            addressLine2: addressLine2,
            landmark: landmark,
            city: city,
            pincode: pincode,
            buildingName: buildingName,
            street: street,
            boundaryType: boundaryType,
            boundary: boundary,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            localityBoundaryCode: localityBoundaryCode,
            localityBoundaryName: localityBoundaryName,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            type: type,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$AddressTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $AddressTable,
    Addres,
    $$AddressTableFilterComposer,
    $$AddressTableOrderingComposer,
    $$AddressTableProcessedTableManager,
    $$AddressTableInsertCompanionBuilder,
    $$AddressTableUpdateCompanionBuilder> {
  $$AddressTableProcessedTableManager(super.$state);
}

class $$AddressTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $AddressTable> {
  $$AddressTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get relatedClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.relatedClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get doorNo => $state.composableBuilder(
      column: $state.table.doorNo,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<double> get latitude => $state.composableBuilder(
      column: $state.table.latitude,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<double> get longitude => $state.composableBuilder(
      column: $state.table.longitude,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<double> get locationAccuracy => $state.composableBuilder(
      column: $state.table.locationAccuracy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get addressLine1 => $state.composableBuilder(
      column: $state.table.addressLine1,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get addressLine2 => $state.composableBuilder(
      column: $state.table.addressLine2,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get landmark => $state.composableBuilder(
      column: $state.table.landmark,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get city => $state.composableBuilder(
      column: $state.table.city,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get pincode => $state.composableBuilder(
      column: $state.table.pincode,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get buildingName => $state.composableBuilder(
      column: $state.table.buildingName,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get street => $state.composableBuilder(
      column: $state.table.street,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get boundaryType => $state.composableBuilder(
      column: $state.table.boundaryType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get boundary => $state.composableBuilder(
      column: $state.table.boundary,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get localityBoundaryCode => $state.composableBuilder(
      column: $state.table.localityBoundaryCode,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get localityBoundaryName => $state.composableBuilder(
      column: $state.table.localityBoundaryName,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnWithTypeConverterFilters<AddressType?, AddressType, int> get type =>
      $state.composableBuilder(
          column: $state.table.type,
          builder: (column, joinBuilders) => ColumnWithTypeConverterFilters(
              column,
              joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$AddressTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $AddressTable> {
  $$AddressTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get relatedClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.relatedClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get doorNo => $state.composableBuilder(
      column: $state.table.doorNo,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<double> get latitude => $state.composableBuilder(
      column: $state.table.latitude,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<double> get longitude => $state.composableBuilder(
      column: $state.table.longitude,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<double> get locationAccuracy => $state.composableBuilder(
      column: $state.table.locationAccuracy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get addressLine1 => $state.composableBuilder(
      column: $state.table.addressLine1,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get addressLine2 => $state.composableBuilder(
      column: $state.table.addressLine2,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get landmark => $state.composableBuilder(
      column: $state.table.landmark,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get city => $state.composableBuilder(
      column: $state.table.city,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get pincode => $state.composableBuilder(
      column: $state.table.pincode,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get buildingName => $state.composableBuilder(
      column: $state.table.buildingName,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get street => $state.composableBuilder(
      column: $state.table.street,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get boundaryType => $state.composableBuilder(
      column: $state.table.boundaryType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get boundary => $state.composableBuilder(
      column: $state.table.boundary,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get localityBoundaryCode => $state.composableBuilder(
      column: $state.table.localityBoundaryCode,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get localityBoundaryName => $state.composableBuilder(
      column: $state.table.localityBoundaryName,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get type => $state.composableBuilder(
      column: $state.table.type,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$NameTableInsertCompanionBuilder = NameCompanion Function({
  Value<String?> id,
  Value<String?> individualClientReferenceId,
  Value<String?> givenName,
  Value<String?> familyName,
  Value<String?> otherNames,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$NameTableUpdateCompanionBuilder = NameCompanion Function({
  Value<String?> id,
  Value<String?> individualClientReferenceId,
  Value<String?> givenName,
  Value<String?> familyName,
  Value<String?> otherNames,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$NameTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $NameTable,
    NameData,
    $$NameTableFilterComposer,
    $$NameTableOrderingComposer,
    $$NameTableProcessedTableManager,
    $$NameTableInsertCompanionBuilder,
    $$NameTableUpdateCompanionBuilder> {
  $$NameTableTableManager(_$LocalSqlDataStore db, $NameTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$NameTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$NameTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) => $$NameTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> individualClientReferenceId = const Value.absent(),
            Value<String?> givenName = const Value.absent(),
            Value<String?> familyName = const Value.absent(),
            Value<String?> otherNames = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              NameCompanion(
            id: id,
            individualClientReferenceId: individualClientReferenceId,
            givenName: givenName,
            familyName: familyName,
            otherNames: otherNames,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> individualClientReferenceId = const Value.absent(),
            Value<String?> givenName = const Value.absent(),
            Value<String?> familyName = const Value.absent(),
            Value<String?> otherNames = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              NameCompanion.insert(
            id: id,
            individualClientReferenceId: individualClientReferenceId,
            givenName: givenName,
            familyName: familyName,
            otherNames: otherNames,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$NameTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $NameTable,
    NameData,
    $$NameTableFilterComposer,
    $$NameTableOrderingComposer,
    $$NameTableProcessedTableManager,
    $$NameTableInsertCompanionBuilder,
    $$NameTableUpdateCompanionBuilder> {
  $$NameTableProcessedTableManager(super.$state);
}

class $$NameTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $NameTable> {
  $$NameTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get individualClientReferenceId => $state
      .composableBuilder(
          column: $state.table.individualClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get givenName => $state.composableBuilder(
      column: $state.table.givenName,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get familyName => $state.composableBuilder(
      column: $state.table.familyName,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get otherNames => $state.composableBuilder(
      column: $state.table.otherNames,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$NameTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $NameTable> {
  $$NameTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get individualClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.individualClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get givenName => $state.composableBuilder(
      column: $state.table.givenName,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get familyName => $state.composableBuilder(
      column: $state.table.familyName,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get otherNames => $state.composableBuilder(
      column: $state.table.otherNames,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$BoundaryTableInsertCompanionBuilder = BoundaryCompanion Function({
  Value<String?> code,
  Value<String?> name,
  Value<String?> label,
  Value<String?> latitude,
  Value<String?> longitude,
  Value<String?> materializedPath,
  Value<String?> auditCreatedBy,
  Value<int?> boundaryNum,
  Value<int?> auditCreatedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<int> rowid,
});
typedef $$BoundaryTableUpdateCompanionBuilder = BoundaryCompanion Function({
  Value<String?> code,
  Value<String?> name,
  Value<String?> label,
  Value<String?> latitude,
  Value<String?> longitude,
  Value<String?> materializedPath,
  Value<String?> auditCreatedBy,
  Value<int?> boundaryNum,
  Value<int?> auditCreatedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<int> rowid,
});

class $$BoundaryTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $BoundaryTable,
    BoundaryData,
    $$BoundaryTableFilterComposer,
    $$BoundaryTableOrderingComposer,
    $$BoundaryTableProcessedTableManager,
    $$BoundaryTableInsertCompanionBuilder,
    $$BoundaryTableUpdateCompanionBuilder> {
  $$BoundaryTableTableManager(_$LocalSqlDataStore db, $BoundaryTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$BoundaryTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$BoundaryTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$BoundaryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> code = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> label = const Value.absent(),
            Value<String?> latitude = const Value.absent(),
            Value<String?> longitude = const Value.absent(),
            Value<String?> materializedPath = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<int?> boundaryNum = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              BoundaryCompanion(
            code: code,
            name: name,
            label: label,
            latitude: latitude,
            longitude: longitude,
            materializedPath: materializedPath,
            auditCreatedBy: auditCreatedBy,
            boundaryNum: boundaryNum,
            auditCreatedTime: auditCreatedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> code = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> label = const Value.absent(),
            Value<String?> latitude = const Value.absent(),
            Value<String?> longitude = const Value.absent(),
            Value<String?> materializedPath = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<int?> boundaryNum = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              BoundaryCompanion.insert(
            code: code,
            name: name,
            label: label,
            latitude: latitude,
            longitude: longitude,
            materializedPath: materializedPath,
            auditCreatedBy: auditCreatedBy,
            boundaryNum: boundaryNum,
            auditCreatedTime: auditCreatedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            rowid: rowid,
          ),
        ));
}

class $$BoundaryTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $BoundaryTable,
    BoundaryData,
    $$BoundaryTableFilterComposer,
    $$BoundaryTableOrderingComposer,
    $$BoundaryTableProcessedTableManager,
    $$BoundaryTableInsertCompanionBuilder,
    $$BoundaryTableUpdateCompanionBuilder> {
  $$BoundaryTableProcessedTableManager(super.$state);
}

class $$BoundaryTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $BoundaryTable> {
  $$BoundaryTableFilterComposer(super.$state);
  ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get label => $state.composableBuilder(
      column: $state.table.label,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get latitude => $state.composableBuilder(
      column: $state.table.latitude,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get longitude => $state.composableBuilder(
      column: $state.table.longitude,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get materializedPath => $state.composableBuilder(
      column: $state.table.materializedPath,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get boundaryNum => $state.composableBuilder(
      column: $state.table.boundaryNum,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$BoundaryTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $BoundaryTable> {
  $$BoundaryTableOrderingComposer(super.$state);
  ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get label => $state.composableBuilder(
      column: $state.table.label,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get latitude => $state.composableBuilder(
      column: $state.table.latitude,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get longitude => $state.composableBuilder(
      column: $state.table.longitude,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get materializedPath => $state.composableBuilder(
      column: $state.table.materializedPath,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get boundaryNum => $state.composableBuilder(
      column: $state.table.boundaryNum,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$DocumentTableInsertCompanionBuilder = DocumentCompanion Function({
  Value<String?> id,
  Value<String?> documentType,
  Value<String?> fileStoreId,
  Value<String?> documentUid,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$DocumentTableUpdateCompanionBuilder = DocumentCompanion Function({
  Value<String?> id,
  Value<String?> documentType,
  Value<String?> fileStoreId,
  Value<String?> documentUid,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$DocumentTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $DocumentTable,
    DocumentData,
    $$DocumentTableFilterComposer,
    $$DocumentTableOrderingComposer,
    $$DocumentTableProcessedTableManager,
    $$DocumentTableInsertCompanionBuilder,
    $$DocumentTableUpdateCompanionBuilder> {
  $$DocumentTableTableManager(_$LocalSqlDataStore db, $DocumentTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$DocumentTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$DocumentTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$DocumentTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> documentType = const Value.absent(),
            Value<String?> fileStoreId = const Value.absent(),
            Value<String?> documentUid = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DocumentCompanion(
            id: id,
            documentType: documentType,
            fileStoreId: fileStoreId,
            documentUid: documentUid,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> documentType = const Value.absent(),
            Value<String?> fileStoreId = const Value.absent(),
            Value<String?> documentUid = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DocumentCompanion.insert(
            id: id,
            documentType: documentType,
            fileStoreId: fileStoreId,
            documentUid: documentUid,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$DocumentTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $DocumentTable,
    DocumentData,
    $$DocumentTableFilterComposer,
    $$DocumentTableOrderingComposer,
    $$DocumentTableProcessedTableManager,
    $$DocumentTableInsertCompanionBuilder,
    $$DocumentTableUpdateCompanionBuilder> {
  $$DocumentTableProcessedTableManager(super.$state);
}

class $$DocumentTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $DocumentTable> {
  $$DocumentTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get documentType => $state.composableBuilder(
      column: $state.table.documentType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get fileStoreId => $state.composableBuilder(
      column: $state.table.fileStoreId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get documentUid => $state.composableBuilder(
      column: $state.table.documentUid,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$DocumentTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $DocumentTable> {
  $$DocumentTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get documentType => $state.composableBuilder(
      column: $state.table.documentType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get fileStoreId => $state.composableBuilder(
      column: $state.table.fileStoreId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get documentUid => $state.composableBuilder(
      column: $state.table.documentUid,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$FacilityTableInsertCompanionBuilder = FacilityCompanion Function({
  required String id,
  Value<bool?> isPermanent,
  Value<String?> usage,
  Value<int?> storageCapacity,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<String?> name,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$FacilityTableUpdateCompanionBuilder = FacilityCompanion Function({
  Value<String> id,
  Value<bool?> isPermanent,
  Value<String?> usage,
  Value<int?> storageCapacity,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<String?> name,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$FacilityTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $FacilityTable,
    FacilityData,
    $$FacilityTableFilterComposer,
    $$FacilityTableOrderingComposer,
    $$FacilityTableProcessedTableManager,
    $$FacilityTableInsertCompanionBuilder,
    $$FacilityTableUpdateCompanionBuilder> {
  $$FacilityTableTableManager(_$LocalSqlDataStore db, $FacilityTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$FacilityTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$FacilityTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$FacilityTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String> id = const Value.absent(),
            Value<bool?> isPermanent = const Value.absent(),
            Value<String?> usage = const Value.absent(),
            Value<int?> storageCapacity = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              FacilityCompanion(
            id: id,
            isPermanent: isPermanent,
            usage: usage,
            storageCapacity: storageCapacity,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            name: name,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String id,
            Value<bool?> isPermanent = const Value.absent(),
            Value<String?> usage = const Value.absent(),
            Value<int?> storageCapacity = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              FacilityCompanion.insert(
            id: id,
            isPermanent: isPermanent,
            usage: usage,
            storageCapacity: storageCapacity,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            name: name,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$FacilityTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $FacilityTable,
    FacilityData,
    $$FacilityTableFilterComposer,
    $$FacilityTableOrderingComposer,
    $$FacilityTableProcessedTableManager,
    $$FacilityTableInsertCompanionBuilder,
    $$FacilityTableUpdateCompanionBuilder> {
  $$FacilityTableProcessedTableManager(super.$state);
}

class $$FacilityTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $FacilityTable> {
  $$FacilityTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isPermanent => $state.composableBuilder(
      column: $state.table.isPermanent,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get usage => $state.composableBuilder(
      column: $state.table.usage,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get storageCapacity => $state.composableBuilder(
      column: $state.table.storageCapacity,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$FacilityTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $FacilityTable> {
  $$FacilityTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isPermanent => $state.composableBuilder(
      column: $state.table.isPermanent,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get usage => $state.composableBuilder(
      column: $state.table.usage,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get storageCapacity => $state.composableBuilder(
      column: $state.table.storageCapacity,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ProductTableInsertCompanionBuilder = ProductCompanion Function({
  Value<String?> id,
  Value<String?> type,
  Value<String?> name,
  Value<String?> manufacturer,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$ProductTableUpdateCompanionBuilder = ProductCompanion Function({
  Value<String?> id,
  Value<String?> type,
  Value<String?> name,
  Value<String?> manufacturer,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$ProductTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $ProductTable,
    ProductData,
    $$ProductTableFilterComposer,
    $$ProductTableOrderingComposer,
    $$ProductTableProcessedTableManager,
    $$ProductTableInsertCompanionBuilder,
    $$ProductTableUpdateCompanionBuilder> {
  $$ProductTableTableManager(_$LocalSqlDataStore db, $ProductTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ProductTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$ProductTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) => $$ProductTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> manufacturer = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProductCompanion(
            id: id,
            type: type,
            name: name,
            manufacturer: manufacturer,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> manufacturer = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProductCompanion.insert(
            id: id,
            type: type,
            name: name,
            manufacturer: manufacturer,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$ProductTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $ProductTable,
    ProductData,
    $$ProductTableFilterComposer,
    $$ProductTableOrderingComposer,
    $$ProductTableProcessedTableManager,
    $$ProductTableInsertCompanionBuilder,
    $$ProductTableUpdateCompanionBuilder> {
  $$ProductTableProcessedTableManager(super.$state);
}

class $$ProductTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $ProductTable> {
  $$ProductTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get type => $state.composableBuilder(
      column: $state.table.type,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get manufacturer => $state.composableBuilder(
      column: $state.table.manufacturer,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ProductTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $ProductTable> {
  $$ProductTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get type => $state.composableBuilder(
      column: $state.table.type,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get manufacturer => $state.composableBuilder(
      column: $state.table.manufacturer,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ProductVariantTableInsertCompanionBuilder = ProductVariantCompanion
    Function({
  required String id,
  Value<String?> productId,
  Value<String?> sku,
  Value<String?> variation,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$ProductVariantTableUpdateCompanionBuilder = ProductVariantCompanion
    Function({
  Value<String> id,
  Value<String?> productId,
  Value<String?> sku,
  Value<String?> variation,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$ProductVariantTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $ProductVariantTable,
    ProductVariantData,
    $$ProductVariantTableFilterComposer,
    $$ProductVariantTableOrderingComposer,
    $$ProductVariantTableProcessedTableManager,
    $$ProductVariantTableInsertCompanionBuilder,
    $$ProductVariantTableUpdateCompanionBuilder> {
  $$ProductVariantTableTableManager(
      _$LocalSqlDataStore db, $ProductVariantTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ProductVariantTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$ProductVariantTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ProductVariantTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String> id = const Value.absent(),
            Value<String?> productId = const Value.absent(),
            Value<String?> sku = const Value.absent(),
            Value<String?> variation = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProductVariantCompanion(
            id: id,
            productId: productId,
            sku: sku,
            variation: variation,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String id,
            Value<String?> productId = const Value.absent(),
            Value<String?> sku = const Value.absent(),
            Value<String?> variation = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProductVariantCompanion.insert(
            id: id,
            productId: productId,
            sku: sku,
            variation: variation,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$ProductVariantTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $ProductVariantTable,
    ProductVariantData,
    $$ProductVariantTableFilterComposer,
    $$ProductVariantTableOrderingComposer,
    $$ProductVariantTableProcessedTableManager,
    $$ProductVariantTableInsertCompanionBuilder,
    $$ProductVariantTableUpdateCompanionBuilder> {
  $$ProductVariantTableProcessedTableManager(super.$state);
}

class $$ProductVariantTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $ProductVariantTable> {
  $$ProductVariantTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get productId => $state.composableBuilder(
      column: $state.table.productId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get sku => $state.composableBuilder(
      column: $state.table.sku,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get variation => $state.composableBuilder(
      column: $state.table.variation,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ProductVariantTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $ProductVariantTable> {
  $$ProductVariantTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get productId => $state.composableBuilder(
      column: $state.table.productId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get sku => $state.composableBuilder(
      column: $state.table.sku,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get variation => $state.composableBuilder(
      column: $state.table.variation,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ProjectTableInsertCompanionBuilder = ProjectCompanion Function({
  Value<String?> projectType,
  required String id,
  Value<String?> projectTypeId,
  Value<String?> projectNumber,
  Value<String?> subProjectTypeId,
  Value<bool?> isTaskEnabled,
  Value<String?> parent,
  required String name,
  Value<String?> department,
  Value<String?> description,
  Value<String?> referenceId,
  Value<String?> projectHierarchy,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<int?> startDate,
  Value<int?> endDate,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$ProjectTableUpdateCompanionBuilder = ProjectCompanion Function({
  Value<String?> projectType,
  Value<String> id,
  Value<String?> projectTypeId,
  Value<String?> projectNumber,
  Value<String?> subProjectTypeId,
  Value<bool?> isTaskEnabled,
  Value<String?> parent,
  Value<String> name,
  Value<String?> department,
  Value<String?> description,
  Value<String?> referenceId,
  Value<String?> projectHierarchy,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<int?> startDate,
  Value<int?> endDate,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$ProjectTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $ProjectTable,
    ProjectData,
    $$ProjectTableFilterComposer,
    $$ProjectTableOrderingComposer,
    $$ProjectTableProcessedTableManager,
    $$ProjectTableInsertCompanionBuilder,
    $$ProjectTableUpdateCompanionBuilder> {
  $$ProjectTableTableManager(_$LocalSqlDataStore db, $ProjectTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ProjectTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$ProjectTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) => $$ProjectTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> projectType = const Value.absent(),
            Value<String> id = const Value.absent(),
            Value<String?> projectTypeId = const Value.absent(),
            Value<String?> projectNumber = const Value.absent(),
            Value<String?> subProjectTypeId = const Value.absent(),
            Value<bool?> isTaskEnabled = const Value.absent(),
            Value<String?> parent = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> department = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<String?> projectHierarchy = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<int?> startDate = const Value.absent(),
            Value<int?> endDate = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectCompanion(
            projectType: projectType,
            id: id,
            projectTypeId: projectTypeId,
            projectNumber: projectNumber,
            subProjectTypeId: subProjectTypeId,
            isTaskEnabled: isTaskEnabled,
            parent: parent,
            name: name,
            department: department,
            description: description,
            referenceId: referenceId,
            projectHierarchy: projectHierarchy,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            startDate: startDate,
            endDate: endDate,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> projectType = const Value.absent(),
            required String id,
            Value<String?> projectTypeId = const Value.absent(),
            Value<String?> projectNumber = const Value.absent(),
            Value<String?> subProjectTypeId = const Value.absent(),
            Value<bool?> isTaskEnabled = const Value.absent(),
            Value<String?> parent = const Value.absent(),
            required String name,
            Value<String?> department = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<String?> projectHierarchy = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<int?> startDate = const Value.absent(),
            Value<int?> endDate = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectCompanion.insert(
            projectType: projectType,
            id: id,
            projectTypeId: projectTypeId,
            projectNumber: projectNumber,
            subProjectTypeId: subProjectTypeId,
            isTaskEnabled: isTaskEnabled,
            parent: parent,
            name: name,
            department: department,
            description: description,
            referenceId: referenceId,
            projectHierarchy: projectHierarchy,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            startDate: startDate,
            endDate: endDate,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$ProjectTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $ProjectTable,
    ProjectData,
    $$ProjectTableFilterComposer,
    $$ProjectTableOrderingComposer,
    $$ProjectTableProcessedTableManager,
    $$ProjectTableInsertCompanionBuilder,
    $$ProjectTableUpdateCompanionBuilder> {
  $$ProjectTableProcessedTableManager(super.$state);
}

class $$ProjectTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $ProjectTable> {
  $$ProjectTableFilterComposer(super.$state);
  ColumnFilters<String> get projectType => $state.composableBuilder(
      column: $state.table.projectType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectTypeId => $state.composableBuilder(
      column: $state.table.projectTypeId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectNumber => $state.composableBuilder(
      column: $state.table.projectNumber,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get subProjectTypeId => $state.composableBuilder(
      column: $state.table.subProjectTypeId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isTaskEnabled => $state.composableBuilder(
      column: $state.table.isTaskEnabled,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get parent => $state.composableBuilder(
      column: $state.table.parent,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get department => $state.composableBuilder(
      column: $state.table.department,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get description => $state.composableBuilder(
      column: $state.table.description,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectHierarchy => $state.composableBuilder(
      column: $state.table.projectHierarchy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get startDate => $state.composableBuilder(
      column: $state.table.startDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get endDate => $state.composableBuilder(
      column: $state.table.endDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ProjectTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $ProjectTable> {
  $$ProjectTableOrderingComposer(super.$state);
  ColumnOrderings<String> get projectType => $state.composableBuilder(
      column: $state.table.projectType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectTypeId => $state.composableBuilder(
      column: $state.table.projectTypeId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectNumber => $state.composableBuilder(
      column: $state.table.projectNumber,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get subProjectTypeId => $state.composableBuilder(
      column: $state.table.subProjectTypeId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isTaskEnabled => $state.composableBuilder(
      column: $state.table.isTaskEnabled,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get parent => $state.composableBuilder(
      column: $state.table.parent,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get department => $state.composableBuilder(
      column: $state.table.department,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get description => $state.composableBuilder(
      column: $state.table.description,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectHierarchy => $state.composableBuilder(
      column: $state.table.projectHierarchy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get startDate => $state.composableBuilder(
      column: $state.table.startDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get endDate => $state.composableBuilder(
      column: $state.table.endDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ProjectBeneficiaryTableInsertCompanionBuilder
    = ProjectBeneficiaryCompanion Function({
  Value<String?> id,
  Value<String?> projectId,
  Value<String?> beneficiaryId,
  Value<String?> tag,
  Value<String?> beneficiaryClientReferenceId,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  required int dateOfRegistration,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$ProjectBeneficiaryTableUpdateCompanionBuilder
    = ProjectBeneficiaryCompanion Function({
  Value<String?> id,
  Value<String?> projectId,
  Value<String?> beneficiaryId,
  Value<String?> tag,
  Value<String?> beneficiaryClientReferenceId,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<int> dateOfRegistration,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$ProjectBeneficiaryTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $ProjectBeneficiaryTable,
    ProjectBeneficiaryData,
    $$ProjectBeneficiaryTableFilterComposer,
    $$ProjectBeneficiaryTableOrderingComposer,
    $$ProjectBeneficiaryTableProcessedTableManager,
    $$ProjectBeneficiaryTableInsertCompanionBuilder,
    $$ProjectBeneficiaryTableUpdateCompanionBuilder> {
  $$ProjectBeneficiaryTableTableManager(
      _$LocalSqlDataStore db, $ProjectBeneficiaryTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ProjectBeneficiaryTableFilterComposer(ComposerState(db, table)),
          orderingComposer: $$ProjectBeneficiaryTableOrderingComposer(
              ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ProjectBeneficiaryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> beneficiaryId = const Value.absent(),
            Value<String?> tag = const Value.absent(),
            Value<String?> beneficiaryClientReferenceId = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<int> dateOfRegistration = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectBeneficiaryCompanion(
            id: id,
            projectId: projectId,
            beneficiaryId: beneficiaryId,
            tag: tag,
            beneficiaryClientReferenceId: beneficiaryClientReferenceId,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            dateOfRegistration: dateOfRegistration,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> beneficiaryId = const Value.absent(),
            Value<String?> tag = const Value.absent(),
            Value<String?> beneficiaryClientReferenceId = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            required int dateOfRegistration,
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectBeneficiaryCompanion.insert(
            id: id,
            projectId: projectId,
            beneficiaryId: beneficiaryId,
            tag: tag,
            beneficiaryClientReferenceId: beneficiaryClientReferenceId,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            dateOfRegistration: dateOfRegistration,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$ProjectBeneficiaryTableProcessedTableManager
    extends ProcessedTableManager<
        _$LocalSqlDataStore,
        $ProjectBeneficiaryTable,
        ProjectBeneficiaryData,
        $$ProjectBeneficiaryTableFilterComposer,
        $$ProjectBeneficiaryTableOrderingComposer,
        $$ProjectBeneficiaryTableProcessedTableManager,
        $$ProjectBeneficiaryTableInsertCompanionBuilder,
        $$ProjectBeneficiaryTableUpdateCompanionBuilder> {
  $$ProjectBeneficiaryTableProcessedTableManager(super.$state);
}

class $$ProjectBeneficiaryTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $ProjectBeneficiaryTable> {
  $$ProjectBeneficiaryTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get beneficiaryId => $state.composableBuilder(
      column: $state.table.beneficiaryId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tag => $state.composableBuilder(
      column: $state.table.tag,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get beneficiaryClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.beneficiaryClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get dateOfRegistration => $state.composableBuilder(
      column: $state.table.dateOfRegistration,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ProjectBeneficiaryTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $ProjectBeneficiaryTable> {
  $$ProjectBeneficiaryTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get beneficiaryId => $state.composableBuilder(
      column: $state.table.beneficiaryId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tag => $state.composableBuilder(
      column: $state.table.tag,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get beneficiaryClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.beneficiaryClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get dateOfRegistration => $state.composableBuilder(
      column: $state.table.dateOfRegistration,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ProjectFacilityTableInsertCompanionBuilder = ProjectFacilityCompanion
    Function({
  required String id,
  required String facilityId,
  required String projectId,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$ProjectFacilityTableUpdateCompanionBuilder = ProjectFacilityCompanion
    Function({
  Value<String> id,
  Value<String> facilityId,
  Value<String> projectId,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$ProjectFacilityTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $ProjectFacilityTable,
    ProjectFacilityData,
    $$ProjectFacilityTableFilterComposer,
    $$ProjectFacilityTableOrderingComposer,
    $$ProjectFacilityTableProcessedTableManager,
    $$ProjectFacilityTableInsertCompanionBuilder,
    $$ProjectFacilityTableUpdateCompanionBuilder> {
  $$ProjectFacilityTableTableManager(
      _$LocalSqlDataStore db, $ProjectFacilityTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ProjectFacilityTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$ProjectFacilityTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ProjectFacilityTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String> id = const Value.absent(),
            Value<String> facilityId = const Value.absent(),
            Value<String> projectId = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectFacilityCompanion(
            id: id,
            facilityId: facilityId,
            projectId: projectId,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String id,
            required String facilityId,
            required String projectId,
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectFacilityCompanion.insert(
            id: id,
            facilityId: facilityId,
            projectId: projectId,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$ProjectFacilityTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $ProjectFacilityTable,
    ProjectFacilityData,
    $$ProjectFacilityTableFilterComposer,
    $$ProjectFacilityTableOrderingComposer,
    $$ProjectFacilityTableProcessedTableManager,
    $$ProjectFacilityTableInsertCompanionBuilder,
    $$ProjectFacilityTableUpdateCompanionBuilder> {
  $$ProjectFacilityTableProcessedTableManager(super.$state);
}

class $$ProjectFacilityTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $ProjectFacilityTable> {
  $$ProjectFacilityTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get facilityId => $state.composableBuilder(
      column: $state.table.facilityId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ProjectFacilityTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $ProjectFacilityTable> {
  $$ProjectFacilityTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get facilityId => $state.composableBuilder(
      column: $state.table.facilityId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ProjectProductVariantTableInsertCompanionBuilder
    = ProjectProductVariantCompanion Function({
  required String productVariantId,
  Value<String?> type,
  Value<bool?> isBaseUnitVariant,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> name,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$ProjectProductVariantTableUpdateCompanionBuilder
    = ProjectProductVariantCompanion Function({
  Value<String> productVariantId,
  Value<String?> type,
  Value<bool?> isBaseUnitVariant,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> name,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$ProjectProductVariantTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $ProjectProductVariantTable,
    ProjectProductVariantData,
    $$ProjectProductVariantTableFilterComposer,
    $$ProjectProductVariantTableOrderingComposer,
    $$ProjectProductVariantTableProcessedTableManager,
    $$ProjectProductVariantTableInsertCompanionBuilder,
    $$ProjectProductVariantTableUpdateCompanionBuilder> {
  $$ProjectProductVariantTableTableManager(
      _$LocalSqlDataStore db, $ProjectProductVariantTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$ProjectProductVariantTableFilterComposer(
              ComposerState(db, table)),
          orderingComposer: $$ProjectProductVariantTableOrderingComposer(
              ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ProjectProductVariantTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String> productVariantId = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<bool?> isBaseUnitVariant = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectProductVariantCompanion(
            productVariantId: productVariantId,
            type: type,
            isBaseUnitVariant: isBaseUnitVariant,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            name: name,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String productVariantId,
            Value<String?> type = const Value.absent(),
            Value<bool?> isBaseUnitVariant = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectProductVariantCompanion.insert(
            productVariantId: productVariantId,
            type: type,
            isBaseUnitVariant: isBaseUnitVariant,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            name: name,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$ProjectProductVariantTableProcessedTableManager
    extends ProcessedTableManager<
        _$LocalSqlDataStore,
        $ProjectProductVariantTable,
        ProjectProductVariantData,
        $$ProjectProductVariantTableFilterComposer,
        $$ProjectProductVariantTableOrderingComposer,
        $$ProjectProductVariantTableProcessedTableManager,
        $$ProjectProductVariantTableInsertCompanionBuilder,
        $$ProjectProductVariantTableUpdateCompanionBuilder> {
  $$ProjectProductVariantTableProcessedTableManager(super.$state);
}

class $$ProjectProductVariantTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $ProjectProductVariantTable> {
  $$ProjectProductVariantTableFilterComposer(super.$state);
  ColumnFilters<String> get productVariantId => $state.composableBuilder(
      column: $state.table.productVariantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get type => $state.composableBuilder(
      column: $state.table.type,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isBaseUnitVariant => $state.composableBuilder(
      column: $state.table.isBaseUnitVariant,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ComposableFilter projectResourceRefs(
      ComposableFilter Function($$ProjectResourceTableFilterComposer f) f) {
    final $$ProjectResourceTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.productVariantId,
            referencedTable: $state.db.projectResource,
            getReferencedColumn: (t) => t.resource,
            builder: (joinBuilder, parentComposers) =>
                $$ProjectResourceTableFilterComposer(ComposerState($state.db,
                    $state.db.projectResource, joinBuilder, parentComposers)));
    return f(composer);
  }
}

class $$ProjectProductVariantTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $ProjectProductVariantTable> {
  $$ProjectProductVariantTableOrderingComposer(super.$state);
  ColumnOrderings<String> get productVariantId => $state.composableBuilder(
      column: $state.table.productVariantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get type => $state.composableBuilder(
      column: $state.table.type,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isBaseUnitVariant => $state.composableBuilder(
      column: $state.table.isBaseUnitVariant,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ProjectResourceTableInsertCompanionBuilder = ProjectResourceCompanion
    Function({
  Value<String?> id,
  Value<String?> projectId,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  required String resource,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$ProjectResourceTableUpdateCompanionBuilder = ProjectResourceCompanion
    Function({
  Value<String?> id,
  Value<String?> projectId,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String> resource,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$ProjectResourceTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $ProjectResourceTable,
    ProjectResourceData,
    $$ProjectResourceTableFilterComposer,
    $$ProjectResourceTableOrderingComposer,
    $$ProjectResourceTableProcessedTableManager,
    $$ProjectResourceTableInsertCompanionBuilder,
    $$ProjectResourceTableUpdateCompanionBuilder> {
  $$ProjectResourceTableTableManager(
      _$LocalSqlDataStore db, $ProjectResourceTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ProjectResourceTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$ProjectResourceTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ProjectResourceTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String> resource = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectResourceCompanion(
            id: id,
            projectId: projectId,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            resource: resource,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            required String resource,
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectResourceCompanion.insert(
            id: id,
            projectId: projectId,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            resource: resource,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$ProjectResourceTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $ProjectResourceTable,
    ProjectResourceData,
    $$ProjectResourceTableFilterComposer,
    $$ProjectResourceTableOrderingComposer,
    $$ProjectResourceTableProcessedTableManager,
    $$ProjectResourceTableInsertCompanionBuilder,
    $$ProjectResourceTableUpdateCompanionBuilder> {
  $$ProjectResourceTableProcessedTableManager(super.$state);
}

class $$ProjectResourceTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $ProjectResourceTable> {
  $$ProjectResourceTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  $$ProjectProductVariantTableFilterComposer get resource {
    final $$ProjectProductVariantTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.resource,
            referencedTable: $state.db.projectProductVariant,
            getReferencedColumn: (t) => t.productVariantId,
            builder: (joinBuilder, parentComposers) =>
                $$ProjectProductVariantTableFilterComposer(ComposerState(
                    $state.db,
                    $state.db.projectProductVariant,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }
}

class $$ProjectResourceTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $ProjectResourceTable> {
  $$ProjectResourceTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  $$ProjectProductVariantTableOrderingComposer get resource {
    final $$ProjectProductVariantTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.resource,
            referencedTable: $state.db.projectProductVariant,
            getReferencedColumn: (t) => t.productVariantId,
            builder: (joinBuilder, parentComposers) =>
                $$ProjectProductVariantTableOrderingComposer(ComposerState(
                    $state.db,
                    $state.db.projectProductVariant,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }
}

typedef $$ProjectStaffTableInsertCompanionBuilder = ProjectStaffCompanion
    Function({
  required String id,
  Value<String?> staffId,
  Value<String?> userId,
  Value<String?> projectId,
  Value<String?> channel,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<int?> startDate,
  Value<int?> endDate,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$ProjectStaffTableUpdateCompanionBuilder = ProjectStaffCompanion
    Function({
  Value<String> id,
  Value<String?> staffId,
  Value<String?> userId,
  Value<String?> projectId,
  Value<String?> channel,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<int?> startDate,
  Value<int?> endDate,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$ProjectStaffTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $ProjectStaffTable,
    ProjectStaffData,
    $$ProjectStaffTableFilterComposer,
    $$ProjectStaffTableOrderingComposer,
    $$ProjectStaffTableProcessedTableManager,
    $$ProjectStaffTableInsertCompanionBuilder,
    $$ProjectStaffTableUpdateCompanionBuilder> {
  $$ProjectStaffTableTableManager(
      _$LocalSqlDataStore db, $ProjectStaffTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ProjectStaffTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$ProjectStaffTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ProjectStaffTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String> id = const Value.absent(),
            Value<String?> staffId = const Value.absent(),
            Value<String?> userId = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> channel = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<int?> startDate = const Value.absent(),
            Value<int?> endDate = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectStaffCompanion(
            id: id,
            staffId: staffId,
            userId: userId,
            projectId: projectId,
            channel: channel,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            startDate: startDate,
            endDate: endDate,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String id,
            Value<String?> staffId = const Value.absent(),
            Value<String?> userId = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> channel = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<int?> startDate = const Value.absent(),
            Value<int?> endDate = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectStaffCompanion.insert(
            id: id,
            staffId: staffId,
            userId: userId,
            projectId: projectId,
            channel: channel,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            startDate: startDate,
            endDate: endDate,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$ProjectStaffTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $ProjectStaffTable,
    ProjectStaffData,
    $$ProjectStaffTableFilterComposer,
    $$ProjectStaffTableOrderingComposer,
    $$ProjectStaffTableProcessedTableManager,
    $$ProjectStaffTableInsertCompanionBuilder,
    $$ProjectStaffTableUpdateCompanionBuilder> {
  $$ProjectStaffTableProcessedTableManager(super.$state);
}

class $$ProjectStaffTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $ProjectStaffTable> {
  $$ProjectStaffTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get staffId => $state.composableBuilder(
      column: $state.table.staffId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get userId => $state.composableBuilder(
      column: $state.table.userId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get channel => $state.composableBuilder(
      column: $state.table.channel,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get startDate => $state.composableBuilder(
      column: $state.table.startDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get endDate => $state.composableBuilder(
      column: $state.table.endDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ProjectStaffTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $ProjectStaffTable> {
  $$ProjectStaffTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get staffId => $state.composableBuilder(
      column: $state.table.staffId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get userId => $state.composableBuilder(
      column: $state.table.userId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get channel => $state.composableBuilder(
      column: $state.table.channel,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get startDate => $state.composableBuilder(
      column: $state.table.startDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get endDate => $state.composableBuilder(
      column: $state.table.endDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ProjectTypeTableInsertCompanionBuilder = ProjectTypeCompanion
    Function({
  Value<String?> id,
  Value<String?> name,
  Value<String?> code,
  Value<String?> group,
  Value<BeneficiaryType?> beneficiaryType,
  Value<String?> eligibilityCriteria,
  Value<String?> taskProcedure,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$ProjectTypeTableUpdateCompanionBuilder = ProjectTypeCompanion
    Function({
  Value<String?> id,
  Value<String?> name,
  Value<String?> code,
  Value<String?> group,
  Value<BeneficiaryType?> beneficiaryType,
  Value<String?> eligibilityCriteria,
  Value<String?> taskProcedure,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$ProjectTypeTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $ProjectTypeTable,
    ProjectTypeData,
    $$ProjectTypeTableFilterComposer,
    $$ProjectTypeTableOrderingComposer,
    $$ProjectTypeTableProcessedTableManager,
    $$ProjectTypeTableInsertCompanionBuilder,
    $$ProjectTypeTableUpdateCompanionBuilder> {
  $$ProjectTypeTableTableManager(
      _$LocalSqlDataStore db, $ProjectTypeTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ProjectTypeTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$ProjectTypeTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ProjectTypeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String?> group = const Value.absent(),
            Value<BeneficiaryType?> beneficiaryType = const Value.absent(),
            Value<String?> eligibilityCriteria = const Value.absent(),
            Value<String?> taskProcedure = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectTypeCompanion(
            id: id,
            name: name,
            code: code,
            group: group,
            beneficiaryType: beneficiaryType,
            eligibilityCriteria: eligibilityCriteria,
            taskProcedure: taskProcedure,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String?> group = const Value.absent(),
            Value<BeneficiaryType?> beneficiaryType = const Value.absent(),
            Value<String?> eligibilityCriteria = const Value.absent(),
            Value<String?> taskProcedure = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ProjectTypeCompanion.insert(
            id: id,
            name: name,
            code: code,
            group: group,
            beneficiaryType: beneficiaryType,
            eligibilityCriteria: eligibilityCriteria,
            taskProcedure: taskProcedure,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$ProjectTypeTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $ProjectTypeTable,
    ProjectTypeData,
    $$ProjectTypeTableFilterComposer,
    $$ProjectTypeTableOrderingComposer,
    $$ProjectTypeTableProcessedTableManager,
    $$ProjectTypeTableInsertCompanionBuilder,
    $$ProjectTypeTableUpdateCompanionBuilder> {
  $$ProjectTypeTableProcessedTableManager(super.$state);
}

class $$ProjectTypeTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $ProjectTypeTable> {
  $$ProjectTypeTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get group => $state.composableBuilder(
      column: $state.table.group,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnWithTypeConverterFilters<BeneficiaryType?, BeneficiaryType, int>
      get beneficiaryType => $state.composableBuilder(
          column: $state.table.beneficiaryType,
          builder: (column, joinBuilders) => ColumnWithTypeConverterFilters(
              column,
              joinBuilders: joinBuilders));

  ColumnFilters<String> get eligibilityCriteria => $state.composableBuilder(
      column: $state.table.eligibilityCriteria,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get taskProcedure => $state.composableBuilder(
      column: $state.table.taskProcedure,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ProjectTypeTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $ProjectTypeTable> {
  $$ProjectTypeTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get group => $state.composableBuilder(
      column: $state.table.group,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get beneficiaryType => $state.composableBuilder(
      column: $state.table.beneficiaryType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get eligibilityCriteria => $state.composableBuilder(
      column: $state.table.eligibilityCriteria,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get taskProcedure => $state.composableBuilder(
      column: $state.table.taskProcedure,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$IndividualTableInsertCompanionBuilder = IndividualCompanion Function({
  Value<String?> id,
  Value<String?> individualId,
  Value<String?> userId,
  Value<String?> userUuid,
  Value<String?> dateOfBirth,
  Value<String?> mobileNumber,
  Value<String?> altContactNumber,
  Value<String?> email,
  Value<String?> fatherName,
  Value<String?> husbandName,
  Value<String?> photo,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<BloodGroup?> bloodGroup,
  Value<Gender?> gender,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$IndividualTableUpdateCompanionBuilder = IndividualCompanion Function({
  Value<String?> id,
  Value<String?> individualId,
  Value<String?> userId,
  Value<String?> userUuid,
  Value<String?> dateOfBirth,
  Value<String?> mobileNumber,
  Value<String?> altContactNumber,
  Value<String?> email,
  Value<String?> fatherName,
  Value<String?> husbandName,
  Value<String?> photo,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<BloodGroup?> bloodGroup,
  Value<Gender?> gender,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$IndividualTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $IndividualTable,
    IndividualData,
    $$IndividualTableFilterComposer,
    $$IndividualTableOrderingComposer,
    $$IndividualTableProcessedTableManager,
    $$IndividualTableInsertCompanionBuilder,
    $$IndividualTableUpdateCompanionBuilder> {
  $$IndividualTableTableManager(_$LocalSqlDataStore db, $IndividualTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$IndividualTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$IndividualTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$IndividualTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> individualId = const Value.absent(),
            Value<String?> userId = const Value.absent(),
            Value<String?> userUuid = const Value.absent(),
            Value<String?> dateOfBirth = const Value.absent(),
            Value<String?> mobileNumber = const Value.absent(),
            Value<String?> altContactNumber = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> fatherName = const Value.absent(),
            Value<String?> husbandName = const Value.absent(),
            Value<String?> photo = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<BloodGroup?> bloodGroup = const Value.absent(),
            Value<Gender?> gender = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              IndividualCompanion(
            id: id,
            individualId: individualId,
            userId: userId,
            userUuid: userUuid,
            dateOfBirth: dateOfBirth,
            mobileNumber: mobileNumber,
            altContactNumber: altContactNumber,
            email: email,
            fatherName: fatherName,
            husbandName: husbandName,
            photo: photo,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            bloodGroup: bloodGroup,
            gender: gender,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> individualId = const Value.absent(),
            Value<String?> userId = const Value.absent(),
            Value<String?> userUuid = const Value.absent(),
            Value<String?> dateOfBirth = const Value.absent(),
            Value<String?> mobileNumber = const Value.absent(),
            Value<String?> altContactNumber = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> fatherName = const Value.absent(),
            Value<String?> husbandName = const Value.absent(),
            Value<String?> photo = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<BloodGroup?> bloodGroup = const Value.absent(),
            Value<Gender?> gender = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              IndividualCompanion.insert(
            id: id,
            individualId: individualId,
            userId: userId,
            userUuid: userUuid,
            dateOfBirth: dateOfBirth,
            mobileNumber: mobileNumber,
            altContactNumber: altContactNumber,
            email: email,
            fatherName: fatherName,
            husbandName: husbandName,
            photo: photo,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            bloodGroup: bloodGroup,
            gender: gender,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$IndividualTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $IndividualTable,
    IndividualData,
    $$IndividualTableFilterComposer,
    $$IndividualTableOrderingComposer,
    $$IndividualTableProcessedTableManager,
    $$IndividualTableInsertCompanionBuilder,
    $$IndividualTableUpdateCompanionBuilder> {
  $$IndividualTableProcessedTableManager(super.$state);
}

class $$IndividualTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $IndividualTable> {
  $$IndividualTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get individualId => $state.composableBuilder(
      column: $state.table.individualId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get userId => $state.composableBuilder(
      column: $state.table.userId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get userUuid => $state.composableBuilder(
      column: $state.table.userUuid,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get dateOfBirth => $state.composableBuilder(
      column: $state.table.dateOfBirth,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get mobileNumber => $state.composableBuilder(
      column: $state.table.mobileNumber,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get altContactNumber => $state.composableBuilder(
      column: $state.table.altContactNumber,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get email => $state.composableBuilder(
      column: $state.table.email,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get fatherName => $state.composableBuilder(
      column: $state.table.fatherName,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get husbandName => $state.composableBuilder(
      column: $state.table.husbandName,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get photo => $state.composableBuilder(
      column: $state.table.photo,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnWithTypeConverterFilters<BloodGroup?, BloodGroup, int> get bloodGroup =>
      $state.composableBuilder(
          column: $state.table.bloodGroup,
          builder: (column, joinBuilders) => ColumnWithTypeConverterFilters(
              column,
              joinBuilders: joinBuilders));

  ColumnWithTypeConverterFilters<Gender?, Gender, int> get gender =>
      $state.composableBuilder(
          column: $state.table.gender,
          builder: (column, joinBuilders) => ColumnWithTypeConverterFilters(
              column,
              joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$IndividualTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $IndividualTable> {
  $$IndividualTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get individualId => $state.composableBuilder(
      column: $state.table.individualId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get userId => $state.composableBuilder(
      column: $state.table.userId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get userUuid => $state.composableBuilder(
      column: $state.table.userUuid,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get dateOfBirth => $state.composableBuilder(
      column: $state.table.dateOfBirth,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get mobileNumber => $state.composableBuilder(
      column: $state.table.mobileNumber,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get altContactNumber => $state.composableBuilder(
      column: $state.table.altContactNumber,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get email => $state.composableBuilder(
      column: $state.table.email,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get fatherName => $state.composableBuilder(
      column: $state.table.fatherName,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get husbandName => $state.composableBuilder(
      column: $state.table.husbandName,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get photo => $state.composableBuilder(
      column: $state.table.photo,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get bloodGroup => $state.composableBuilder(
      column: $state.table.bloodGroup,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get gender => $state.composableBuilder(
      column: $state.table.gender,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$IdentifierTableInsertCompanionBuilder = IdentifierCompanion Function({
  Value<String?> id,
  Value<String?> individualId,
  required String individualClientReferenceId,
  Value<String?> identifierType,
  Value<String?> identifierId,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$IdentifierTableUpdateCompanionBuilder = IdentifierCompanion Function({
  Value<String?> id,
  Value<String?> individualId,
  Value<String> individualClientReferenceId,
  Value<String?> identifierType,
  Value<String?> identifierId,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$IdentifierTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $IdentifierTable,
    IdentifierData,
    $$IdentifierTableFilterComposer,
    $$IdentifierTableOrderingComposer,
    $$IdentifierTableProcessedTableManager,
    $$IdentifierTableInsertCompanionBuilder,
    $$IdentifierTableUpdateCompanionBuilder> {
  $$IdentifierTableTableManager(_$LocalSqlDataStore db, $IdentifierTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$IdentifierTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$IdentifierTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$IdentifierTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> individualId = const Value.absent(),
            Value<String> individualClientReferenceId = const Value.absent(),
            Value<String?> identifierType = const Value.absent(),
            Value<String?> identifierId = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              IdentifierCompanion(
            id: id,
            individualId: individualId,
            individualClientReferenceId: individualClientReferenceId,
            identifierType: identifierType,
            identifierId: identifierId,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> individualId = const Value.absent(),
            required String individualClientReferenceId,
            Value<String?> identifierType = const Value.absent(),
            Value<String?> identifierId = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              IdentifierCompanion.insert(
            id: id,
            individualId: individualId,
            individualClientReferenceId: individualClientReferenceId,
            identifierType: identifierType,
            identifierId: identifierId,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$IdentifierTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $IdentifierTable,
    IdentifierData,
    $$IdentifierTableFilterComposer,
    $$IdentifierTableOrderingComposer,
    $$IdentifierTableProcessedTableManager,
    $$IdentifierTableInsertCompanionBuilder,
    $$IdentifierTableUpdateCompanionBuilder> {
  $$IdentifierTableProcessedTableManager(super.$state);
}

class $$IdentifierTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $IdentifierTable> {
  $$IdentifierTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get individualId => $state.composableBuilder(
      column: $state.table.individualId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get individualClientReferenceId => $state
      .composableBuilder(
          column: $state.table.individualClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get identifierType => $state.composableBuilder(
      column: $state.table.identifierType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get identifierId => $state.composableBuilder(
      column: $state.table.identifierId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$IdentifierTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $IdentifierTable> {
  $$IdentifierTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get individualId => $state.composableBuilder(
      column: $state.table.individualId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get individualClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.individualClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get identifierType => $state.composableBuilder(
      column: $state.table.identifierType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get identifierId => $state.composableBuilder(
      column: $state.table.identifierId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$StockTableInsertCompanionBuilder = StockCompanion Function({
  Value<String?> id,
  Value<String?> tenantId,
  Value<String?> facilityId,
  Value<String?> productVariantId,
  Value<String?> referenceId,
  Value<String?> referenceIdType,
  Value<String?> transactingPartyId,
  Value<String?> transactingPartyType,
  Value<String?> quantity,
  Value<String?> waybillNumber,
  Value<String?> receiverId,
  Value<String?> receiverType,
  Value<String?> senderId,
  Value<String?> senderType,
  Value<int?> dateOfEntry,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> transactionType,
  Value<String?> transactionReason,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$StockTableUpdateCompanionBuilder = StockCompanion Function({
  Value<String?> id,
  Value<String?> tenantId,
  Value<String?> facilityId,
  Value<String?> productVariantId,
  Value<String?> referenceId,
  Value<String?> referenceIdType,
  Value<String?> transactingPartyId,
  Value<String?> transactingPartyType,
  Value<String?> quantity,
  Value<String?> waybillNumber,
  Value<String?> receiverId,
  Value<String?> receiverType,
  Value<String?> senderId,
  Value<String?> senderType,
  Value<int?> dateOfEntry,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> transactionType,
  Value<String?> transactionReason,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$StockTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $StockTable,
    StockData,
    $$StockTableFilterComposer,
    $$StockTableOrderingComposer,
    $$StockTableProcessedTableManager,
    $$StockTableInsertCompanionBuilder,
    $$StockTableUpdateCompanionBuilder> {
  $$StockTableTableManager(_$LocalSqlDataStore db, $StockTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$StockTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$StockTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) => $$StockTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> facilityId = const Value.absent(),
            Value<String?> productVariantId = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<String?> referenceIdType = const Value.absent(),
            Value<String?> transactingPartyId = const Value.absent(),
            Value<String?> transactingPartyType = const Value.absent(),
            Value<String?> quantity = const Value.absent(),
            Value<String?> waybillNumber = const Value.absent(),
            Value<String?> receiverId = const Value.absent(),
            Value<String?> receiverType = const Value.absent(),
            Value<String?> senderId = const Value.absent(),
            Value<String?> senderType = const Value.absent(),
            Value<int?> dateOfEntry = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> transactionType = const Value.absent(),
            Value<String?> transactionReason = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              StockCompanion(
            id: id,
            tenantId: tenantId,
            facilityId: facilityId,
            productVariantId: productVariantId,
            referenceId: referenceId,
            referenceIdType: referenceIdType,
            transactingPartyId: transactingPartyId,
            transactingPartyType: transactingPartyType,
            quantity: quantity,
            waybillNumber: waybillNumber,
            receiverId: receiverId,
            receiverType: receiverType,
            senderId: senderId,
            senderType: senderType,
            dateOfEntry: dateOfEntry,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            transactionType: transactionType,
            transactionReason: transactionReason,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> facilityId = const Value.absent(),
            Value<String?> productVariantId = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<String?> referenceIdType = const Value.absent(),
            Value<String?> transactingPartyId = const Value.absent(),
            Value<String?> transactingPartyType = const Value.absent(),
            Value<String?> quantity = const Value.absent(),
            Value<String?> waybillNumber = const Value.absent(),
            Value<String?> receiverId = const Value.absent(),
            Value<String?> receiverType = const Value.absent(),
            Value<String?> senderId = const Value.absent(),
            Value<String?> senderType = const Value.absent(),
            Value<int?> dateOfEntry = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> transactionType = const Value.absent(),
            Value<String?> transactionReason = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              StockCompanion.insert(
            id: id,
            tenantId: tenantId,
            facilityId: facilityId,
            productVariantId: productVariantId,
            referenceId: referenceId,
            referenceIdType: referenceIdType,
            transactingPartyId: transactingPartyId,
            transactingPartyType: transactingPartyType,
            quantity: quantity,
            waybillNumber: waybillNumber,
            receiverId: receiverId,
            receiverType: receiverType,
            senderId: senderId,
            senderType: senderType,
            dateOfEntry: dateOfEntry,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            transactionType: transactionType,
            transactionReason: transactionReason,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$StockTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $StockTable,
    StockData,
    $$StockTableFilterComposer,
    $$StockTableOrderingComposer,
    $$StockTableProcessedTableManager,
    $$StockTableInsertCompanionBuilder,
    $$StockTableUpdateCompanionBuilder> {
  $$StockTableProcessedTableManager(super.$state);
}

class $$StockTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $StockTable> {
  $$StockTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get facilityId => $state.composableBuilder(
      column: $state.table.facilityId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get productVariantId => $state.composableBuilder(
      column: $state.table.productVariantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get referenceIdType => $state.composableBuilder(
      column: $state.table.referenceIdType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get transactingPartyId => $state.composableBuilder(
      column: $state.table.transactingPartyId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get transactingPartyType => $state.composableBuilder(
      column: $state.table.transactingPartyType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get quantity => $state.composableBuilder(
      column: $state.table.quantity,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get waybillNumber => $state.composableBuilder(
      column: $state.table.waybillNumber,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get receiverId => $state.composableBuilder(
      column: $state.table.receiverId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get receiverType => $state.composableBuilder(
      column: $state.table.receiverType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get senderId => $state.composableBuilder(
      column: $state.table.senderId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get senderType => $state.composableBuilder(
      column: $state.table.senderType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get dateOfEntry => $state.composableBuilder(
      column: $state.table.dateOfEntry,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get transactionType => $state.composableBuilder(
      column: $state.table.transactionType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get transactionReason => $state.composableBuilder(
      column: $state.table.transactionReason,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$StockTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $StockTable> {
  $$StockTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get facilityId => $state.composableBuilder(
      column: $state.table.facilityId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get productVariantId => $state.composableBuilder(
      column: $state.table.productVariantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get referenceIdType => $state.composableBuilder(
      column: $state.table.referenceIdType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get transactingPartyId => $state.composableBuilder(
      column: $state.table.transactingPartyId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get transactingPartyType => $state.composableBuilder(
      column: $state.table.transactingPartyType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get quantity => $state.composableBuilder(
      column: $state.table.quantity,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get waybillNumber => $state.composableBuilder(
      column: $state.table.waybillNumber,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get receiverId => $state.composableBuilder(
      column: $state.table.receiverId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get receiverType => $state.composableBuilder(
      column: $state.table.receiverType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get senderId => $state.composableBuilder(
      column: $state.table.senderId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get senderType => $state.composableBuilder(
      column: $state.table.senderType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get dateOfEntry => $state.composableBuilder(
      column: $state.table.dateOfEntry,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get transactionType => $state.composableBuilder(
      column: $state.table.transactionType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get transactionReason => $state.composableBuilder(
      column: $state.table.transactionReason,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$StockReconciliationTableInsertCompanionBuilder
    = StockReconciliationCompanion Function({
  Value<String?> id,
  Value<String?> tenantId,
  Value<String?> facilityId,
  Value<String?> productVariantId,
  Value<String?> referenceId,
  Value<String?> referenceIdType,
  Value<int?> physicalCount,
  Value<int?> calculatedCount,
  Value<String?> commentsOnReconciliation,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  required int dateOfReconciliation,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$StockReconciliationTableUpdateCompanionBuilder
    = StockReconciliationCompanion Function({
  Value<String?> id,
  Value<String?> tenantId,
  Value<String?> facilityId,
  Value<String?> productVariantId,
  Value<String?> referenceId,
  Value<String?> referenceIdType,
  Value<int?> physicalCount,
  Value<int?> calculatedCount,
  Value<String?> commentsOnReconciliation,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<int> dateOfReconciliation,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$StockReconciliationTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $StockReconciliationTable,
    StockReconciliationData,
    $$StockReconciliationTableFilterComposer,
    $$StockReconciliationTableOrderingComposer,
    $$StockReconciliationTableProcessedTableManager,
    $$StockReconciliationTableInsertCompanionBuilder,
    $$StockReconciliationTableUpdateCompanionBuilder> {
  $$StockReconciliationTableTableManager(
      _$LocalSqlDataStore db, $StockReconciliationTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$StockReconciliationTableFilterComposer(
              ComposerState(db, table)),
          orderingComposer: $$StockReconciliationTableOrderingComposer(
              ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$StockReconciliationTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> facilityId = const Value.absent(),
            Value<String?> productVariantId = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<String?> referenceIdType = const Value.absent(),
            Value<int?> physicalCount = const Value.absent(),
            Value<int?> calculatedCount = const Value.absent(),
            Value<String?> commentsOnReconciliation = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<int> dateOfReconciliation = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              StockReconciliationCompanion(
            id: id,
            tenantId: tenantId,
            facilityId: facilityId,
            productVariantId: productVariantId,
            referenceId: referenceId,
            referenceIdType: referenceIdType,
            physicalCount: physicalCount,
            calculatedCount: calculatedCount,
            commentsOnReconciliation: commentsOnReconciliation,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            dateOfReconciliation: dateOfReconciliation,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> facilityId = const Value.absent(),
            Value<String?> productVariantId = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<String?> referenceIdType = const Value.absent(),
            Value<int?> physicalCount = const Value.absent(),
            Value<int?> calculatedCount = const Value.absent(),
            Value<String?> commentsOnReconciliation = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            required int dateOfReconciliation,
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              StockReconciliationCompanion.insert(
            id: id,
            tenantId: tenantId,
            facilityId: facilityId,
            productVariantId: productVariantId,
            referenceId: referenceId,
            referenceIdType: referenceIdType,
            physicalCount: physicalCount,
            calculatedCount: calculatedCount,
            commentsOnReconciliation: commentsOnReconciliation,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            dateOfReconciliation: dateOfReconciliation,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$StockReconciliationTableProcessedTableManager
    extends ProcessedTableManager<
        _$LocalSqlDataStore,
        $StockReconciliationTable,
        StockReconciliationData,
        $$StockReconciliationTableFilterComposer,
        $$StockReconciliationTableOrderingComposer,
        $$StockReconciliationTableProcessedTableManager,
        $$StockReconciliationTableInsertCompanionBuilder,
        $$StockReconciliationTableUpdateCompanionBuilder> {
  $$StockReconciliationTableProcessedTableManager(super.$state);
}

class $$StockReconciliationTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $StockReconciliationTable> {
  $$StockReconciliationTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get facilityId => $state.composableBuilder(
      column: $state.table.facilityId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get productVariantId => $state.composableBuilder(
      column: $state.table.productVariantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get referenceIdType => $state.composableBuilder(
      column: $state.table.referenceIdType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get physicalCount => $state.composableBuilder(
      column: $state.table.physicalCount,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get calculatedCount => $state.composableBuilder(
      column: $state.table.calculatedCount,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get commentsOnReconciliation =>
      $state.composableBuilder(
          column: $state.table.commentsOnReconciliation,
          builder: (column, joinBuilders) =>
              ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get dateOfReconciliation => $state.composableBuilder(
      column: $state.table.dateOfReconciliation,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$StockReconciliationTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $StockReconciliationTable> {
  $$StockReconciliationTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get facilityId => $state.composableBuilder(
      column: $state.table.facilityId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get productVariantId => $state.composableBuilder(
      column: $state.table.productVariantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get referenceIdType => $state.composableBuilder(
      column: $state.table.referenceIdType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get physicalCount => $state.composableBuilder(
      column: $state.table.physicalCount,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get calculatedCount => $state.composableBuilder(
      column: $state.table.calculatedCount,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get commentsOnReconciliation =>
      $state.composableBuilder(
          column: $state.table.commentsOnReconciliation,
          builder: (column, joinBuilders) =>
              ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get dateOfReconciliation => $state.composableBuilder(
      column: $state.table.dateOfReconciliation,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$TargetTableInsertCompanionBuilder = TargetCompanion Function({
  required String id,
  Value<String?> clientReferenceId,
  Value<double?> totalNo,
  Value<double?> targetNo,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> beneficiaryType,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$TargetTableUpdateCompanionBuilder = TargetCompanion Function({
  Value<String> id,
  Value<String?> clientReferenceId,
  Value<double?> totalNo,
  Value<double?> targetNo,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> beneficiaryType,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$TargetTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $TargetTable,
    TargetData,
    $$TargetTableFilterComposer,
    $$TargetTableOrderingComposer,
    $$TargetTableProcessedTableManager,
    $$TargetTableInsertCompanionBuilder,
    $$TargetTableUpdateCompanionBuilder> {
  $$TargetTableTableManager(_$LocalSqlDataStore db, $TargetTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$TargetTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$TargetTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) => $$TargetTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String> id = const Value.absent(),
            Value<String?> clientReferenceId = const Value.absent(),
            Value<double?> totalNo = const Value.absent(),
            Value<double?> targetNo = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> beneficiaryType = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TargetCompanion(
            id: id,
            clientReferenceId: clientReferenceId,
            totalNo: totalNo,
            targetNo: targetNo,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            beneficiaryType: beneficiaryType,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String id,
            Value<String?> clientReferenceId = const Value.absent(),
            Value<double?> totalNo = const Value.absent(),
            Value<double?> targetNo = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> beneficiaryType = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TargetCompanion.insert(
            id: id,
            clientReferenceId: clientReferenceId,
            totalNo: totalNo,
            targetNo: targetNo,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            beneficiaryType: beneficiaryType,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$TargetTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $TargetTable,
    TargetData,
    $$TargetTableFilterComposer,
    $$TargetTableOrderingComposer,
    $$TargetTableProcessedTableManager,
    $$TargetTableInsertCompanionBuilder,
    $$TargetTableUpdateCompanionBuilder> {
  $$TargetTableProcessedTableManager(super.$state);
}

class $$TargetTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $TargetTable> {
  $$TargetTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<double> get totalNo => $state.composableBuilder(
      column: $state.table.totalNo,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<double> get targetNo => $state.composableBuilder(
      column: $state.table.targetNo,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get beneficiaryType => $state.composableBuilder(
      column: $state.table.beneficiaryType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$TargetTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $TargetTable> {
  $$TargetTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<double> get totalNo => $state.composableBuilder(
      column: $state.table.totalNo,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<double> get targetNo => $state.composableBuilder(
      column: $state.table.targetNo,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get beneficiaryType => $state.composableBuilder(
      column: $state.table.beneficiaryType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ServiceTableInsertCompanionBuilder = ServiceCompanion Function({
  Value<String?> id,
  required String clientId,
  Value<String?> serviceDefId,
  Value<String?> referenceId,
  Value<bool?> isActive,
  Value<String?> accountId,
  Value<String?> additionalDetails,
  Value<String?> createdAt,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$ServiceTableUpdateCompanionBuilder = ServiceCompanion Function({
  Value<String?> id,
  Value<String> clientId,
  Value<String?> serviceDefId,
  Value<String?> referenceId,
  Value<bool?> isActive,
  Value<String?> accountId,
  Value<String?> additionalDetails,
  Value<String?> createdAt,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$ServiceTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $ServiceTable,
    ServiceData,
    $$ServiceTableFilterComposer,
    $$ServiceTableOrderingComposer,
    $$ServiceTableProcessedTableManager,
    $$ServiceTableInsertCompanionBuilder,
    $$ServiceTableUpdateCompanionBuilder> {
  $$ServiceTableTableManager(_$LocalSqlDataStore db, $ServiceTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ServiceTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$ServiceTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) => $$ServiceTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String> clientId = const Value.absent(),
            Value<String?> serviceDefId = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<bool?> isActive = const Value.absent(),
            Value<String?> accountId = const Value.absent(),
            Value<String?> additionalDetails = const Value.absent(),
            Value<String?> createdAt = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ServiceCompanion(
            id: id,
            clientId: clientId,
            serviceDefId: serviceDefId,
            referenceId: referenceId,
            isActive: isActive,
            accountId: accountId,
            additionalDetails: additionalDetails,
            createdAt: createdAt,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            required String clientId,
            Value<String?> serviceDefId = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<bool?> isActive = const Value.absent(),
            Value<String?> accountId = const Value.absent(),
            Value<String?> additionalDetails = const Value.absent(),
            Value<String?> createdAt = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ServiceCompanion.insert(
            id: id,
            clientId: clientId,
            serviceDefId: serviceDefId,
            referenceId: referenceId,
            isActive: isActive,
            accountId: accountId,
            additionalDetails: additionalDetails,
            createdAt: createdAt,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$ServiceTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $ServiceTable,
    ServiceData,
    $$ServiceTableFilterComposer,
    $$ServiceTableOrderingComposer,
    $$ServiceTableProcessedTableManager,
    $$ServiceTableInsertCompanionBuilder,
    $$ServiceTableUpdateCompanionBuilder> {
  $$ServiceTableProcessedTableManager(super.$state);
}

class $$ServiceTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $ServiceTable> {
  $$ServiceTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientId => $state.composableBuilder(
      column: $state.table.clientId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get serviceDefId => $state.composableBuilder(
      column: $state.table.serviceDefId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isActive => $state.composableBuilder(
      column: $state.table.isActive,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get accountId => $state.composableBuilder(
      column: $state.table.accountId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalDetails => $state.composableBuilder(
      column: $state.table.additionalDetails,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get createdAt => $state.composableBuilder(
      column: $state.table.createdAt,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ServiceTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $ServiceTable> {
  $$ServiceTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientId => $state.composableBuilder(
      column: $state.table.clientId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get serviceDefId => $state.composableBuilder(
      column: $state.table.serviceDefId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isActive => $state.composableBuilder(
      column: $state.table.isActive,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get accountId => $state.composableBuilder(
      column: $state.table.accountId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalDetails => $state.composableBuilder(
      column: $state.table.additionalDetails,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get createdAt => $state.composableBuilder(
      column: $state.table.createdAt,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ServiceAttributesTableInsertCompanionBuilder
    = ServiceAttributesCompanion Function({
  Value<String?> id,
  Value<String?> attributeCode,
  Value<String?> value,
  Value<String?> dataType,
  Value<String?> referenceId,
  Value<String?> additionalDetails,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> clientReferenceId,
  Value<String?> serviceClientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$ServiceAttributesTableUpdateCompanionBuilder
    = ServiceAttributesCompanion Function({
  Value<String?> id,
  Value<String?> attributeCode,
  Value<String?> value,
  Value<String?> dataType,
  Value<String?> referenceId,
  Value<String?> additionalDetails,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> clientReferenceId,
  Value<String?> serviceClientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$ServiceAttributesTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $ServiceAttributesTable,
    ServiceAttribute,
    $$ServiceAttributesTableFilterComposer,
    $$ServiceAttributesTableOrderingComposer,
    $$ServiceAttributesTableProcessedTableManager,
    $$ServiceAttributesTableInsertCompanionBuilder,
    $$ServiceAttributesTableUpdateCompanionBuilder> {
  $$ServiceAttributesTableTableManager(
      _$LocalSqlDataStore db, $ServiceAttributesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ServiceAttributesTableFilterComposer(ComposerState(db, table)),
          orderingComposer: $$ServiceAttributesTableOrderingComposer(
              ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ServiceAttributesTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> attributeCode = const Value.absent(),
            Value<String?> value = const Value.absent(),
            Value<String?> dataType = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<String?> additionalDetails = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> clientReferenceId = const Value.absent(),
            Value<String?> serviceClientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ServiceAttributesCompanion(
            id: id,
            attributeCode: attributeCode,
            value: value,
            dataType: dataType,
            referenceId: referenceId,
            additionalDetails: additionalDetails,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            serviceClientReferenceId: serviceClientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> attributeCode = const Value.absent(),
            Value<String?> value = const Value.absent(),
            Value<String?> dataType = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<String?> additionalDetails = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> clientReferenceId = const Value.absent(),
            Value<String?> serviceClientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ServiceAttributesCompanion.insert(
            id: id,
            attributeCode: attributeCode,
            value: value,
            dataType: dataType,
            referenceId: referenceId,
            additionalDetails: additionalDetails,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            serviceClientReferenceId: serviceClientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$ServiceAttributesTableProcessedTableManager
    extends ProcessedTableManager<
        _$LocalSqlDataStore,
        $ServiceAttributesTable,
        ServiceAttribute,
        $$ServiceAttributesTableFilterComposer,
        $$ServiceAttributesTableOrderingComposer,
        $$ServiceAttributesTableProcessedTableManager,
        $$ServiceAttributesTableInsertCompanionBuilder,
        $$ServiceAttributesTableUpdateCompanionBuilder> {
  $$ServiceAttributesTableProcessedTableManager(super.$state);
}

class $$ServiceAttributesTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $ServiceAttributesTable> {
  $$ServiceAttributesTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get attributeCode => $state.composableBuilder(
      column: $state.table.attributeCode,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get value => $state.composableBuilder(
      column: $state.table.value,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get dataType => $state.composableBuilder(
      column: $state.table.dataType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalDetails => $state.composableBuilder(
      column: $state.table.additionalDetails,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get serviceClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.serviceClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ServiceAttributesTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $ServiceAttributesTable> {
  $$ServiceAttributesTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get attributeCode => $state.composableBuilder(
      column: $state.table.attributeCode,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get value => $state.composableBuilder(
      column: $state.table.value,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get dataType => $state.composableBuilder(
      column: $state.table.dataType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalDetails => $state.composableBuilder(
      column: $state.table.additionalDetails,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get serviceClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.serviceClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ServiceDefinitionTableInsertCompanionBuilder
    = ServiceDefinitionCompanion Function({
  Value<String?> id,
  Value<String?> tenantId,
  Value<String?> code,
  Value<bool?> isActive,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$ServiceDefinitionTableUpdateCompanionBuilder
    = ServiceDefinitionCompanion Function({
  Value<String?> id,
  Value<String?> tenantId,
  Value<String?> code,
  Value<bool?> isActive,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$ServiceDefinitionTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $ServiceDefinitionTable,
    ServiceDefinitionData,
    $$ServiceDefinitionTableFilterComposer,
    $$ServiceDefinitionTableOrderingComposer,
    $$ServiceDefinitionTableProcessedTableManager,
    $$ServiceDefinitionTableInsertCompanionBuilder,
    $$ServiceDefinitionTableUpdateCompanionBuilder> {
  $$ServiceDefinitionTableTableManager(
      _$LocalSqlDataStore db, $ServiceDefinitionTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ServiceDefinitionTableFilterComposer(ComposerState(db, table)),
          orderingComposer: $$ServiceDefinitionTableOrderingComposer(
              ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ServiceDefinitionTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<bool?> isActive = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ServiceDefinitionCompanion(
            id: id,
            tenantId: tenantId,
            code: code,
            isActive: isActive,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<bool?> isActive = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ServiceDefinitionCompanion.insert(
            id: id,
            tenantId: tenantId,
            code: code,
            isActive: isActive,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$ServiceDefinitionTableProcessedTableManager
    extends ProcessedTableManager<
        _$LocalSqlDataStore,
        $ServiceDefinitionTable,
        ServiceDefinitionData,
        $$ServiceDefinitionTableFilterComposer,
        $$ServiceDefinitionTableOrderingComposer,
        $$ServiceDefinitionTableProcessedTableManager,
        $$ServiceDefinitionTableInsertCompanionBuilder,
        $$ServiceDefinitionTableUpdateCompanionBuilder> {
  $$ServiceDefinitionTableProcessedTableManager(super.$state);
}

class $$ServiceDefinitionTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $ServiceDefinitionTable> {
  $$ServiceDefinitionTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isActive => $state.composableBuilder(
      column: $state.table.isActive,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ServiceDefinitionTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $ServiceDefinitionTable> {
  $$ServiceDefinitionTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isActive => $state.composableBuilder(
      column: $state.table.isActive,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LocalityTableInsertCompanionBuilder = LocalityCompanion Function({
  required String code,
  Value<String?> name,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$LocalityTableUpdateCompanionBuilder = LocalityCompanion Function({
  Value<String> code,
  Value<String?> name,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$LocalityTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $LocalityTable,
    LocalityData,
    $$LocalityTableFilterComposer,
    $$LocalityTableOrderingComposer,
    $$LocalityTableProcessedTableManager,
    $$LocalityTableInsertCompanionBuilder,
    $$LocalityTableUpdateCompanionBuilder> {
  $$LocalityTableTableManager(_$LocalSqlDataStore db, $LocalityTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LocalityTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$LocalityTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LocalityTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String> code = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              LocalityCompanion(
            code: code,
            name: name,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            Value<String?> name = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              LocalityCompanion.insert(
            code: code,
            name: name,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$LocalityTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $LocalityTable,
    LocalityData,
    $$LocalityTableFilterComposer,
    $$LocalityTableOrderingComposer,
    $$LocalityTableProcessedTableManager,
    $$LocalityTableInsertCompanionBuilder,
    $$LocalityTableUpdateCompanionBuilder> {
  $$LocalityTableProcessedTableManager(super.$state);
}

class $$LocalityTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $LocalityTable> {
  $$LocalityTableFilterComposer(super.$state);
  ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LocalityTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $LocalityTable> {
  $$LocalityTableOrderingComposer(super.$state);
  ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$StaffTableInsertCompanionBuilder = StaffCompanion Function({
  Value<String?> id,
  required String tenantId,
  required String registerId,
  required String userId,
  Value<int?> enrollmentDate,
  Value<int?> denrollmentDate,
  Value<int> rowid,
});
typedef $$StaffTableUpdateCompanionBuilder = StaffCompanion Function({
  Value<String?> id,
  Value<String> tenantId,
  Value<String> registerId,
  Value<String> userId,
  Value<int?> enrollmentDate,
  Value<int?> denrollmentDate,
  Value<int> rowid,
});

class $$StaffTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $StaffTable,
    StaffData,
    $$StaffTableFilterComposer,
    $$StaffTableOrderingComposer,
    $$StaffTableProcessedTableManager,
    $$StaffTableInsertCompanionBuilder,
    $$StaffTableUpdateCompanionBuilder> {
  $$StaffTableTableManager(_$LocalSqlDataStore db, $StaffTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$StaffTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$StaffTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) => $$StaffTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String> tenantId = const Value.absent(),
            Value<String> registerId = const Value.absent(),
            Value<String> userId = const Value.absent(),
            Value<int?> enrollmentDate = const Value.absent(),
            Value<int?> denrollmentDate = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              StaffCompanion(
            id: id,
            tenantId: tenantId,
            registerId: registerId,
            userId: userId,
            enrollmentDate: enrollmentDate,
            denrollmentDate: denrollmentDate,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            required String tenantId,
            required String registerId,
            required String userId,
            Value<int?> enrollmentDate = const Value.absent(),
            Value<int?> denrollmentDate = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              StaffCompanion.insert(
            id: id,
            tenantId: tenantId,
            registerId: registerId,
            userId: userId,
            enrollmentDate: enrollmentDate,
            denrollmentDate: denrollmentDate,
            rowid: rowid,
          ),
        ));
}

class $$StaffTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $StaffTable,
    StaffData,
    $$StaffTableFilterComposer,
    $$StaffTableOrderingComposer,
    $$StaffTableProcessedTableManager,
    $$StaffTableInsertCompanionBuilder,
    $$StaffTableUpdateCompanionBuilder> {
  $$StaffTableProcessedTableManager(super.$state);
}

class $$StaffTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $StaffTable> {
  $$StaffTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get registerId => $state.composableBuilder(
      column: $state.table.registerId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get userId => $state.composableBuilder(
      column: $state.table.userId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get enrollmentDate => $state.composableBuilder(
      column: $state.table.enrollmentDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get denrollmentDate => $state.composableBuilder(
      column: $state.table.denrollmentDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$StaffTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $StaffTable> {
  $$StaffTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get registerId => $state.composableBuilder(
      column: $state.table.registerId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get userId => $state.composableBuilder(
      column: $state.table.userId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get enrollmentDate => $state.composableBuilder(
      column: $state.table.enrollmentDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get denrollmentDate => $state.composableBuilder(
      column: $state.table.denrollmentDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$AttributesTableInsertCompanionBuilder = AttributesCompanion Function({
  Value<String?> id,
  Value<String?> dataType,
  Value<String?> referenceId,
  Value<String?> tenantId,
  Value<String?> code,
  Value<String?> values,
  Value<bool?> isActive,
  Value<bool?> required,
  Value<String?> regex,
  Value<int?> order,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalDetails,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$AttributesTableUpdateCompanionBuilder = AttributesCompanion Function({
  Value<String?> id,
  Value<String?> dataType,
  Value<String?> referenceId,
  Value<String?> tenantId,
  Value<String?> code,
  Value<String?> values,
  Value<bool?> isActive,
  Value<bool?> required,
  Value<String?> regex,
  Value<int?> order,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalDetails,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$AttributesTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $AttributesTable,
    Attribute,
    $$AttributesTableFilterComposer,
    $$AttributesTableOrderingComposer,
    $$AttributesTableProcessedTableManager,
    $$AttributesTableInsertCompanionBuilder,
    $$AttributesTableUpdateCompanionBuilder> {
  $$AttributesTableTableManager(_$LocalSqlDataStore db, $AttributesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$AttributesTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$AttributesTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$AttributesTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> dataType = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String?> values = const Value.absent(),
            Value<bool?> isActive = const Value.absent(),
            Value<bool?> required = const Value.absent(),
            Value<String?> regex = const Value.absent(),
            Value<int?> order = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalDetails = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AttributesCompanion(
            id: id,
            dataType: dataType,
            referenceId: referenceId,
            tenantId: tenantId,
            code: code,
            values: values,
            isActive: isActive,
            required: required,
            regex: regex,
            order: order,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalDetails: additionalDetails,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> dataType = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> code = const Value.absent(),
            Value<String?> values = const Value.absent(),
            Value<bool?> isActive = const Value.absent(),
            Value<bool?> required = const Value.absent(),
            Value<String?> regex = const Value.absent(),
            Value<int?> order = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalDetails = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              AttributesCompanion.insert(
            id: id,
            dataType: dataType,
            referenceId: referenceId,
            tenantId: tenantId,
            code: code,
            values: values,
            isActive: isActive,
            required: required,
            regex: regex,
            order: order,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalDetails: additionalDetails,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$AttributesTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $AttributesTable,
    Attribute,
    $$AttributesTableFilterComposer,
    $$AttributesTableOrderingComposer,
    $$AttributesTableProcessedTableManager,
    $$AttributesTableInsertCompanionBuilder,
    $$AttributesTableUpdateCompanionBuilder> {
  $$AttributesTableProcessedTableManager(super.$state);
}

class $$AttributesTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $AttributesTable> {
  $$AttributesTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get dataType => $state.composableBuilder(
      column: $state.table.dataType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get values => $state.composableBuilder(
      column: $state.table.values,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isActive => $state.composableBuilder(
      column: $state.table.isActive,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get required => $state.composableBuilder(
      column: $state.table.required,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get regex => $state.composableBuilder(
      column: $state.table.regex,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get order => $state.composableBuilder(
      column: $state.table.order,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalDetails => $state.composableBuilder(
      column: $state.table.additionalDetails,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$AttributesTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $AttributesTable> {
  $$AttributesTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get dataType => $state.composableBuilder(
      column: $state.table.dataType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get referenceId => $state.composableBuilder(
      column: $state.table.referenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get values => $state.composableBuilder(
      column: $state.table.values,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isActive => $state.composableBuilder(
      column: $state.table.isActive,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get required => $state.composableBuilder(
      column: $state.table.required,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get regex => $state.composableBuilder(
      column: $state.table.regex,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get order => $state.composableBuilder(
      column: $state.table.order,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalDetails => $state.composableBuilder(
      column: $state.table.additionalDetails,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$PgrServiceTableInsertCompanionBuilder = PgrServiceCompanion Function({
  required bool active,
  required String clientReferenceId,
  Value<String?> id,
  required String tenantId,
  required String serviceCode,
  required String description,
  Value<String?> serviceRequestId,
  Value<String?> accountId,
  required PgrServiceApplicationStatus applicationStatus,
  Value<String?> source,
  Value<String?> auditCreatedBy,
  Value<int?> auditCreatedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required bool isDeleted,
  required int rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$PgrServiceTableUpdateCompanionBuilder = PgrServiceCompanion Function({
  Value<bool> active,
  Value<String> clientReferenceId,
  Value<String?> id,
  Value<String> tenantId,
  Value<String> serviceCode,
  Value<String> description,
  Value<String?> serviceRequestId,
  Value<String?> accountId,
  Value<PgrServiceApplicationStatus> applicationStatus,
  Value<String?> source,
  Value<String?> auditCreatedBy,
  Value<int?> auditCreatedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool> isDeleted,
  Value<int> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$PgrServiceTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $PgrServiceTable,
    PgrServiceData,
    $$PgrServiceTableFilterComposer,
    $$PgrServiceTableOrderingComposer,
    $$PgrServiceTableProcessedTableManager,
    $$PgrServiceTableInsertCompanionBuilder,
    $$PgrServiceTableUpdateCompanionBuilder> {
  $$PgrServiceTableTableManager(_$LocalSqlDataStore db, $PgrServiceTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$PgrServiceTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$PgrServiceTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$PgrServiceTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<bool> active = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> id = const Value.absent(),
            Value<String> tenantId = const Value.absent(),
            Value<String> serviceCode = const Value.absent(),
            Value<String> description = const Value.absent(),
            Value<String?> serviceRequestId = const Value.absent(),
            Value<String?> accountId = const Value.absent(),
            Value<PgrServiceApplicationStatus> applicationStatus =
                const Value.absent(),
            Value<String?> source = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<int> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PgrServiceCompanion(
            active: active,
            clientReferenceId: clientReferenceId,
            id: id,
            tenantId: tenantId,
            serviceCode: serviceCode,
            description: description,
            serviceRequestId: serviceRequestId,
            accountId: accountId,
            applicationStatus: applicationStatus,
            source: source,
            auditCreatedBy: auditCreatedBy,
            auditCreatedTime: auditCreatedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required bool active,
            required String clientReferenceId,
            Value<String?> id = const Value.absent(),
            required String tenantId,
            required String serviceCode,
            required String description,
            Value<String?> serviceRequestId = const Value.absent(),
            Value<String?> accountId = const Value.absent(),
            required PgrServiceApplicationStatus applicationStatus,
            Value<String?> source = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required bool isDeleted,
            required int rowVersion,
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PgrServiceCompanion.insert(
            active: active,
            clientReferenceId: clientReferenceId,
            id: id,
            tenantId: tenantId,
            serviceCode: serviceCode,
            description: description,
            serviceRequestId: serviceRequestId,
            accountId: accountId,
            applicationStatus: applicationStatus,
            source: source,
            auditCreatedBy: auditCreatedBy,
            auditCreatedTime: auditCreatedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$PgrServiceTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $PgrServiceTable,
    PgrServiceData,
    $$PgrServiceTableFilterComposer,
    $$PgrServiceTableOrderingComposer,
    $$PgrServiceTableProcessedTableManager,
    $$PgrServiceTableInsertCompanionBuilder,
    $$PgrServiceTableUpdateCompanionBuilder> {
  $$PgrServiceTableProcessedTableManager(super.$state);
}

class $$PgrServiceTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $PgrServiceTable> {
  $$PgrServiceTableFilterComposer(super.$state);
  ColumnFilters<bool> get active => $state.composableBuilder(
      column: $state.table.active,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get serviceCode => $state.composableBuilder(
      column: $state.table.serviceCode,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get description => $state.composableBuilder(
      column: $state.table.description,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get serviceRequestId => $state.composableBuilder(
      column: $state.table.serviceRequestId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get accountId => $state.composableBuilder(
      column: $state.table.accountId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnWithTypeConverterFilters<PgrServiceApplicationStatus,
          PgrServiceApplicationStatus, int>
      get applicationStatus => $state.composableBuilder(
          column: $state.table.applicationStatus,
          builder: (column, joinBuilders) => ColumnWithTypeConverterFilters(
              column,
              joinBuilders: joinBuilders));

  ColumnFilters<String> get source => $state.composableBuilder(
      column: $state.table.source,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$PgrServiceTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $PgrServiceTable> {
  $$PgrServiceTableOrderingComposer(super.$state);
  ColumnOrderings<bool> get active => $state.composableBuilder(
      column: $state.table.active,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get serviceCode => $state.composableBuilder(
      column: $state.table.serviceCode,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get description => $state.composableBuilder(
      column: $state.table.description,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get serviceRequestId => $state.composableBuilder(
      column: $state.table.serviceRequestId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get accountId => $state.composableBuilder(
      column: $state.table.accountId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get applicationStatus => $state.composableBuilder(
      column: $state.table.applicationStatus,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get source => $state.composableBuilder(
      column: $state.table.source,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$PgrComplainantTableInsertCompanionBuilder = PgrComplainantCompanion
    Function({
  Value<int?> id,
  required String clientReferenceId,
  required String complaintClientReferenceId,
  Value<String?> userName,
  Value<String?> name,
  Value<String?> type,
  Value<String?> mobileNumber,
  Value<String?> emailId,
  required String tenantId,
  Value<String?> uuid,
  required bool active,
  Value<String?> auditCreatedBy,
  Value<int?> auditCreatedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required bool isDeleted,
  required int rowVersion,
  Value<int> rowid,
});
typedef $$PgrComplainantTableUpdateCompanionBuilder = PgrComplainantCompanion
    Function({
  Value<int?> id,
  Value<String> clientReferenceId,
  Value<String> complaintClientReferenceId,
  Value<String?> userName,
  Value<String?> name,
  Value<String?> type,
  Value<String?> mobileNumber,
  Value<String?> emailId,
  Value<String> tenantId,
  Value<String?> uuid,
  Value<bool> active,
  Value<String?> auditCreatedBy,
  Value<int?> auditCreatedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool> isDeleted,
  Value<int> rowVersion,
  Value<int> rowid,
});

class $$PgrComplainantTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $PgrComplainantTable,
    PgrComplainantData,
    $$PgrComplainantTableFilterComposer,
    $$PgrComplainantTableOrderingComposer,
    $$PgrComplainantTableProcessedTableManager,
    $$PgrComplainantTableInsertCompanionBuilder,
    $$PgrComplainantTableUpdateCompanionBuilder> {
  $$PgrComplainantTableTableManager(
      _$LocalSqlDataStore db, $PgrComplainantTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$PgrComplainantTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$PgrComplainantTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$PgrComplainantTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<int?> id = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String> complaintClientReferenceId = const Value.absent(),
            Value<String?> userName = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> mobileNumber = const Value.absent(),
            Value<String?> emailId = const Value.absent(),
            Value<String> tenantId = const Value.absent(),
            Value<String?> uuid = const Value.absent(),
            Value<bool> active = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<int> rowVersion = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              PgrComplainantCompanion(
            id: id,
            clientReferenceId: clientReferenceId,
            complaintClientReferenceId: complaintClientReferenceId,
            userName: userName,
            name: name,
            type: type,
            mobileNumber: mobileNumber,
            emailId: emailId,
            tenantId: tenantId,
            uuid: uuid,
            active: active,
            auditCreatedBy: auditCreatedBy,
            auditCreatedTime: auditCreatedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<int?> id = const Value.absent(),
            required String clientReferenceId,
            required String complaintClientReferenceId,
            Value<String?> userName = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<String?> mobileNumber = const Value.absent(),
            Value<String?> emailId = const Value.absent(),
            required String tenantId,
            Value<String?> uuid = const Value.absent(),
            required bool active,
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required bool isDeleted,
            required int rowVersion,
            Value<int> rowid = const Value.absent(),
          }) =>
              PgrComplainantCompanion.insert(
            id: id,
            clientReferenceId: clientReferenceId,
            complaintClientReferenceId: complaintClientReferenceId,
            userName: userName,
            name: name,
            type: type,
            mobileNumber: mobileNumber,
            emailId: emailId,
            tenantId: tenantId,
            uuid: uuid,
            active: active,
            auditCreatedBy: auditCreatedBy,
            auditCreatedTime: auditCreatedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            rowid: rowid,
          ),
        ));
}

class $$PgrComplainantTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $PgrComplainantTable,
    PgrComplainantData,
    $$PgrComplainantTableFilterComposer,
    $$PgrComplainantTableOrderingComposer,
    $$PgrComplainantTableProcessedTableManager,
    $$PgrComplainantTableInsertCompanionBuilder,
    $$PgrComplainantTableUpdateCompanionBuilder> {
  $$PgrComplainantTableProcessedTableManager(super.$state);
}

class $$PgrComplainantTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $PgrComplainantTable> {
  $$PgrComplainantTableFilterComposer(super.$state);
  ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get complaintClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.complaintClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get userName => $state.composableBuilder(
      column: $state.table.userName,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get type => $state.composableBuilder(
      column: $state.table.type,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get mobileNumber => $state.composableBuilder(
      column: $state.table.mobileNumber,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get emailId => $state.composableBuilder(
      column: $state.table.emailId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get uuid => $state.composableBuilder(
      column: $state.table.uuid,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get active => $state.composableBuilder(
      column: $state.table.active,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$PgrComplainantTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $PgrComplainantTable> {
  $$PgrComplainantTableOrderingComposer(super.$state);
  ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get complaintClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.complaintClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get userName => $state.composableBuilder(
      column: $state.table.userName,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get type => $state.composableBuilder(
      column: $state.table.type,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get mobileNumber => $state.composableBuilder(
      column: $state.table.mobileNumber,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get emailId => $state.composableBuilder(
      column: $state.table.emailId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get uuid => $state.composableBuilder(
      column: $state.table.uuid,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get active => $state.composableBuilder(
      column: $state.table.active,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$UserTableInsertCompanionBuilder = UserCompanion Function({
  Value<String?> id,
  Value<String?> userName,
  Value<String?> salutation,
  Value<String?> name,
  Value<String?> gender,
  Value<String?> mobileNumber,
  Value<String?> emailId,
  Value<String?> altContactNumber,
  Value<String?> pan,
  Value<String?> aadhaarNumber,
  Value<String?> permanentAddress,
  Value<String?> permanentCity,
  Value<String?> permanentPinCode,
  Value<String?> correspondenceAddress,
  Value<String?> correspondenceCity,
  Value<String?> correspondencePinCode,
  Value<String?> alternatemobilenumber,
  Value<bool?> active,
  Value<String?> locale,
  Value<String?> type,
  Value<bool?> accountLocked,
  Value<int?> accountLockedDate,
  Value<String?> fatherOrHusbandName,
  Value<String?> relationship,
  Value<String?> signature,
  Value<String?> bloodGroup,
  Value<String?> photo,
  Value<String?> identificationMark,
  Value<int?> createdBy,
  Value<String?> lastModifiedBy,
  Value<String?> tenantId,
  Value<String?> uuid,
  Value<String?> createdDate,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$UserTableUpdateCompanionBuilder = UserCompanion Function({
  Value<String?> id,
  Value<String?> userName,
  Value<String?> salutation,
  Value<String?> name,
  Value<String?> gender,
  Value<String?> mobileNumber,
  Value<String?> emailId,
  Value<String?> altContactNumber,
  Value<String?> pan,
  Value<String?> aadhaarNumber,
  Value<String?> permanentAddress,
  Value<String?> permanentCity,
  Value<String?> permanentPinCode,
  Value<String?> correspondenceAddress,
  Value<String?> correspondenceCity,
  Value<String?> correspondencePinCode,
  Value<String?> alternatemobilenumber,
  Value<bool?> active,
  Value<String?> locale,
  Value<String?> type,
  Value<bool?> accountLocked,
  Value<int?> accountLockedDate,
  Value<String?> fatherOrHusbandName,
  Value<String?> relationship,
  Value<String?> signature,
  Value<String?> bloodGroup,
  Value<String?> photo,
  Value<String?> identificationMark,
  Value<int?> createdBy,
  Value<String?> lastModifiedBy,
  Value<String?> tenantId,
  Value<String?> uuid,
  Value<String?> createdDate,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$UserTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $UserTable,
    UserData,
    $$UserTableFilterComposer,
    $$UserTableOrderingComposer,
    $$UserTableProcessedTableManager,
    $$UserTableInsertCompanionBuilder,
    $$UserTableUpdateCompanionBuilder> {
  $$UserTableTableManager(_$LocalSqlDataStore db, $UserTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$UserTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$UserTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) => $$UserTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> userName = const Value.absent(),
            Value<String?> salutation = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> gender = const Value.absent(),
            Value<String?> mobileNumber = const Value.absent(),
            Value<String?> emailId = const Value.absent(),
            Value<String?> altContactNumber = const Value.absent(),
            Value<String?> pan = const Value.absent(),
            Value<String?> aadhaarNumber = const Value.absent(),
            Value<String?> permanentAddress = const Value.absent(),
            Value<String?> permanentCity = const Value.absent(),
            Value<String?> permanentPinCode = const Value.absent(),
            Value<String?> correspondenceAddress = const Value.absent(),
            Value<String?> correspondenceCity = const Value.absent(),
            Value<String?> correspondencePinCode = const Value.absent(),
            Value<String?> alternatemobilenumber = const Value.absent(),
            Value<bool?> active = const Value.absent(),
            Value<String?> locale = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<bool?> accountLocked = const Value.absent(),
            Value<int?> accountLockedDate = const Value.absent(),
            Value<String?> fatherOrHusbandName = const Value.absent(),
            Value<String?> relationship = const Value.absent(),
            Value<String?> signature = const Value.absent(),
            Value<String?> bloodGroup = const Value.absent(),
            Value<String?> photo = const Value.absent(),
            Value<String?> identificationMark = const Value.absent(),
            Value<int?> createdBy = const Value.absent(),
            Value<String?> lastModifiedBy = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> uuid = const Value.absent(),
            Value<String?> createdDate = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              UserCompanion(
            id: id,
            userName: userName,
            salutation: salutation,
            name: name,
            gender: gender,
            mobileNumber: mobileNumber,
            emailId: emailId,
            altContactNumber: altContactNumber,
            pan: pan,
            aadhaarNumber: aadhaarNumber,
            permanentAddress: permanentAddress,
            permanentCity: permanentCity,
            permanentPinCode: permanentPinCode,
            correspondenceAddress: correspondenceAddress,
            correspondenceCity: correspondenceCity,
            correspondencePinCode: correspondencePinCode,
            alternatemobilenumber: alternatemobilenumber,
            active: active,
            locale: locale,
            type: type,
            accountLocked: accountLocked,
            accountLockedDate: accountLockedDate,
            fatherOrHusbandName: fatherOrHusbandName,
            relationship: relationship,
            signature: signature,
            bloodGroup: bloodGroup,
            photo: photo,
            identificationMark: identificationMark,
            createdBy: createdBy,
            lastModifiedBy: lastModifiedBy,
            tenantId: tenantId,
            uuid: uuid,
            createdDate: createdDate,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> userName = const Value.absent(),
            Value<String?> salutation = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> gender = const Value.absent(),
            Value<String?> mobileNumber = const Value.absent(),
            Value<String?> emailId = const Value.absent(),
            Value<String?> altContactNumber = const Value.absent(),
            Value<String?> pan = const Value.absent(),
            Value<String?> aadhaarNumber = const Value.absent(),
            Value<String?> permanentAddress = const Value.absent(),
            Value<String?> permanentCity = const Value.absent(),
            Value<String?> permanentPinCode = const Value.absent(),
            Value<String?> correspondenceAddress = const Value.absent(),
            Value<String?> correspondenceCity = const Value.absent(),
            Value<String?> correspondencePinCode = const Value.absent(),
            Value<String?> alternatemobilenumber = const Value.absent(),
            Value<bool?> active = const Value.absent(),
            Value<String?> locale = const Value.absent(),
            Value<String?> type = const Value.absent(),
            Value<bool?> accountLocked = const Value.absent(),
            Value<int?> accountLockedDate = const Value.absent(),
            Value<String?> fatherOrHusbandName = const Value.absent(),
            Value<String?> relationship = const Value.absent(),
            Value<String?> signature = const Value.absent(),
            Value<String?> bloodGroup = const Value.absent(),
            Value<String?> photo = const Value.absent(),
            Value<String?> identificationMark = const Value.absent(),
            Value<int?> createdBy = const Value.absent(),
            Value<String?> lastModifiedBy = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> uuid = const Value.absent(),
            Value<String?> createdDate = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              UserCompanion.insert(
            id: id,
            userName: userName,
            salutation: salutation,
            name: name,
            gender: gender,
            mobileNumber: mobileNumber,
            emailId: emailId,
            altContactNumber: altContactNumber,
            pan: pan,
            aadhaarNumber: aadhaarNumber,
            permanentAddress: permanentAddress,
            permanentCity: permanentCity,
            permanentPinCode: permanentPinCode,
            correspondenceAddress: correspondenceAddress,
            correspondenceCity: correspondenceCity,
            correspondencePinCode: correspondencePinCode,
            alternatemobilenumber: alternatemobilenumber,
            active: active,
            locale: locale,
            type: type,
            accountLocked: accountLocked,
            accountLockedDate: accountLockedDate,
            fatherOrHusbandName: fatherOrHusbandName,
            relationship: relationship,
            signature: signature,
            bloodGroup: bloodGroup,
            photo: photo,
            identificationMark: identificationMark,
            createdBy: createdBy,
            lastModifiedBy: lastModifiedBy,
            tenantId: tenantId,
            uuid: uuid,
            createdDate: createdDate,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$UserTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $UserTable,
    UserData,
    $$UserTableFilterComposer,
    $$UserTableOrderingComposer,
    $$UserTableProcessedTableManager,
    $$UserTableInsertCompanionBuilder,
    $$UserTableUpdateCompanionBuilder> {
  $$UserTableProcessedTableManager(super.$state);
}

class $$UserTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $UserTable> {
  $$UserTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get userName => $state.composableBuilder(
      column: $state.table.userName,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get salutation => $state.composableBuilder(
      column: $state.table.salutation,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get gender => $state.composableBuilder(
      column: $state.table.gender,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get mobileNumber => $state.composableBuilder(
      column: $state.table.mobileNumber,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get emailId => $state.composableBuilder(
      column: $state.table.emailId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get altContactNumber => $state.composableBuilder(
      column: $state.table.altContactNumber,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get pan => $state.composableBuilder(
      column: $state.table.pan,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get aadhaarNumber => $state.composableBuilder(
      column: $state.table.aadhaarNumber,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get permanentAddress => $state.composableBuilder(
      column: $state.table.permanentAddress,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get permanentCity => $state.composableBuilder(
      column: $state.table.permanentCity,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get permanentPinCode => $state.composableBuilder(
      column: $state.table.permanentPinCode,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get correspondenceAddress => $state.composableBuilder(
      column: $state.table.correspondenceAddress,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get correspondenceCity => $state.composableBuilder(
      column: $state.table.correspondenceCity,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get correspondencePinCode => $state.composableBuilder(
      column: $state.table.correspondencePinCode,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get alternatemobilenumber => $state.composableBuilder(
      column: $state.table.alternatemobilenumber,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get active => $state.composableBuilder(
      column: $state.table.active,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get locale => $state.composableBuilder(
      column: $state.table.locale,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get type => $state.composableBuilder(
      column: $state.table.type,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get accountLocked => $state.composableBuilder(
      column: $state.table.accountLocked,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get accountLockedDate => $state.composableBuilder(
      column: $state.table.accountLockedDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get fatherOrHusbandName => $state.composableBuilder(
      column: $state.table.fatherOrHusbandName,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get relationship => $state.composableBuilder(
      column: $state.table.relationship,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get signature => $state.composableBuilder(
      column: $state.table.signature,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get bloodGroup => $state.composableBuilder(
      column: $state.table.bloodGroup,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get photo => $state.composableBuilder(
      column: $state.table.photo,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get identificationMark => $state.composableBuilder(
      column: $state.table.identificationMark,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get createdBy => $state.composableBuilder(
      column: $state.table.createdBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get lastModifiedBy => $state.composableBuilder(
      column: $state.table.lastModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get uuid => $state.composableBuilder(
      column: $state.table.uuid,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get createdDate => $state.composableBuilder(
      column: $state.table.createdDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$UserTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $UserTable> {
  $$UserTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get userName => $state.composableBuilder(
      column: $state.table.userName,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get salutation => $state.composableBuilder(
      column: $state.table.salutation,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get gender => $state.composableBuilder(
      column: $state.table.gender,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get mobileNumber => $state.composableBuilder(
      column: $state.table.mobileNumber,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get emailId => $state.composableBuilder(
      column: $state.table.emailId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get altContactNumber => $state.composableBuilder(
      column: $state.table.altContactNumber,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get pan => $state.composableBuilder(
      column: $state.table.pan,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get aadhaarNumber => $state.composableBuilder(
      column: $state.table.aadhaarNumber,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get permanentAddress => $state.composableBuilder(
      column: $state.table.permanentAddress,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get permanentCity => $state.composableBuilder(
      column: $state.table.permanentCity,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get permanentPinCode => $state.composableBuilder(
      column: $state.table.permanentPinCode,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get correspondenceAddress => $state.composableBuilder(
      column: $state.table.correspondenceAddress,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get correspondenceCity => $state.composableBuilder(
      column: $state.table.correspondenceCity,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get correspondencePinCode => $state.composableBuilder(
      column: $state.table.correspondencePinCode,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get alternatemobilenumber => $state.composableBuilder(
      column: $state.table.alternatemobilenumber,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get active => $state.composableBuilder(
      column: $state.table.active,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get locale => $state.composableBuilder(
      column: $state.table.locale,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get type => $state.composableBuilder(
      column: $state.table.type,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get accountLocked => $state.composableBuilder(
      column: $state.table.accountLocked,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get accountLockedDate => $state.composableBuilder(
      column: $state.table.accountLockedDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get fatherOrHusbandName => $state.composableBuilder(
      column: $state.table.fatherOrHusbandName,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get relationship => $state.composableBuilder(
      column: $state.table.relationship,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get signature => $state.composableBuilder(
      column: $state.table.signature,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get bloodGroup => $state.composableBuilder(
      column: $state.table.bloodGroup,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get photo => $state.composableBuilder(
      column: $state.table.photo,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get identificationMark => $state.composableBuilder(
      column: $state.table.identificationMark,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get createdBy => $state.composableBuilder(
      column: $state.table.createdBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get lastModifiedBy => $state.composableBuilder(
      column: $state.table.lastModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get uuid => $state.composableBuilder(
      column: $state.table.uuid,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get createdDate => $state.composableBuilder(
      column: $state.table.createdDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$DownsyncTableInsertCompanionBuilder = DownsyncCompanion Function({
  Value<String?> locality,
  Value<String?> projectId,
  Value<int?> offset,
  Value<int?> limit,
  Value<int?> lastSyncedTime,
  Value<int?> totalCount,
  Value<String?> boundaryName,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$DownsyncTableUpdateCompanionBuilder = DownsyncCompanion Function({
  Value<String?> locality,
  Value<String?> projectId,
  Value<int?> offset,
  Value<int?> limit,
  Value<int?> lastSyncedTime,
  Value<int?> totalCount,
  Value<String?> boundaryName,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$DownsyncTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $DownsyncTable,
    DownsyncData,
    $$DownsyncTableFilterComposer,
    $$DownsyncTableOrderingComposer,
    $$DownsyncTableProcessedTableManager,
    $$DownsyncTableInsertCompanionBuilder,
    $$DownsyncTableUpdateCompanionBuilder> {
  $$DownsyncTableTableManager(_$LocalSqlDataStore db, $DownsyncTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$DownsyncTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$DownsyncTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$DownsyncTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> locality = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<int?> offset = const Value.absent(),
            Value<int?> limit = const Value.absent(),
            Value<int?> lastSyncedTime = const Value.absent(),
            Value<int?> totalCount = const Value.absent(),
            Value<String?> boundaryName = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DownsyncCompanion(
            locality: locality,
            projectId: projectId,
            offset: offset,
            limit: limit,
            lastSyncedTime: lastSyncedTime,
            totalCount: totalCount,
            boundaryName: boundaryName,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> locality = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<int?> offset = const Value.absent(),
            Value<int?> limit = const Value.absent(),
            Value<int?> lastSyncedTime = const Value.absent(),
            Value<int?> totalCount = const Value.absent(),
            Value<String?> boundaryName = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DownsyncCompanion.insert(
            locality: locality,
            projectId: projectId,
            offset: offset,
            limit: limit,
            lastSyncedTime: lastSyncedTime,
            totalCount: totalCount,
            boundaryName: boundaryName,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$DownsyncTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $DownsyncTable,
    DownsyncData,
    $$DownsyncTableFilterComposer,
    $$DownsyncTableOrderingComposer,
    $$DownsyncTableProcessedTableManager,
    $$DownsyncTableInsertCompanionBuilder,
    $$DownsyncTableUpdateCompanionBuilder> {
  $$DownsyncTableProcessedTableManager(super.$state);
}

class $$DownsyncTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $DownsyncTable> {
  $$DownsyncTableFilterComposer(super.$state);
  ColumnFilters<String> get locality => $state.composableBuilder(
      column: $state.table.locality,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get offset => $state.composableBuilder(
      column: $state.table.offset,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get limit => $state.composableBuilder(
      column: $state.table.limit,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get lastSyncedTime => $state.composableBuilder(
      column: $state.table.lastSyncedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get totalCount => $state.composableBuilder(
      column: $state.table.totalCount,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get boundaryName => $state.composableBuilder(
      column: $state.table.boundaryName,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$DownsyncTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $DownsyncTable> {
  $$DownsyncTableOrderingComposer(super.$state);
  ColumnOrderings<String> get locality => $state.composableBuilder(
      column: $state.table.locality,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get offset => $state.composableBuilder(
      column: $state.table.offset,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get limit => $state.composableBuilder(
      column: $state.table.limit,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get lastSyncedTime => $state.composableBuilder(
      column: $state.table.lastSyncedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get totalCount => $state.composableBuilder(
      column: $state.table.totalCount,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get boundaryName => $state.composableBuilder(
      column: $state.table.boundaryName,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$DownsyncCriteriaTableInsertCompanionBuilder
    = DownsyncCriteriaCompanion Function({
  Value<String?> locality,
  Value<String?> tenantId,
  Value<int?> offset,
  Value<int?> limit,
  Value<String?> projectId,
  Value<int?> lastSyncedTime,
  Value<int?> totalCount,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$DownsyncCriteriaTableUpdateCompanionBuilder
    = DownsyncCriteriaCompanion Function({
  Value<String?> locality,
  Value<String?> tenantId,
  Value<int?> offset,
  Value<int?> limit,
  Value<String?> projectId,
  Value<int?> lastSyncedTime,
  Value<int?> totalCount,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$DownsyncCriteriaTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $DownsyncCriteriaTable,
    DownsyncCriteriaData,
    $$DownsyncCriteriaTableFilterComposer,
    $$DownsyncCriteriaTableOrderingComposer,
    $$DownsyncCriteriaTableProcessedTableManager,
    $$DownsyncCriteriaTableInsertCompanionBuilder,
    $$DownsyncCriteriaTableUpdateCompanionBuilder> {
  $$DownsyncCriteriaTableTableManager(
      _$LocalSqlDataStore db, $DownsyncCriteriaTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$DownsyncCriteriaTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$DownsyncCriteriaTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$DownsyncCriteriaTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> locality = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<int?> offset = const Value.absent(),
            Value<int?> limit = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<int?> lastSyncedTime = const Value.absent(),
            Value<int?> totalCount = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DownsyncCriteriaCompanion(
            locality: locality,
            tenantId: tenantId,
            offset: offset,
            limit: limit,
            projectId: projectId,
            lastSyncedTime: lastSyncedTime,
            totalCount: totalCount,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> locality = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<int?> offset = const Value.absent(),
            Value<int?> limit = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<int?> lastSyncedTime = const Value.absent(),
            Value<int?> totalCount = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DownsyncCriteriaCompanion.insert(
            locality: locality,
            tenantId: tenantId,
            offset: offset,
            limit: limit,
            projectId: projectId,
            lastSyncedTime: lastSyncedTime,
            totalCount: totalCount,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$DownsyncCriteriaTableProcessedTableManager
    extends ProcessedTableManager<
        _$LocalSqlDataStore,
        $DownsyncCriteriaTable,
        DownsyncCriteriaData,
        $$DownsyncCriteriaTableFilterComposer,
        $$DownsyncCriteriaTableOrderingComposer,
        $$DownsyncCriteriaTableProcessedTableManager,
        $$DownsyncCriteriaTableInsertCompanionBuilder,
        $$DownsyncCriteriaTableUpdateCompanionBuilder> {
  $$DownsyncCriteriaTableProcessedTableManager(super.$state);
}

class $$DownsyncCriteriaTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $DownsyncCriteriaTable> {
  $$DownsyncCriteriaTableFilterComposer(super.$state);
  ColumnFilters<String> get locality => $state.composableBuilder(
      column: $state.table.locality,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get offset => $state.composableBuilder(
      column: $state.table.offset,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get limit => $state.composableBuilder(
      column: $state.table.limit,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get lastSyncedTime => $state.composableBuilder(
      column: $state.table.lastSyncedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get totalCount => $state.composableBuilder(
      column: $state.table.totalCount,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$DownsyncCriteriaTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $DownsyncCriteriaTable> {
  $$DownsyncCriteriaTableOrderingComposer(super.$state);
  ColumnOrderings<String> get locality => $state.composableBuilder(
      column: $state.table.locality,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get offset => $state.composableBuilder(
      column: $state.table.offset,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get limit => $state.composableBuilder(
      column: $state.table.limit,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get lastSyncedTime => $state.composableBuilder(
      column: $state.table.lastSyncedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get totalCount => $state.composableBuilder(
      column: $state.table.totalCount,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$HFReferralTableInsertCompanionBuilder = HFReferralCompanion Function({
  Value<String?> id,
  Value<String?> tenantId,
  Value<String?> name,
  Value<String?> projectId,
  Value<String?> projectFacilityId,
  Value<String?> symptomSurveyId,
  Value<String?> beneficiaryId,
  Value<String?> referralCode,
  Value<String?> nationalLevelId,
  Value<String?> symptom,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$HFReferralTableUpdateCompanionBuilder = HFReferralCompanion Function({
  Value<String?> id,
  Value<String?> tenantId,
  Value<String?> name,
  Value<String?> projectId,
  Value<String?> projectFacilityId,
  Value<String?> symptomSurveyId,
  Value<String?> beneficiaryId,
  Value<String?> referralCode,
  Value<String?> nationalLevelId,
  Value<String?> symptom,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$HFReferralTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $HFReferralTable,
    HFReferralData,
    $$HFReferralTableFilterComposer,
    $$HFReferralTableOrderingComposer,
    $$HFReferralTableProcessedTableManager,
    $$HFReferralTableInsertCompanionBuilder,
    $$HFReferralTableUpdateCompanionBuilder> {
  $$HFReferralTableTableManager(_$LocalSqlDataStore db, $HFReferralTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$HFReferralTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$HFReferralTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$HFReferralTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> projectFacilityId = const Value.absent(),
            Value<String?> symptomSurveyId = const Value.absent(),
            Value<String?> beneficiaryId = const Value.absent(),
            Value<String?> referralCode = const Value.absent(),
            Value<String?> nationalLevelId = const Value.absent(),
            Value<String?> symptom = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              HFReferralCompanion(
            id: id,
            tenantId: tenantId,
            name: name,
            projectId: projectId,
            projectFacilityId: projectFacilityId,
            symptomSurveyId: symptomSurveyId,
            beneficiaryId: beneficiaryId,
            referralCode: referralCode,
            nationalLevelId: nationalLevelId,
            symptom: symptom,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> name = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> projectFacilityId = const Value.absent(),
            Value<String?> symptomSurveyId = const Value.absent(),
            Value<String?> beneficiaryId = const Value.absent(),
            Value<String?> referralCode = const Value.absent(),
            Value<String?> nationalLevelId = const Value.absent(),
            Value<String?> symptom = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              HFReferralCompanion.insert(
            id: id,
            tenantId: tenantId,
            name: name,
            projectId: projectId,
            projectFacilityId: projectFacilityId,
            symptomSurveyId: symptomSurveyId,
            beneficiaryId: beneficiaryId,
            referralCode: referralCode,
            nationalLevelId: nationalLevelId,
            symptom: symptom,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$HFReferralTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $HFReferralTable,
    HFReferralData,
    $$HFReferralTableFilterComposer,
    $$HFReferralTableOrderingComposer,
    $$HFReferralTableProcessedTableManager,
    $$HFReferralTableInsertCompanionBuilder,
    $$HFReferralTableUpdateCompanionBuilder> {
  $$HFReferralTableProcessedTableManager(super.$state);
}

class $$HFReferralTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $HFReferralTable> {
  $$HFReferralTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectFacilityId => $state.composableBuilder(
      column: $state.table.projectFacilityId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get symptomSurveyId => $state.composableBuilder(
      column: $state.table.symptomSurveyId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get beneficiaryId => $state.composableBuilder(
      column: $state.table.beneficiaryId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get referralCode => $state.composableBuilder(
      column: $state.table.referralCode,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get nationalLevelId => $state.composableBuilder(
      column: $state.table.nationalLevelId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get symptom => $state.composableBuilder(
      column: $state.table.symptom,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$HFReferralTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $HFReferralTable> {
  $$HFReferralTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectFacilityId => $state.composableBuilder(
      column: $state.table.projectFacilityId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get symptomSurveyId => $state.composableBuilder(
      column: $state.table.symptomSurveyId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get beneficiaryId => $state.composableBuilder(
      column: $state.table.beneficiaryId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get referralCode => $state.composableBuilder(
      column: $state.table.referralCode,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get nationalLevelId => $state.composableBuilder(
      column: $state.table.nationalLevelId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get symptom => $state.composableBuilder(
      column: $state.table.symptom,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$HouseholdTableInsertCompanionBuilder = HouseholdCompanion Function({
  Value<String?> id,
  Value<int?> memberCount,
  Value<double?> latitude,
  Value<double?> longitude,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<HouseholdType?> householdType,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$HouseholdTableUpdateCompanionBuilder = HouseholdCompanion Function({
  Value<String?> id,
  Value<int?> memberCount,
  Value<double?> latitude,
  Value<double?> longitude,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<HouseholdType?> householdType,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$HouseholdTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $HouseholdTable,
    HouseholdData,
    $$HouseholdTableFilterComposer,
    $$HouseholdTableOrderingComposer,
    $$HouseholdTableProcessedTableManager,
    $$HouseholdTableInsertCompanionBuilder,
    $$HouseholdTableUpdateCompanionBuilder> {
  $$HouseholdTableTableManager(_$LocalSqlDataStore db, $HouseholdTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$HouseholdTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$HouseholdTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$HouseholdTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<int?> memberCount = const Value.absent(),
            Value<double?> latitude = const Value.absent(),
            Value<double?> longitude = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<HouseholdType?> householdType = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              HouseholdCompanion(
            id: id,
            memberCount: memberCount,
            latitude: latitude,
            longitude: longitude,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            householdType: householdType,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<int?> memberCount = const Value.absent(),
            Value<double?> latitude = const Value.absent(),
            Value<double?> longitude = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<HouseholdType?> householdType = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              HouseholdCompanion.insert(
            id: id,
            memberCount: memberCount,
            latitude: latitude,
            longitude: longitude,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            householdType: householdType,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$HouseholdTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $HouseholdTable,
    HouseholdData,
    $$HouseholdTableFilterComposer,
    $$HouseholdTableOrderingComposer,
    $$HouseholdTableProcessedTableManager,
    $$HouseholdTableInsertCompanionBuilder,
    $$HouseholdTableUpdateCompanionBuilder> {
  $$HouseholdTableProcessedTableManager(super.$state);
}

class $$HouseholdTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $HouseholdTable> {
  $$HouseholdTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get memberCount => $state.composableBuilder(
      column: $state.table.memberCount,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<double> get latitude => $state.composableBuilder(
      column: $state.table.latitude,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<double> get longitude => $state.composableBuilder(
      column: $state.table.longitude,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnWithTypeConverterFilters<HouseholdType?, HouseholdType, int>
      get householdType => $state.composableBuilder(
          column: $state.table.householdType,
          builder: (column, joinBuilders) => ColumnWithTypeConverterFilters(
              column,
              joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$HouseholdTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $HouseholdTable> {
  $$HouseholdTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get memberCount => $state.composableBuilder(
      column: $state.table.memberCount,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<double> get latitude => $state.composableBuilder(
      column: $state.table.latitude,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<double> get longitude => $state.composableBuilder(
      column: $state.table.longitude,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get householdType => $state.composableBuilder(
      column: $state.table.householdType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$HouseholdMemberTableInsertCompanionBuilder = HouseholdMemberCompanion
    Function({
  Value<String?> id,
  Value<String?> householdId,
  Value<String?> householdClientReferenceId,
  Value<String?> individualId,
  Value<String?> individualClientReferenceId,
  required bool isHeadOfHousehold,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$HouseholdMemberTableUpdateCompanionBuilder = HouseholdMemberCompanion
    Function({
  Value<String?> id,
  Value<String?> householdId,
  Value<String?> householdClientReferenceId,
  Value<String?> individualId,
  Value<String?> individualClientReferenceId,
  Value<bool> isHeadOfHousehold,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$HouseholdMemberTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $HouseholdMemberTable,
    HouseholdMemberData,
    $$HouseholdMemberTableFilterComposer,
    $$HouseholdMemberTableOrderingComposer,
    $$HouseholdMemberTableProcessedTableManager,
    $$HouseholdMemberTableInsertCompanionBuilder,
    $$HouseholdMemberTableUpdateCompanionBuilder> {
  $$HouseholdMemberTableTableManager(
      _$LocalSqlDataStore db, $HouseholdMemberTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$HouseholdMemberTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$HouseholdMemberTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$HouseholdMemberTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> householdId = const Value.absent(),
            Value<String?> householdClientReferenceId = const Value.absent(),
            Value<String?> individualId = const Value.absent(),
            Value<String?> individualClientReferenceId = const Value.absent(),
            Value<bool> isHeadOfHousehold = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              HouseholdMemberCompanion(
            id: id,
            householdId: householdId,
            householdClientReferenceId: householdClientReferenceId,
            individualId: individualId,
            individualClientReferenceId: individualClientReferenceId,
            isHeadOfHousehold: isHeadOfHousehold,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> householdId = const Value.absent(),
            Value<String?> householdClientReferenceId = const Value.absent(),
            Value<String?> individualId = const Value.absent(),
            Value<String?> individualClientReferenceId = const Value.absent(),
            required bool isHeadOfHousehold,
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              HouseholdMemberCompanion.insert(
            id: id,
            householdId: householdId,
            householdClientReferenceId: householdClientReferenceId,
            individualId: individualId,
            individualClientReferenceId: individualClientReferenceId,
            isHeadOfHousehold: isHeadOfHousehold,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$HouseholdMemberTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $HouseholdMemberTable,
    HouseholdMemberData,
    $$HouseholdMemberTableFilterComposer,
    $$HouseholdMemberTableOrderingComposer,
    $$HouseholdMemberTableProcessedTableManager,
    $$HouseholdMemberTableInsertCompanionBuilder,
    $$HouseholdMemberTableUpdateCompanionBuilder> {
  $$HouseholdMemberTableProcessedTableManager(super.$state);
}

class $$HouseholdMemberTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $HouseholdMemberTable> {
  $$HouseholdMemberTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get householdId => $state.composableBuilder(
      column: $state.table.householdId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get householdClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.householdClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get individualId => $state.composableBuilder(
      column: $state.table.individualId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get individualClientReferenceId => $state
      .composableBuilder(
          column: $state.table.individualClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isHeadOfHousehold => $state.composableBuilder(
      column: $state.table.isHeadOfHousehold,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$HouseholdMemberTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $HouseholdMemberTable> {
  $$HouseholdMemberTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get householdId => $state.composableBuilder(
      column: $state.table.householdId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get householdClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.householdClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get individualId => $state.composableBuilder(
      column: $state.table.individualId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get individualClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.individualClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isHeadOfHousehold => $state.composableBuilder(
      column: $state.table.isHeadOfHousehold,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$HouseholdMemberRelationShipTableInsertCompanionBuilder
    = HouseholdMemberRelationShipCompanion Function({
  Value<String?> id,
  Value<String?> selfId,
  Value<String?> selfClientReferenceId,
  Value<String?> relativeId,
  Value<String?> relativeClientReferenceId,
  Value<String?> relationshipType,
  required String clientReferenceId,
  Value<String?> tenantId,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$HouseholdMemberRelationShipTableUpdateCompanionBuilder
    = HouseholdMemberRelationShipCompanion Function({
  Value<String?> id,
  Value<String?> selfId,
  Value<String?> selfClientReferenceId,
  Value<String?> relativeId,
  Value<String?> relativeClientReferenceId,
  Value<String?> relationshipType,
  Value<String> clientReferenceId,
  Value<String?> tenantId,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$HouseholdMemberRelationShipTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $HouseholdMemberRelationShipTable,
    HouseholdMemberRelationShipData,
    $$HouseholdMemberRelationShipTableFilterComposer,
    $$HouseholdMemberRelationShipTableOrderingComposer,
    $$HouseholdMemberRelationShipTableProcessedTableManager,
    $$HouseholdMemberRelationShipTableInsertCompanionBuilder,
    $$HouseholdMemberRelationShipTableUpdateCompanionBuilder> {
  $$HouseholdMemberRelationShipTableTableManager(
      _$LocalSqlDataStore db, $HouseholdMemberRelationShipTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$HouseholdMemberRelationShipTableFilterComposer(
              ComposerState(db, table)),
          orderingComposer: $$HouseholdMemberRelationShipTableOrderingComposer(
              ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$HouseholdMemberRelationShipTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> selfId = const Value.absent(),
            Value<String?> selfClientReferenceId = const Value.absent(),
            Value<String?> relativeId = const Value.absent(),
            Value<String?> relativeClientReferenceId = const Value.absent(),
            Value<String?> relationshipType = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              HouseholdMemberRelationShipCompanion(
            id: id,
            selfId: selfId,
            selfClientReferenceId: selfClientReferenceId,
            relativeId: relativeId,
            relativeClientReferenceId: relativeClientReferenceId,
            relationshipType: relationshipType,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> selfId = const Value.absent(),
            Value<String?> selfClientReferenceId = const Value.absent(),
            Value<String?> relativeId = const Value.absent(),
            Value<String?> relativeClientReferenceId = const Value.absent(),
            Value<String?> relationshipType = const Value.absent(),
            required String clientReferenceId,
            Value<String?> tenantId = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              HouseholdMemberRelationShipCompanion.insert(
            id: id,
            selfId: selfId,
            selfClientReferenceId: selfClientReferenceId,
            relativeId: relativeId,
            relativeClientReferenceId: relativeClientReferenceId,
            relationshipType: relationshipType,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$HouseholdMemberRelationShipTableProcessedTableManager
    extends ProcessedTableManager<
        _$LocalSqlDataStore,
        $HouseholdMemberRelationShipTable,
        HouseholdMemberRelationShipData,
        $$HouseholdMemberRelationShipTableFilterComposer,
        $$HouseholdMemberRelationShipTableOrderingComposer,
        $$HouseholdMemberRelationShipTableProcessedTableManager,
        $$HouseholdMemberRelationShipTableInsertCompanionBuilder,
        $$HouseholdMemberRelationShipTableUpdateCompanionBuilder> {
  $$HouseholdMemberRelationShipTableProcessedTableManager(super.$state);
}

class $$HouseholdMemberRelationShipTableFilterComposer extends FilterComposer<
    _$LocalSqlDataStore, $HouseholdMemberRelationShipTable> {
  $$HouseholdMemberRelationShipTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get selfId => $state.composableBuilder(
      column: $state.table.selfId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get selfClientReferenceId => $state.composableBuilder(
      column: $state.table.selfClientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get relativeId => $state.composableBuilder(
      column: $state.table.relativeId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get relativeClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.relativeClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get relationshipType => $state.composableBuilder(
      column: $state.table.relationshipType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$HouseholdMemberRelationShipTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore,
        $HouseholdMemberRelationShipTable> {
  $$HouseholdMemberRelationShipTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get selfId => $state.composableBuilder(
      column: $state.table.selfId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get selfClientReferenceId => $state.composableBuilder(
      column: $state.table.selfClientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get relativeId => $state.composableBuilder(
      column: $state.table.relativeId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get relativeClientReferenceId => $state
      .composableBuilder(
          column: $state.table.relativeClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get relationshipType => $state.composableBuilder(
      column: $state.table.relationshipType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$TaskTableInsertCompanionBuilder = TaskCompanion Function({
  Value<String?> id,
  Value<String?> projectId,
  Value<String?> projectBeneficiaryId,
  Value<String?> projectBeneficiaryClientReferenceId,
  Value<String?> createdBy,
  Value<String?> status,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<int?> plannedStartDate,
  Value<int?> plannedEndDate,
  Value<int?> actualStartDate,
  Value<int?> actualEndDate,
  Value<int?> createdDate,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$TaskTableUpdateCompanionBuilder = TaskCompanion Function({
  Value<String?> id,
  Value<String?> projectId,
  Value<String?> projectBeneficiaryId,
  Value<String?> projectBeneficiaryClientReferenceId,
  Value<String?> createdBy,
  Value<String?> status,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<int?> plannedStartDate,
  Value<int?> plannedEndDate,
  Value<int?> actualStartDate,
  Value<int?> actualEndDate,
  Value<int?> createdDate,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$TaskTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $TaskTable,
    TaskData,
    $$TaskTableFilterComposer,
    $$TaskTableOrderingComposer,
    $$TaskTableProcessedTableManager,
    $$TaskTableInsertCompanionBuilder,
    $$TaskTableUpdateCompanionBuilder> {
  $$TaskTableTableManager(_$LocalSqlDataStore db, $TaskTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$TaskTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$TaskTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) => $$TaskTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> projectBeneficiaryId = const Value.absent(),
            Value<String?> projectBeneficiaryClientReferenceId =
                const Value.absent(),
            Value<String?> createdBy = const Value.absent(),
            Value<String?> status = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<int?> plannedStartDate = const Value.absent(),
            Value<int?> plannedEndDate = const Value.absent(),
            Value<int?> actualStartDate = const Value.absent(),
            Value<int?> actualEndDate = const Value.absent(),
            Value<int?> createdDate = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TaskCompanion(
            id: id,
            projectId: projectId,
            projectBeneficiaryId: projectBeneficiaryId,
            projectBeneficiaryClientReferenceId:
                projectBeneficiaryClientReferenceId,
            createdBy: createdBy,
            status: status,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            plannedStartDate: plannedStartDate,
            plannedEndDate: plannedEndDate,
            actualStartDate: actualStartDate,
            actualEndDate: actualEndDate,
            createdDate: createdDate,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> projectBeneficiaryId = const Value.absent(),
            Value<String?> projectBeneficiaryClientReferenceId =
                const Value.absent(),
            Value<String?> createdBy = const Value.absent(),
            Value<String?> status = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<int?> plannedStartDate = const Value.absent(),
            Value<int?> plannedEndDate = const Value.absent(),
            Value<int?> actualStartDate = const Value.absent(),
            Value<int?> actualEndDate = const Value.absent(),
            Value<int?> createdDate = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TaskCompanion.insert(
            id: id,
            projectId: projectId,
            projectBeneficiaryId: projectBeneficiaryId,
            projectBeneficiaryClientReferenceId:
                projectBeneficiaryClientReferenceId,
            createdBy: createdBy,
            status: status,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            plannedStartDate: plannedStartDate,
            plannedEndDate: plannedEndDate,
            actualStartDate: actualStartDate,
            actualEndDate: actualEndDate,
            createdDate: createdDate,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$TaskTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $TaskTable,
    TaskData,
    $$TaskTableFilterComposer,
    $$TaskTableOrderingComposer,
    $$TaskTableProcessedTableManager,
    $$TaskTableInsertCompanionBuilder,
    $$TaskTableUpdateCompanionBuilder> {
  $$TaskTableProcessedTableManager(super.$state);
}

class $$TaskTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $TaskTable> {
  $$TaskTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectBeneficiaryId => $state.composableBuilder(
      column: $state.table.projectBeneficiaryId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectBeneficiaryClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.projectBeneficiaryClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get createdBy => $state.composableBuilder(
      column: $state.table.createdBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get status => $state.composableBuilder(
      column: $state.table.status,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get plannedStartDate => $state.composableBuilder(
      column: $state.table.plannedStartDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get plannedEndDate => $state.composableBuilder(
      column: $state.table.plannedEndDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get actualStartDate => $state.composableBuilder(
      column: $state.table.actualStartDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get actualEndDate => $state.composableBuilder(
      column: $state.table.actualEndDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get createdDate => $state.composableBuilder(
      column: $state.table.createdDate,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$TaskTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $TaskTable> {
  $$TaskTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectBeneficiaryId => $state.composableBuilder(
      column: $state.table.projectBeneficiaryId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectBeneficiaryClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.projectBeneficiaryClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get createdBy => $state.composableBuilder(
      column: $state.table.createdBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get status => $state.composableBuilder(
      column: $state.table.status,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get plannedStartDate => $state.composableBuilder(
      column: $state.table.plannedStartDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get plannedEndDate => $state.composableBuilder(
      column: $state.table.plannedEndDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get actualStartDate => $state.composableBuilder(
      column: $state.table.actualStartDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get actualEndDate => $state.composableBuilder(
      column: $state.table.actualEndDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get createdDate => $state.composableBuilder(
      column: $state.table.createdDate,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$TaskResourceTableInsertCompanionBuilder = TaskResourceCompanion
    Function({
  required String clientReferenceId,
  Value<String?> taskclientReferenceId,
  Value<String?> taskId,
  Value<String?> id,
  Value<String?> productVariantId,
  Value<String?> quantity,
  Value<bool?> isDelivered,
  Value<String?> deliveryComment,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$TaskResourceTableUpdateCompanionBuilder = TaskResourceCompanion
    Function({
  Value<String> clientReferenceId,
  Value<String?> taskclientReferenceId,
  Value<String?> taskId,
  Value<String?> id,
  Value<String?> productVariantId,
  Value<String?> quantity,
  Value<bool?> isDelivered,
  Value<String?> deliveryComment,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$TaskResourceTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $TaskResourceTable,
    TaskResourceData,
    $$TaskResourceTableFilterComposer,
    $$TaskResourceTableOrderingComposer,
    $$TaskResourceTableProcessedTableManager,
    $$TaskResourceTableInsertCompanionBuilder,
    $$TaskResourceTableUpdateCompanionBuilder> {
  $$TaskResourceTableTableManager(
      _$LocalSqlDataStore db, $TaskResourceTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$TaskResourceTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$TaskResourceTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$TaskResourceTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> taskclientReferenceId = const Value.absent(),
            Value<String?> taskId = const Value.absent(),
            Value<String?> id = const Value.absent(),
            Value<String?> productVariantId = const Value.absent(),
            Value<String?> quantity = const Value.absent(),
            Value<bool?> isDelivered = const Value.absent(),
            Value<String?> deliveryComment = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TaskResourceCompanion(
            clientReferenceId: clientReferenceId,
            taskclientReferenceId: taskclientReferenceId,
            taskId: taskId,
            id: id,
            productVariantId: productVariantId,
            quantity: quantity,
            isDelivered: isDelivered,
            deliveryComment: deliveryComment,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String clientReferenceId,
            Value<String?> taskclientReferenceId = const Value.absent(),
            Value<String?> taskId = const Value.absent(),
            Value<String?> id = const Value.absent(),
            Value<String?> productVariantId = const Value.absent(),
            Value<String?> quantity = const Value.absent(),
            Value<bool?> isDelivered = const Value.absent(),
            Value<String?> deliveryComment = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TaskResourceCompanion.insert(
            clientReferenceId: clientReferenceId,
            taskclientReferenceId: taskclientReferenceId,
            taskId: taskId,
            id: id,
            productVariantId: productVariantId,
            quantity: quantity,
            isDelivered: isDelivered,
            deliveryComment: deliveryComment,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$TaskResourceTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $TaskResourceTable,
    TaskResourceData,
    $$TaskResourceTableFilterComposer,
    $$TaskResourceTableOrderingComposer,
    $$TaskResourceTableProcessedTableManager,
    $$TaskResourceTableInsertCompanionBuilder,
    $$TaskResourceTableUpdateCompanionBuilder> {
  $$TaskResourceTableProcessedTableManager(super.$state);
}

class $$TaskResourceTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $TaskResourceTable> {
  $$TaskResourceTableFilterComposer(super.$state);
  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get taskclientReferenceId => $state.composableBuilder(
      column: $state.table.taskclientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get taskId => $state.composableBuilder(
      column: $state.table.taskId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get productVariantId => $state.composableBuilder(
      column: $state.table.productVariantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get quantity => $state.composableBuilder(
      column: $state.table.quantity,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDelivered => $state.composableBuilder(
      column: $state.table.isDelivered,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get deliveryComment => $state.composableBuilder(
      column: $state.table.deliveryComment,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$TaskResourceTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $TaskResourceTable> {
  $$TaskResourceTableOrderingComposer(super.$state);
  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get taskclientReferenceId => $state.composableBuilder(
      column: $state.table.taskclientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get taskId => $state.composableBuilder(
      column: $state.table.taskId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get productVariantId => $state.composableBuilder(
      column: $state.table.productVariantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get quantity => $state.composableBuilder(
      column: $state.table.quantity,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDelivered => $state.composableBuilder(
      column: $state.table.isDelivered,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get deliveryComment => $state.composableBuilder(
      column: $state.table.deliveryComment,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SideEffectTableInsertCompanionBuilder = SideEffectCompanion Function({
  Value<String?> id,
  Value<String?> projectId,
  Value<String?> taskClientReferenceId,
  Value<String?> projectBeneficiaryClientReferenceId,
  Value<int?> reAttempts,
  Value<String?> symptoms,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$SideEffectTableUpdateCompanionBuilder = SideEffectCompanion Function({
  Value<String?> id,
  Value<String?> projectId,
  Value<String?> taskClientReferenceId,
  Value<String?> projectBeneficiaryClientReferenceId,
  Value<int?> reAttempts,
  Value<String?> symptoms,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$SideEffectTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $SideEffectTable,
    SideEffectData,
    $$SideEffectTableFilterComposer,
    $$SideEffectTableOrderingComposer,
    $$SideEffectTableProcessedTableManager,
    $$SideEffectTableInsertCompanionBuilder,
    $$SideEffectTableUpdateCompanionBuilder> {
  $$SideEffectTableTableManager(_$LocalSqlDataStore db, $SideEffectTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SideEffectTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$SideEffectTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SideEffectTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> taskClientReferenceId = const Value.absent(),
            Value<String?> projectBeneficiaryClientReferenceId =
                const Value.absent(),
            Value<int?> reAttempts = const Value.absent(),
            Value<String?> symptoms = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              SideEffectCompanion(
            id: id,
            projectId: projectId,
            taskClientReferenceId: taskClientReferenceId,
            projectBeneficiaryClientReferenceId:
                projectBeneficiaryClientReferenceId,
            reAttempts: reAttempts,
            symptoms: symptoms,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> taskClientReferenceId = const Value.absent(),
            Value<String?> projectBeneficiaryClientReferenceId =
                const Value.absent(),
            Value<int?> reAttempts = const Value.absent(),
            Value<String?> symptoms = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              SideEffectCompanion.insert(
            id: id,
            projectId: projectId,
            taskClientReferenceId: taskClientReferenceId,
            projectBeneficiaryClientReferenceId:
                projectBeneficiaryClientReferenceId,
            reAttempts: reAttempts,
            symptoms: symptoms,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$SideEffectTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $SideEffectTable,
    SideEffectData,
    $$SideEffectTableFilterComposer,
    $$SideEffectTableOrderingComposer,
    $$SideEffectTableProcessedTableManager,
    $$SideEffectTableInsertCompanionBuilder,
    $$SideEffectTableUpdateCompanionBuilder> {
  $$SideEffectTableProcessedTableManager(super.$state);
}

class $$SideEffectTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $SideEffectTable> {
  $$SideEffectTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get taskClientReferenceId => $state.composableBuilder(
      column: $state.table.taskClientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectBeneficiaryClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.projectBeneficiaryClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get reAttempts => $state.composableBuilder(
      column: $state.table.reAttempts,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get symptoms => $state.composableBuilder(
      column: $state.table.symptoms,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$SideEffectTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $SideEffectTable> {
  $$SideEffectTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get taskClientReferenceId => $state.composableBuilder(
      column: $state.table.taskClientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectBeneficiaryClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.projectBeneficiaryClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get reAttempts => $state.composableBuilder(
      column: $state.table.reAttempts,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get symptoms => $state.composableBuilder(
      column: $state.table.symptoms,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ReferralTableInsertCompanionBuilder = ReferralCompanion Function({
  Value<String?> id,
  Value<String?> projectId,
  Value<String?> projectBeneficiaryClientReferenceId,
  Value<String?> referrerId,
  Value<String?> recipientType,
  Value<String?> recipientId,
  Value<String?> reasons,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  required String clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$ReferralTableUpdateCompanionBuilder = ReferralCompanion Function({
  Value<String?> id,
  Value<String?> projectId,
  Value<String?> projectBeneficiaryClientReferenceId,
  Value<String?> referrerId,
  Value<String?> recipientType,
  Value<String?> recipientId,
  Value<String?> reasons,
  Value<String?> auditCreatedBy,
  Value<bool?> nonRecoverableError,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String> clientReferenceId,
  Value<String?> tenantId,
  Value<bool?> isDeleted,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$ReferralTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $ReferralTable,
    ReferralData,
    $$ReferralTableFilterComposer,
    $$ReferralTableOrderingComposer,
    $$ReferralTableProcessedTableManager,
    $$ReferralTableInsertCompanionBuilder,
    $$ReferralTableUpdateCompanionBuilder> {
  $$ReferralTableTableManager(_$LocalSqlDataStore db, $ReferralTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ReferralTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$ReferralTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ReferralTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> projectBeneficiaryClientReferenceId =
                const Value.absent(),
            Value<String?> referrerId = const Value.absent(),
            Value<String?> recipientType = const Value.absent(),
            Value<String?> recipientId = const Value.absent(),
            Value<String?> reasons = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ReferralCompanion(
            id: id,
            projectId: projectId,
            projectBeneficiaryClientReferenceId:
                projectBeneficiaryClientReferenceId,
            referrerId: referrerId,
            recipientType: recipientType,
            recipientId: recipientId,
            reasons: reasons,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            Value<String?> id = const Value.absent(),
            Value<String?> projectId = const Value.absent(),
            Value<String?> projectBeneficiaryClientReferenceId =
                const Value.absent(),
            Value<String?> referrerId = const Value.absent(),
            Value<String?> recipientType = const Value.absent(),
            Value<String?> recipientId = const Value.absent(),
            Value<String?> reasons = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            required String clientReferenceId,
            Value<String?> tenantId = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              ReferralCompanion.insert(
            id: id,
            projectId: projectId,
            projectBeneficiaryClientReferenceId:
                projectBeneficiaryClientReferenceId,
            referrerId: referrerId,
            recipientType: recipientType,
            recipientId: recipientId,
            reasons: reasons,
            auditCreatedBy: auditCreatedBy,
            nonRecoverableError: nonRecoverableError,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            clientReferenceId: clientReferenceId,
            tenantId: tenantId,
            isDeleted: isDeleted,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$ReferralTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $ReferralTable,
    ReferralData,
    $$ReferralTableFilterComposer,
    $$ReferralTableOrderingComposer,
    $$ReferralTableProcessedTableManager,
    $$ReferralTableInsertCompanionBuilder,
    $$ReferralTableUpdateCompanionBuilder> {
  $$ReferralTableProcessedTableManager(super.$state);
}

class $$ReferralTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $ReferralTable> {
  $$ReferralTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectBeneficiaryClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.projectBeneficiaryClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get referrerId => $state.composableBuilder(
      column: $state.table.referrerId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get recipientType => $state.composableBuilder(
      column: $state.table.recipientType,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get recipientId => $state.composableBuilder(
      column: $state.table.recipientId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get reasons => $state.composableBuilder(
      column: $state.table.reasons,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ReferralTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $ReferralTable> {
  $$ReferralTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectBeneficiaryClientReferenceId =>
      $state.composableBuilder(
          column: $state.table.projectBeneficiaryClientReferenceId,
          builder: (column, joinBuilders) =>
              ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get referrerId => $state.composableBuilder(
      column: $state.table.referrerId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get recipientType => $state.composableBuilder(
      column: $state.table.recipientType,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get recipientId => $state.composableBuilder(
      column: $state.table.recipientId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get reasons => $state.composableBuilder(
      column: $state.table.reasons,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LocalizationTableInsertCompanionBuilder = LocalizationCompanion
    Function({
  required String locale,
  required String code,
  required String message,
  required String module,
  Value<int> rowid,
});
typedef $$LocalizationTableUpdateCompanionBuilder = LocalizationCompanion
    Function({
  Value<String> locale,
  Value<String> code,
  Value<String> message,
  Value<String> module,
  Value<int> rowid,
});

class $$LocalizationTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $LocalizationTable,
    LocalizationData,
    $$LocalizationTableFilterComposer,
    $$LocalizationTableOrderingComposer,
    $$LocalizationTableProcessedTableManager,
    $$LocalizationTableInsertCompanionBuilder,
    $$LocalizationTableUpdateCompanionBuilder> {
  $$LocalizationTableTableManager(
      _$LocalSqlDataStore db, $LocalizationTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LocalizationTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$LocalizationTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LocalizationTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String> locale = const Value.absent(),
            Value<String> code = const Value.absent(),
            Value<String> message = const Value.absent(),
            Value<String> module = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              LocalizationCompanion(
            locale: locale,
            code: code,
            message: message,
            module: module,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String locale,
            required String code,
            required String message,
            required String module,
            Value<int> rowid = const Value.absent(),
          }) =>
              LocalizationCompanion.insert(
            locale: locale,
            code: code,
            message: message,
            module: module,
            rowid: rowid,
          ),
        ));
}

class $$LocalizationTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $LocalizationTable,
    LocalizationData,
    $$LocalizationTableFilterComposer,
    $$LocalizationTableOrderingComposer,
    $$LocalizationTableProcessedTableManager,
    $$LocalizationTableInsertCompanionBuilder,
    $$LocalizationTableUpdateCompanionBuilder> {
  $$LocalizationTableProcessedTableManager(super.$state);
}

class $$LocalizationTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $LocalizationTable> {
  $$LocalizationTableFilterComposer(super.$state);
  ColumnFilters<String> get locale => $state.composableBuilder(
      column: $state.table.locale,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get message => $state.composableBuilder(
      column: $state.table.message,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get module => $state.composableBuilder(
      column: $state.table.module,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LocalizationTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $LocalizationTable> {
  $$LocalizationTableOrderingComposer(super.$state);
  ColumnOrderings<String> get locale => $state.composableBuilder(
      column: $state.table.locale,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get message => $state.composableBuilder(
      column: $state.table.message,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get module => $state.composableBuilder(
      column: $state.table.module,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$UserActionTableInsertCompanionBuilder = UserActionCompanion Function({
  required String latitude,
  required String longitude,
  required String locationAccuracy,
  required String clientReferenceId,
  Value<bool> isSync,
  required int timestamp,
  Value<bool?> nonRecoverableError,
  Value<String?> tenantId,
  Value<int?> rowVersion,
  required String projectId,
  required String boundaryCode,
  required String action,
  Value<String?> beneficiaryTag,
  Value<String?> resourceTag,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> auditCreatedBy,
  Value<bool?> isDeleted,
  Value<String?> id,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$UserActionTableUpdateCompanionBuilder = UserActionCompanion Function({
  Value<String> latitude,
  Value<String> longitude,
  Value<String> locationAccuracy,
  Value<String> clientReferenceId,
  Value<bool> isSync,
  Value<int> timestamp,
  Value<bool?> nonRecoverableError,
  Value<String?> tenantId,
  Value<int?> rowVersion,
  Value<String> projectId,
  Value<String> boundaryCode,
  Value<String> action,
  Value<String?> beneficiaryTag,
  Value<String?> resourceTag,
  Value<int?> auditCreatedTime,
  Value<int?> clientCreatedTime,
  Value<String?> clientModifiedBy,
  Value<String?> clientCreatedBy,
  Value<int?> clientModifiedTime,
  Value<String?> auditModifiedBy,
  Value<int?> auditModifiedTime,
  Value<String?> auditCreatedBy,
  Value<bool?> isDeleted,
  Value<String?> id,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$UserActionTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $UserActionTable,
    UserActionData,
    $$UserActionTableFilterComposer,
    $$UserActionTableOrderingComposer,
    $$UserActionTableProcessedTableManager,
    $$UserActionTableInsertCompanionBuilder,
    $$UserActionTableUpdateCompanionBuilder> {
  $$UserActionTableTableManager(_$LocalSqlDataStore db, $UserActionTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$UserActionTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$UserActionTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$UserActionTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String> latitude = const Value.absent(),
            Value<String> longitude = const Value.absent(),
            Value<String> locationAccuracy = const Value.absent(),
            Value<String> clientReferenceId = const Value.absent(),
            Value<bool> isSync = const Value.absent(),
            Value<int> timestamp = const Value.absent(),
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String> projectId = const Value.absent(),
            Value<String> boundaryCode = const Value.absent(),
            Value<String> action = const Value.absent(),
            Value<String?> beneficiaryTag = const Value.absent(),
            Value<String?> resourceTag = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<String?> id = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              UserActionCompanion(
            latitude: latitude,
            longitude: longitude,
            locationAccuracy: locationAccuracy,
            clientReferenceId: clientReferenceId,
            isSync: isSync,
            timestamp: timestamp,
            nonRecoverableError: nonRecoverableError,
            tenantId: tenantId,
            rowVersion: rowVersion,
            projectId: projectId,
            boundaryCode: boundaryCode,
            action: action,
            beneficiaryTag: beneficiaryTag,
            resourceTag: resourceTag,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            auditCreatedBy: auditCreatedBy,
            isDeleted: isDeleted,
            id: id,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String latitude,
            required String longitude,
            required String locationAccuracy,
            required String clientReferenceId,
            Value<bool> isSync = const Value.absent(),
            required int timestamp,
            Value<bool?> nonRecoverableError = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            required String projectId,
            required String boundaryCode,
            required String action,
            Value<String?> beneficiaryTag = const Value.absent(),
            Value<String?> resourceTag = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<int?> clientCreatedTime = const Value.absent(),
            Value<String?> clientModifiedBy = const Value.absent(),
            Value<String?> clientCreatedBy = const Value.absent(),
            Value<int?> clientModifiedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<bool?> isDeleted = const Value.absent(),
            Value<String?> id = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              UserActionCompanion.insert(
            latitude: latitude,
            longitude: longitude,
            locationAccuracy: locationAccuracy,
            clientReferenceId: clientReferenceId,
            isSync: isSync,
            timestamp: timestamp,
            nonRecoverableError: nonRecoverableError,
            tenantId: tenantId,
            rowVersion: rowVersion,
            projectId: projectId,
            boundaryCode: boundaryCode,
            action: action,
            beneficiaryTag: beneficiaryTag,
            resourceTag: resourceTag,
            auditCreatedTime: auditCreatedTime,
            clientCreatedTime: clientCreatedTime,
            clientModifiedBy: clientModifiedBy,
            clientCreatedBy: clientCreatedBy,
            clientModifiedTime: clientModifiedTime,
            auditModifiedBy: auditModifiedBy,
            auditModifiedTime: auditModifiedTime,
            auditCreatedBy: auditCreatedBy,
            isDeleted: isDeleted,
            id: id,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$UserActionTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $UserActionTable,
    UserActionData,
    $$UserActionTableFilterComposer,
    $$UserActionTableOrderingComposer,
    $$UserActionTableProcessedTableManager,
    $$UserActionTableInsertCompanionBuilder,
    $$UserActionTableUpdateCompanionBuilder> {
  $$UserActionTableProcessedTableManager(super.$state);
}

class $$UserActionTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $UserActionTable> {
  $$UserActionTableFilterComposer(super.$state);
  ColumnFilters<String> get latitude => $state.composableBuilder(
      column: $state.table.latitude,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get longitude => $state.composableBuilder(
      column: $state.table.longitude,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get locationAccuracy => $state.composableBuilder(
      column: $state.table.locationAccuracy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isSync => $state.composableBuilder(
      column: $state.table.isSync,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get timestamp => $state.composableBuilder(
      column: $state.table.timestamp,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get boundaryCode => $state.composableBuilder(
      column: $state.table.boundaryCode,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get action => $state.composableBuilder(
      column: $state.table.action,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get beneficiaryTag => $state.composableBuilder(
      column: $state.table.beneficiaryTag,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get resourceTag => $state.composableBuilder(
      column: $state.table.resourceTag,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$UserActionTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $UserActionTable> {
  $$UserActionTableOrderingComposer(super.$state);
  ColumnOrderings<String> get latitude => $state.composableBuilder(
      column: $state.table.latitude,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get longitude => $state.composableBuilder(
      column: $state.table.longitude,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get locationAccuracy => $state.composableBuilder(
      column: $state.table.locationAccuracy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientReferenceId => $state.composableBuilder(
      column: $state.table.clientReferenceId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isSync => $state.composableBuilder(
      column: $state.table.isSync,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get timestamp => $state.composableBuilder(
      column: $state.table.timestamp,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get nonRecoverableError => $state.composableBuilder(
      column: $state.table.nonRecoverableError,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get projectId => $state.composableBuilder(
      column: $state.table.projectId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get boundaryCode => $state.composableBuilder(
      column: $state.table.boundaryCode,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get action => $state.composableBuilder(
      column: $state.table.action,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get beneficiaryTag => $state.composableBuilder(
      column: $state.table.beneficiaryTag,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get resourceTag => $state.composableBuilder(
      column: $state.table.resourceTag,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientCreatedTime => $state.composableBuilder(
      column: $state.table.clientCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientModifiedBy => $state.composableBuilder(
      column: $state.table.clientModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get clientCreatedBy => $state.composableBuilder(
      column: $state.table.clientCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get clientModifiedTime => $state.composableBuilder(
      column: $state.table.clientModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<bool> get isDeleted => $state.composableBuilder(
      column: $state.table.isDeleted,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$UniqueIdPoolTableInsertCompanionBuilder = UniqueIdPoolCompanion
    Function({
  required String id,
  Value<String?> deviceUuid,
  Value<String?> userUuid,
  Value<String?> status,
  Value<int?> auditCreatedTime,
  Value<String?> auditModifiedBy,
  Value<String?> auditCreatedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});
typedef $$UniqueIdPoolTableUpdateCompanionBuilder = UniqueIdPoolCompanion
    Function({
  Value<String> id,
  Value<String?> deviceUuid,
  Value<String?> userUuid,
  Value<String?> status,
  Value<int?> auditCreatedTime,
  Value<String?> auditModifiedBy,
  Value<String?> auditCreatedBy,
  Value<int?> auditModifiedTime,
  Value<String?> tenantId,
  Value<int?> rowVersion,
  Value<String?> additionalFields,
  Value<int> rowid,
});

class $$UniqueIdPoolTableTableManager extends RootTableManager<
    _$LocalSqlDataStore,
    $UniqueIdPoolTable,
    UniqueIdPoolData,
    $$UniqueIdPoolTableFilterComposer,
    $$UniqueIdPoolTableOrderingComposer,
    $$UniqueIdPoolTableProcessedTableManager,
    $$UniqueIdPoolTableInsertCompanionBuilder,
    $$UniqueIdPoolTableUpdateCompanionBuilder> {
  $$UniqueIdPoolTableTableManager(
      _$LocalSqlDataStore db, $UniqueIdPoolTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$UniqueIdPoolTableFilterComposer(ComposerState(db, table)),
          orderingComposer:
              $$UniqueIdPoolTableOrderingComposer(ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$UniqueIdPoolTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            Value<String> id = const Value.absent(),
            Value<String?> deviceUuid = const Value.absent(),
            Value<String?> userUuid = const Value.absent(),
            Value<String?> status = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              UniqueIdPoolCompanion(
            id: id,
            deviceUuid: deviceUuid,
            userUuid: userUuid,
            status: status,
            auditCreatedTime: auditCreatedTime,
            auditModifiedBy: auditModifiedBy,
            auditCreatedBy: auditCreatedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String id,
            Value<String?> deviceUuid = const Value.absent(),
            Value<String?> userUuid = const Value.absent(),
            Value<String?> status = const Value.absent(),
            Value<int?> auditCreatedTime = const Value.absent(),
            Value<String?> auditModifiedBy = const Value.absent(),
            Value<String?> auditCreatedBy = const Value.absent(),
            Value<int?> auditModifiedTime = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<int?> rowVersion = const Value.absent(),
            Value<String?> additionalFields = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              UniqueIdPoolCompanion.insert(
            id: id,
            deviceUuid: deviceUuid,
            userUuid: userUuid,
            status: status,
            auditCreatedTime: auditCreatedTime,
            auditModifiedBy: auditModifiedBy,
            auditCreatedBy: auditCreatedBy,
            auditModifiedTime: auditModifiedTime,
            tenantId: tenantId,
            rowVersion: rowVersion,
            additionalFields: additionalFields,
            rowid: rowid,
          ),
        ));
}

class $$UniqueIdPoolTableProcessedTableManager extends ProcessedTableManager<
    _$LocalSqlDataStore,
    $UniqueIdPoolTable,
    UniqueIdPoolData,
    $$UniqueIdPoolTableFilterComposer,
    $$UniqueIdPoolTableOrderingComposer,
    $$UniqueIdPoolTableProcessedTableManager,
    $$UniqueIdPoolTableInsertCompanionBuilder,
    $$UniqueIdPoolTableUpdateCompanionBuilder> {
  $$UniqueIdPoolTableProcessedTableManager(super.$state);
}

class $$UniqueIdPoolTableFilterComposer
    extends FilterComposer<_$LocalSqlDataStore, $UniqueIdPoolTable> {
  $$UniqueIdPoolTableFilterComposer(super.$state);
  ColumnFilters<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get deviceUuid => $state.composableBuilder(
      column: $state.table.deviceUuid,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get userUuid => $state.composableBuilder(
      column: $state.table.userUuid,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get status => $state.composableBuilder(
      column: $state.table.status,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));

  ColumnFilters<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$UniqueIdPoolTableOrderingComposer
    extends OrderingComposer<_$LocalSqlDataStore, $UniqueIdPoolTable> {
  $$UniqueIdPoolTableOrderingComposer(super.$state);
  ColumnOrderings<String> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get deviceUuid => $state.composableBuilder(
      column: $state.table.deviceUuid,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get userUuid => $state.composableBuilder(
      column: $state.table.userUuid,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get status => $state.composableBuilder(
      column: $state.table.status,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditCreatedTime => $state.composableBuilder(
      column: $state.table.auditCreatedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditModifiedBy => $state.composableBuilder(
      column: $state.table.auditModifiedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get auditCreatedBy => $state.composableBuilder(
      column: $state.table.auditCreatedBy,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get auditModifiedTime => $state.composableBuilder(
      column: $state.table.auditModifiedTime,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get tenantId => $state.composableBuilder(
      column: $state.table.tenantId,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<int> get rowVersion => $state.composableBuilder(
      column: $state.table.rowVersion,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));

  ColumnOrderings<String> get additionalFields => $state.composableBuilder(
      column: $state.table.additionalFields,
      builder: (column, joinBuilders) =>
          ColumnOrderings(column, joinBuilders: joinBuilders));
}

class _$LocalSqlDataStoreManager {
  final _$LocalSqlDataStore _db;
  _$LocalSqlDataStoreManager(this._db);
  $$AttendanceRegisterTableTableManager get attendanceRegister =>
      $$AttendanceRegisterTableTableManager(_db, _db.attendanceRegister);
  $$AttendanceTableTableManager get attendance =>
      $$AttendanceTableTableManager(_db, _db.attendance);
  $$AttendeeTableTableManager get attendee =>
      $$AttendeeTableTableManager(_db, _db.attendee);
  $$AddressTableTableManager get address =>
      $$AddressTableTableManager(_db, _db.address);
  $$NameTableTableManager get name => $$NameTableTableManager(_db, _db.name);
  $$BoundaryTableTableManager get boundary =>
      $$BoundaryTableTableManager(_db, _db.boundary);
  $$DocumentTableTableManager get document =>
      $$DocumentTableTableManager(_db, _db.document);
  $$FacilityTableTableManager get facility =>
      $$FacilityTableTableManager(_db, _db.facility);
  $$ProductTableTableManager get product =>
      $$ProductTableTableManager(_db, _db.product);
  $$ProductVariantTableTableManager get productVariant =>
      $$ProductVariantTableTableManager(_db, _db.productVariant);
  $$ProjectTableTableManager get project =>
      $$ProjectTableTableManager(_db, _db.project);
  $$ProjectBeneficiaryTableTableManager get projectBeneficiary =>
      $$ProjectBeneficiaryTableTableManager(_db, _db.projectBeneficiary);
  $$ProjectFacilityTableTableManager get projectFacility =>
      $$ProjectFacilityTableTableManager(_db, _db.projectFacility);
  $$ProjectProductVariantTableTableManager get projectProductVariant =>
      $$ProjectProductVariantTableTableManager(_db, _db.projectProductVariant);
  $$ProjectResourceTableTableManager get projectResource =>
      $$ProjectResourceTableTableManager(_db, _db.projectResource);
  $$ProjectStaffTableTableManager get projectStaff =>
      $$ProjectStaffTableTableManager(_db, _db.projectStaff);
  $$ProjectTypeTableTableManager get projectType =>
      $$ProjectTypeTableTableManager(_db, _db.projectType);
  $$IndividualTableTableManager get individual =>
      $$IndividualTableTableManager(_db, _db.individual);
  $$IdentifierTableTableManager get identifier =>
      $$IdentifierTableTableManager(_db, _db.identifier);
  $$StockTableTableManager get stock =>
      $$StockTableTableManager(_db, _db.stock);
  $$StockReconciliationTableTableManager get stockReconciliation =>
      $$StockReconciliationTableTableManager(_db, _db.stockReconciliation);
  $$TargetTableTableManager get target =>
      $$TargetTableTableManager(_db, _db.target);
  $$ServiceTableTableManager get service =>
      $$ServiceTableTableManager(_db, _db.service);
  $$ServiceAttributesTableTableManager get serviceAttributes =>
      $$ServiceAttributesTableTableManager(_db, _db.serviceAttributes);
  $$ServiceDefinitionTableTableManager get serviceDefinition =>
      $$ServiceDefinitionTableTableManager(_db, _db.serviceDefinition);
  $$LocalityTableTableManager get locality =>
      $$LocalityTableTableManager(_db, _db.locality);
  $$StaffTableTableManager get staff =>
      $$StaffTableTableManager(_db, _db.staff);
  $$AttributesTableTableManager get attributes =>
      $$AttributesTableTableManager(_db, _db.attributes);
  $$PgrServiceTableTableManager get pgrService =>
      $$PgrServiceTableTableManager(_db, _db.pgrService);
  $$PgrComplainantTableTableManager get pgrComplainant =>
      $$PgrComplainantTableTableManager(_db, _db.pgrComplainant);
  $$UserTableTableManager get user => $$UserTableTableManager(_db, _db.user);
  $$DownsyncTableTableManager get downsync =>
      $$DownsyncTableTableManager(_db, _db.downsync);
  $$DownsyncCriteriaTableTableManager get downsyncCriteria =>
      $$DownsyncCriteriaTableTableManager(_db, _db.downsyncCriteria);
  $$HFReferralTableTableManager get hFReferral =>
      $$HFReferralTableTableManager(_db, _db.hFReferral);
  $$HouseholdTableTableManager get household =>
      $$HouseholdTableTableManager(_db, _db.household);
  $$HouseholdMemberTableTableManager get householdMember =>
      $$HouseholdMemberTableTableManager(_db, _db.householdMember);
  $$HouseholdMemberRelationShipTableTableManager
      get householdMemberRelationShip =>
          $$HouseholdMemberRelationShipTableTableManager(
              _db, _db.householdMemberRelationShip);
  $$TaskTableTableManager get task => $$TaskTableTableManager(_db, _db.task);
  $$TaskResourceTableTableManager get taskResource =>
      $$TaskResourceTableTableManager(_db, _db.taskResource);
  $$SideEffectTableTableManager get sideEffect =>
      $$SideEffectTableTableManager(_db, _db.sideEffect);
  $$ReferralTableTableManager get referral =>
      $$ReferralTableTableManager(_db, _db.referral);
  $$LocalizationTableTableManager get localization =>
      $$LocalizationTableTableManager(_db, _db.localization);
  $$UserActionTableTableManager get userAction =>
      $$UserActionTableTableManager(_db, _db.userAction);
  $$UniqueIdPoolTableTableManager get uniqueIdPool =>
      $$UniqueIdPoolTableTableManager(_db, _db.uniqueIdPool);
}
