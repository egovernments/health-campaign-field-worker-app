// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sql_store.dart';

// ignore_for_file: type=lint
class $AttendanceRegisterTable extends AttendanceRegister
    with TableInfo<$AttendanceRegisterTable, AttendanceRegisterData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AttendanceRegisterTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _registerNumberMeta =
      const VerificationMeta('registerNumber');
  @override
  late final GeneratedColumn<String> registerNumber = GeneratedColumn<String>(
      'register_number', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _serviceCodeMeta =
      const VerificationMeta('serviceCode');
  @override
  late final GeneratedColumn<String> serviceCode = GeneratedColumn<String>(
      'service_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _startDateMeta =
      const VerificationMeta('startDate');
  @override
  late final GeneratedColumn<int> startDate = GeneratedColumn<int>(
      'start_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _endDateMeta =
      const VerificationMeta('endDate');
  @override
  late final GeneratedColumn<int> endDate = GeneratedColumn<int>(
      'end_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        registerNumber,
        name,
        referenceId,
        serviceCode,
        status,
        startDate,
        endDate,
        additionalFields,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'attendance_register';
  @override
  VerificationContext validateIntegrity(
      Insertable<AttendanceRegisterData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('register_number')) {
      context.handle(
          _registerNumberMeta,
          registerNumber.isAcceptableOrUnknown(
              data['register_number']!, _registerNumberMeta));
    } else if (isInserting) {
      context.missing(_registerNumberMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    } else if (isInserting) {
      context.missing(_referenceIdMeta);
    }
    if (data.containsKey('service_code')) {
      context.handle(
          _serviceCodeMeta,
          serviceCode.isAcceptableOrUnknown(
              data['service_code']!, _serviceCodeMeta));
    } else if (isInserting) {
      context.missing(_serviceCodeMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  AttendanceRegisterData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AttendanceRegisterData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      registerNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}register_number'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id'])!,
      serviceCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}service_code'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      startDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}start_date']),
      endDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}end_date']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
    );
  }

  @override
  $AttendanceRegisterTable createAlias(String alias) {
    return $AttendanceRegisterTable(attachedDatabase, alias);
  }
}

class AttendanceRegisterData extends DataClass
    implements Insertable<AttendanceRegisterData> {
  final String? id;
  final String tenantId;
  final String registerNumber;
  final String name;
  final String referenceId;
  final String serviceCode;
  final String status;
  final int? startDate;
  final int? endDate;
  final String? additionalFields;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool? isDeleted;
  final int? rowVersion;
  const AttendanceRegisterData(
      {this.id,
      required this.tenantId,
      required this.registerNumber,
      required this.name,
      required this.referenceId,
      required this.serviceCode,
      required this.status,
      this.startDate,
      this.endDate,
      this.additionalFields,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.isDeleted,
      this.rowVersion});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    map['tenant_id'] = Variable<String>(tenantId);
    map['register_number'] = Variable<String>(registerNumber);
    map['name'] = Variable<String>(name);
    map['reference_id'] = Variable<String>(referenceId);
    map['service_code'] = Variable<String>(serviceCode);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || startDate != null) {
      map['start_date'] = Variable<int>(startDate);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<int>(endDate);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    return map;
  }

  AttendanceRegisterCompanion toCompanion(bool nullToAbsent) {
    return AttendanceRegisterCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: Value(tenantId),
      registerNumber: Value(registerNumber),
      name: Value(name),
      referenceId: Value(referenceId),
      serviceCode: Value(serviceCode),
      status: Value(status),
      startDate: startDate == null && nullToAbsent
          ? const Value.absent()
          : Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
    );
  }

  factory AttendanceRegisterData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AttendanceRegisterData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String>(json['tenantId']),
      registerNumber: serializer.fromJson<String>(json['registerNumber']),
      name: serializer.fromJson<String>(json['name']),
      referenceId: serializer.fromJson<String>(json['referenceId']),
      serviceCode: serializer.fromJson<String>(json['serviceCode']),
      status: serializer.fromJson<String>(json['status']),
      startDate: serializer.fromJson<int?>(json['startDate']),
      endDate: serializer.fromJson<int?>(json['endDate']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String>(tenantId),
      'registerNumber': serializer.toJson<String>(registerNumber),
      'name': serializer.toJson<String>(name),
      'referenceId': serializer.toJson<String>(referenceId),
      'serviceCode': serializer.toJson<String>(serviceCode),
      'status': serializer.toJson<String>(status),
      'startDate': serializer.toJson<int?>(startDate),
      'endDate': serializer.toJson<int?>(endDate),
      'additionalFields': serializer.toJson<String?>(additionalFields),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
    };
  }

  AttendanceRegisterData copyWith(
          {Value<String?> id = const Value.absent(),
          String? tenantId,
          String? registerNumber,
          String? name,
          String? referenceId,
          String? serviceCode,
          String? status,
          Value<int?> startDate = const Value.absent(),
          Value<int?> endDate = const Value.absent(),
          Value<String?> additionalFields = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent()}) =>
      AttendanceRegisterData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId ?? this.tenantId,
        registerNumber: registerNumber ?? this.registerNumber,
        name: name ?? this.name,
        referenceId: referenceId ?? this.referenceId,
        serviceCode: serviceCode ?? this.serviceCode,
        status: status ?? this.status,
        startDate: startDate.present ? startDate.value : this.startDate,
        endDate: endDate.present ? endDate.value : this.endDate,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
      );
  @override
  String toString() {
    return (StringBuffer('AttendanceRegisterData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerNumber: $registerNumber, ')
          ..write('name: $name, ')
          ..write('referenceId: $referenceId, ')
          ..write('serviceCode: $serviceCode, ')
          ..write('status: $status, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        tenantId,
        registerNumber,
        name,
        referenceId,
        serviceCode,
        status,
        startDate,
        endDate,
        additionalFields,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AttendanceRegisterData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.registerNumber == this.registerNumber &&
          other.name == this.name &&
          other.referenceId == this.referenceId &&
          other.serviceCode == this.serviceCode &&
          other.status == this.status &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.additionalFields == this.additionalFields &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion);
}

class AttendanceRegisterCompanion
    extends UpdateCompanion<AttendanceRegisterData> {
  final Value<String?> id;
  final Value<String> tenantId;
  final Value<String> registerNumber;
  final Value<String> name;
  final Value<String> referenceId;
  final Value<String> serviceCode;
  final Value<String> status;
  final Value<int?> startDate;
  final Value<int?> endDate;
  final Value<String?> additionalFields;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int> rowid;
  const AttendanceRegisterCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.registerNumber = const Value.absent(),
    this.name = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.serviceCode = const Value.absent(),
    this.status = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AttendanceRegisterCompanion.insert({
    this.id = const Value.absent(),
    required String tenantId,
    required String registerNumber,
    required String name,
    required String referenceId,
    required String serviceCode,
    required String status,
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : tenantId = Value(tenantId),
        registerNumber = Value(registerNumber),
        name = Value(name),
        referenceId = Value(referenceId),
        serviceCode = Value(serviceCode),
        status = Value(status);
  static Insertable<AttendanceRegisterData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? registerNumber,
    Expression<String>? name,
    Expression<String>? referenceId,
    Expression<String>? serviceCode,
    Expression<String>? status,
    Expression<int>? startDate,
    Expression<int>? endDate,
    Expression<String>? additionalFields,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (registerNumber != null) 'register_number': registerNumber,
      if (name != null) 'name': name,
      if (referenceId != null) 'reference_id': referenceId,
      if (serviceCode != null) 'service_code': serviceCode,
      if (status != null) 'status': status,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AttendanceRegisterCompanion copyWith(
      {Value<String?>? id,
      Value<String>? tenantId,
      Value<String>? registerNumber,
      Value<String>? name,
      Value<String>? referenceId,
      Value<String>? serviceCode,
      Value<String>? status,
      Value<int?>? startDate,
      Value<int?>? endDate,
      Value<String?>? additionalFields,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int>? rowid}) {
    return AttendanceRegisterCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      registerNumber: registerNumber ?? this.registerNumber,
      name: name ?? this.name,
      referenceId: referenceId ?? this.referenceId,
      serviceCode: serviceCode ?? this.serviceCode,
      status: status ?? this.status,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      additionalFields: additionalFields ?? this.additionalFields,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (registerNumber.present) {
      map['register_number'] = Variable<String>(registerNumber.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (serviceCode.present) {
      map['service_code'] = Variable<String>(serviceCode.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<int>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<int>(endDate.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AttendanceRegisterCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerNumber: $registerNumber, ')
          ..write('name: $name, ')
          ..write('referenceId: $referenceId, ')
          ..write('serviceCode: $serviceCode, ')
          ..write('status: $status, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AttendanceTable extends Attendance
    with TableInfo<$AttendanceTable, AttendanceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AttendanceTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _registerIdMeta =
      const VerificationMeta('registerId');
  @override
  late final GeneratedColumn<String> registerId = GeneratedColumn<String>(
      'register_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _individualIdMeta =
      const VerificationMeta('individualId');
  @override
  late final GeneratedColumn<String> individualId = GeneratedColumn<String>(
      'individual_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _timeMeta = const VerificationMeta('time');
  @override
  late final GeneratedColumn<int> time = GeneratedColumn<int>(
      'time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _uploadToServerMeta =
      const VerificationMeta('uploadToServer');
  @override
  late final GeneratedColumn<bool> uploadToServer = GeneratedColumn<bool>(
      'upload_to_server', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("upload_to_server" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        clientReferenceId,
        tenantId,
        registerId,
        individualId,
        time,
        status,
        type,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditCreatedBy,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields,
        uploadToServer
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'attendance';
  @override
  VerificationContext validateIntegrity(Insertable<AttendanceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('register_id')) {
      context.handle(
          _registerIdMeta,
          registerId.isAcceptableOrUnknown(
              data['register_id']!, _registerIdMeta));
    } else if (isInserting) {
      context.missing(_registerIdMeta);
    }
    if (data.containsKey('individual_id')) {
      context.handle(
          _individualIdMeta,
          individualId.isAcceptableOrUnknown(
              data['individual_id']!, _individualIdMeta));
    } else if (isInserting) {
      context.missing(_individualIdMeta);
    }
    if (data.containsKey('time')) {
      context.handle(
          _timeMeta, time.isAcceptableOrUnknown(data['time']!, _timeMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    if (data.containsKey('upload_to_server')) {
      context.handle(
          _uploadToServerMeta,
          uploadToServer.isAcceptableOrUnknown(
              data['upload_to_server']!, _uploadToServerMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey =>
      {registerId, individualId, tenantId, type, clientReferenceId};
  @override
  AttendanceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AttendanceData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      registerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}register_id'])!,
      individualId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}individual_id'])!,
      time: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}time']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
      uploadToServer: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}upload_to_server']),
    );
  }

  @override
  $AttendanceTable createAlias(String alias) {
    return $AttendanceTable(attachedDatabase, alias);
  }
}

class AttendanceData extends DataClass implements Insertable<AttendanceData> {
  final String? id;
  final String? clientReferenceId;
  final String tenantId;
  final String registerId;
  final String individualId;
  final int? time;
  final String? status;
  final String? type;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditCreatedBy;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  final bool? uploadToServer;
  const AttendanceData(
      {this.id,
      this.clientReferenceId,
      required this.tenantId,
      required this.registerId,
      required this.individualId,
      this.time,
      this.status,
      this.type,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditCreatedBy,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields,
      this.uploadToServer});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || clientReferenceId != null) {
      map['client_reference_id'] = Variable<String>(clientReferenceId);
    }
    map['tenant_id'] = Variable<String>(tenantId);
    map['register_id'] = Variable<String>(registerId);
    map['individual_id'] = Variable<String>(individualId);
    if (!nullToAbsent || time != null) {
      map['time'] = Variable<int>(time);
    }
    if (!nullToAbsent || status != null) {
      map['status'] = Variable<String>(status);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    if (!nullToAbsent || uploadToServer != null) {
      map['upload_to_server'] = Variable<bool>(uploadToServer);
    }
    return map;
  }

  AttendanceCompanion toCompanion(bool nullToAbsent) {
    return AttendanceCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      clientReferenceId: clientReferenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(clientReferenceId),
      tenantId: Value(tenantId),
      registerId: Value(registerId),
      individualId: Value(individualId),
      time: time == null && nullToAbsent ? const Value.absent() : Value(time),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
      uploadToServer: uploadToServer == null && nullToAbsent
          ? const Value.absent()
          : Value(uploadToServer),
    );
  }

  factory AttendanceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AttendanceData(
      id: serializer.fromJson<String?>(json['id']),
      clientReferenceId:
          serializer.fromJson<String?>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String>(json['tenantId']),
      registerId: serializer.fromJson<String>(json['registerId']),
      individualId: serializer.fromJson<String>(json['individualId']),
      time: serializer.fromJson<int?>(json['time']),
      status: serializer.fromJson<String?>(json['status']),
      type: serializer.fromJson<String?>(json['type']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
      uploadToServer: serializer.fromJson<bool?>(json['uploadToServer']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'clientReferenceId': serializer.toJson<String?>(clientReferenceId),
      'tenantId': serializer.toJson<String>(tenantId),
      'registerId': serializer.toJson<String>(registerId),
      'individualId': serializer.toJson<String>(individualId),
      'time': serializer.toJson<int?>(time),
      'status': serializer.toJson<String?>(status),
      'type': serializer.toJson<String?>(type),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
      'uploadToServer': serializer.toJson<bool?>(uploadToServer),
    };
  }

  AttendanceData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> clientReferenceId = const Value.absent(),
          String? tenantId,
          String? registerId,
          String? individualId,
          Value<int?> time = const Value.absent(),
          Value<String?> status = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent(),
          Value<bool?> uploadToServer = const Value.absent()}) =>
      AttendanceData(
        id: id.present ? id.value : this.id,
        clientReferenceId: clientReferenceId.present
            ? clientReferenceId.value
            : this.clientReferenceId,
        tenantId: tenantId ?? this.tenantId,
        registerId: registerId ?? this.registerId,
        individualId: individualId ?? this.individualId,
        time: time.present ? time.value : this.time,
        status: status.present ? status.value : this.status,
        type: type.present ? type.value : this.type,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
        uploadToServer:
            uploadToServer.present ? uploadToServer.value : this.uploadToServer,
      );
  @override
  String toString() {
    return (StringBuffer('AttendanceData(')
          ..write('id: $id, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerId: $registerId, ')
          ..write('individualId: $individualId, ')
          ..write('time: $time, ')
          ..write('status: $status, ')
          ..write('type: $type, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('uploadToServer: $uploadToServer')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        clientReferenceId,
        tenantId,
        registerId,
        individualId,
        time,
        status,
        type,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditCreatedBy,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields,
        uploadToServer
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AttendanceData &&
          other.id == this.id &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.registerId == this.registerId &&
          other.individualId == this.individualId &&
          other.time == this.time &&
          other.status == this.status &&
          other.type == this.type &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields &&
          other.uploadToServer == this.uploadToServer);
}

class AttendanceCompanion extends UpdateCompanion<AttendanceData> {
  final Value<String?> id;
  final Value<String?> clientReferenceId;
  final Value<String> tenantId;
  final Value<String> registerId;
  final Value<String> individualId;
  final Value<int?> time;
  final Value<String?> status;
  final Value<String?> type;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditCreatedBy;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<bool?> uploadToServer;
  final Value<int> rowid;
  const AttendanceCompanion({
    this.id = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.registerId = const Value.absent(),
    this.individualId = const Value.absent(),
    this.time = const Value.absent(),
    this.status = const Value.absent(),
    this.type = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.uploadToServer = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AttendanceCompanion.insert({
    this.id = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    required String tenantId,
    required String registerId,
    required String individualId,
    this.time = const Value.absent(),
    this.status = const Value.absent(),
    this.type = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.uploadToServer = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : tenantId = Value(tenantId),
        registerId = Value(registerId),
        individualId = Value(individualId);
  static Insertable<AttendanceData> custom({
    Expression<String>? id,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<String>? registerId,
    Expression<String>? individualId,
    Expression<int>? time,
    Expression<String>? status,
    Expression<String>? type,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditCreatedBy,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<bool>? uploadToServer,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (registerId != null) 'register_id': registerId,
      if (individualId != null) 'individual_id': individualId,
      if (time != null) 'time': time,
      if (status != null) 'status': status,
      if (type != null) 'type': type,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (uploadToServer != null) 'upload_to_server': uploadToServer,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AttendanceCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? clientReferenceId,
      Value<String>? tenantId,
      Value<String>? registerId,
      Value<String>? individualId,
      Value<int?>? time,
      Value<String?>? status,
      Value<String?>? type,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditCreatedBy,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<bool?>? uploadToServer,
      Value<int>? rowid}) {
    return AttendanceCompanion(
      id: id ?? this.id,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      registerId: registerId ?? this.registerId,
      individualId: individualId ?? this.individualId,
      time: time ?? this.time,
      status: status ?? this.status,
      type: type ?? this.type,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      uploadToServer: uploadToServer ?? this.uploadToServer,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (registerId.present) {
      map['register_id'] = Variable<String>(registerId.value);
    }
    if (individualId.present) {
      map['individual_id'] = Variable<String>(individualId.value);
    }
    if (time.present) {
      map['time'] = Variable<int>(time.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (uploadToServer.present) {
      map['upload_to_server'] = Variable<bool>(uploadToServer.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AttendanceCompanion(')
          ..write('id: $id, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerId: $registerId, ')
          ..write('individualId: $individualId, ')
          ..write('time: $time, ')
          ..write('status: $status, ')
          ..write('type: $type, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('uploadToServer: $uploadToServer, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AttendeeTable extends Attendee
    with TableInfo<$AttendeeTable, AttendeeData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AttendeeTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _registerIdMeta =
      const VerificationMeta('registerId');
  @override
  late final GeneratedColumn<String> registerId = GeneratedColumn<String>(
      'register_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _individualIdMeta =
      const VerificationMeta('individualId');
  @override
  late final GeneratedColumn<String> individualId = GeneratedColumn<String>(
      'individual_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<int> status = GeneratedColumn<int>(
      'status', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _enrollmentDateMeta =
      const VerificationMeta('enrollmentDate');
  @override
  late final GeneratedColumn<int> enrollmentDate = GeneratedColumn<int>(
      'enrollment_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _denrollmentDateMeta =
      const VerificationMeta('denrollmentDate');
  @override
  late final GeneratedColumn<int> denrollmentDate = GeneratedColumn<int>(
      'denrollment_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        registerId,
        individualId,
        status,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditCreatedBy,
        auditModifiedBy,
        auditModifiedTime,
        enrollmentDate,
        denrollmentDate,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'attendee';
  @override
  VerificationContext validateIntegrity(Insertable<AttendeeData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('register_id')) {
      context.handle(
          _registerIdMeta,
          registerId.isAcceptableOrUnknown(
              data['register_id']!, _registerIdMeta));
    } else if (isInserting) {
      context.missing(_registerIdMeta);
    }
    if (data.containsKey('individual_id')) {
      context.handle(
          _individualIdMeta,
          individualId.isAcceptableOrUnknown(
              data['individual_id']!, _individualIdMeta));
    } else if (isInserting) {
      context.missing(_individualIdMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('enrollment_date')) {
      context.handle(
          _enrollmentDateMeta,
          enrollmentDate.isAcceptableOrUnknown(
              data['enrollment_date']!, _enrollmentDateMeta));
    }
    if (data.containsKey('denrollment_date')) {
      context.handle(
          _denrollmentDateMeta,
          denrollmentDate.isAcceptableOrUnknown(
              data['denrollment_date']!, _denrollmentDateMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, registerId};
  @override
  AttendeeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AttendeeData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      registerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}register_id'])!,
      individualId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}individual_id'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}status']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      enrollmentDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}enrollment_date']),
      denrollmentDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}denrollment_date']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $AttendeeTable createAlias(String alias) {
    return $AttendeeTable(attachedDatabase, alias);
  }
}

class AttendeeData extends DataClass implements Insertable<AttendeeData> {
  final String? id;
  final String tenantId;
  final String registerId;
  final String individualId;
  final int? status;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditCreatedBy;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final int? enrollmentDate;
  final int? denrollmentDate;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const AttendeeData(
      {this.id,
      required this.tenantId,
      required this.registerId,
      required this.individualId,
      this.status,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditCreatedBy,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.enrollmentDate,
      this.denrollmentDate,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    map['tenant_id'] = Variable<String>(tenantId);
    map['register_id'] = Variable<String>(registerId);
    map['individual_id'] = Variable<String>(individualId);
    if (!nullToAbsent || status != null) {
      map['status'] = Variable<int>(status);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || enrollmentDate != null) {
      map['enrollment_date'] = Variable<int>(enrollmentDate);
    }
    if (!nullToAbsent || denrollmentDate != null) {
      map['denrollment_date'] = Variable<int>(denrollmentDate);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  AttendeeCompanion toCompanion(bool nullToAbsent) {
    return AttendeeCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: Value(tenantId),
      registerId: Value(registerId),
      individualId: Value(individualId),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      enrollmentDate: enrollmentDate == null && nullToAbsent
          ? const Value.absent()
          : Value(enrollmentDate),
      denrollmentDate: denrollmentDate == null && nullToAbsent
          ? const Value.absent()
          : Value(denrollmentDate),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory AttendeeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AttendeeData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String>(json['tenantId']),
      registerId: serializer.fromJson<String>(json['registerId']),
      individualId: serializer.fromJson<String>(json['individualId']),
      status: serializer.fromJson<int?>(json['status']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      enrollmentDate: serializer.fromJson<int?>(json['enrollmentDate']),
      denrollmentDate: serializer.fromJson<int?>(json['denrollmentDate']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String>(tenantId),
      'registerId': serializer.toJson<String>(registerId),
      'individualId': serializer.toJson<String>(individualId),
      'status': serializer.toJson<int?>(status),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'enrollmentDate': serializer.toJson<int?>(enrollmentDate),
      'denrollmentDate': serializer.toJson<int?>(denrollmentDate),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  AttendeeData copyWith(
          {Value<String?> id = const Value.absent(),
          String? tenantId,
          String? registerId,
          String? individualId,
          Value<int?> status = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<int?> enrollmentDate = const Value.absent(),
          Value<int?> denrollmentDate = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      AttendeeData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId ?? this.tenantId,
        registerId: registerId ?? this.registerId,
        individualId: individualId ?? this.individualId,
        status: status.present ? status.value : this.status,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        enrollmentDate:
            enrollmentDate.present ? enrollmentDate.value : this.enrollmentDate,
        denrollmentDate: denrollmentDate.present
            ? denrollmentDate.value
            : this.denrollmentDate,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('AttendeeData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerId: $registerId, ')
          ..write('individualId: $individualId, ')
          ..write('status: $status, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('enrollmentDate: $enrollmentDate, ')
          ..write('denrollmentDate: $denrollmentDate, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      tenantId,
      registerId,
      individualId,
      status,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditCreatedBy,
      auditModifiedBy,
      auditModifiedTime,
      enrollmentDate,
      denrollmentDate,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AttendeeData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.registerId == this.registerId &&
          other.individualId == this.individualId &&
          other.status == this.status &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.enrollmentDate == this.enrollmentDate &&
          other.denrollmentDate == this.denrollmentDate &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class AttendeeCompanion extends UpdateCompanion<AttendeeData> {
  final Value<String?> id;
  final Value<String> tenantId;
  final Value<String> registerId;
  final Value<String> individualId;
  final Value<int?> status;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditCreatedBy;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<int?> enrollmentDate;
  final Value<int?> denrollmentDate;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const AttendeeCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.registerId = const Value.absent(),
    this.individualId = const Value.absent(),
    this.status = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.enrollmentDate = const Value.absent(),
    this.denrollmentDate = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AttendeeCompanion.insert({
    this.id = const Value.absent(),
    required String tenantId,
    required String registerId,
    required String individualId,
    this.status = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.enrollmentDate = const Value.absent(),
    this.denrollmentDate = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : tenantId = Value(tenantId),
        registerId = Value(registerId),
        individualId = Value(individualId);
  static Insertable<AttendeeData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? registerId,
    Expression<String>? individualId,
    Expression<int>? status,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditCreatedBy,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<int>? enrollmentDate,
    Expression<int>? denrollmentDate,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (registerId != null) 'register_id': registerId,
      if (individualId != null) 'individual_id': individualId,
      if (status != null) 'status': status,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (enrollmentDate != null) 'enrollment_date': enrollmentDate,
      if (denrollmentDate != null) 'denrollment_date': denrollmentDate,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AttendeeCompanion copyWith(
      {Value<String?>? id,
      Value<String>? tenantId,
      Value<String>? registerId,
      Value<String>? individualId,
      Value<int?>? status,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditCreatedBy,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<int?>? enrollmentDate,
      Value<int?>? denrollmentDate,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return AttendeeCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      registerId: registerId ?? this.registerId,
      individualId: individualId ?? this.individualId,
      status: status ?? this.status,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      enrollmentDate: enrollmentDate ?? this.enrollmentDate,
      denrollmentDate: denrollmentDate ?? this.denrollmentDate,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (registerId.present) {
      map['register_id'] = Variable<String>(registerId.value);
    }
    if (individualId.present) {
      map['individual_id'] = Variable<String>(individualId.value);
    }
    if (status.present) {
      map['status'] = Variable<int>(status.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (enrollmentDate.present) {
      map['enrollment_date'] = Variable<int>(enrollmentDate.value);
    }
    if (denrollmentDate.present) {
      map['denrollment_date'] = Variable<int>(denrollmentDate.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AttendeeCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerId: $registerId, ')
          ..write('individualId: $individualId, ')
          ..write('status: $status, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('enrollmentDate: $enrollmentDate, ')
          ..write('denrollmentDate: $denrollmentDate, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AddressTable extends Address with TableInfo<$AddressTable, Addres> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AddressTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _relatedClientReferenceIdMeta =
      const VerificationMeta('relatedClientReferenceId');
  @override
  late final GeneratedColumn<String> relatedClientReferenceId =
      GeneratedColumn<String>('related_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _doorNoMeta = const VerificationMeta('doorNo');
  @override
  late final GeneratedColumn<String> doorNo = GeneratedColumn<String>(
      'door_no', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
      'latitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
      'longitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _locationAccuracyMeta =
      const VerificationMeta('locationAccuracy');
  @override
  late final GeneratedColumn<double> locationAccuracy = GeneratedColumn<double>(
      'location_accuracy', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _addressLine1Meta =
      const VerificationMeta('addressLine1');
  @override
  late final GeneratedColumn<String> addressLine1 = GeneratedColumn<String>(
      'address_line1', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _addressLine2Meta =
      const VerificationMeta('addressLine2');
  @override
  late final GeneratedColumn<String> addressLine2 = GeneratedColumn<String>(
      'address_line2', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _landmarkMeta =
      const VerificationMeta('landmark');
  @override
  late final GeneratedColumn<String> landmark = GeneratedColumn<String>(
      'landmark', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _cityMeta = const VerificationMeta('city');
  @override
  late final GeneratedColumn<String> city = GeneratedColumn<String>(
      'city', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _pincodeMeta =
      const VerificationMeta('pincode');
  @override
  late final GeneratedColumn<String> pincode = GeneratedColumn<String>(
      'pincode', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _buildingNameMeta =
      const VerificationMeta('buildingName');
  @override
  late final GeneratedColumn<String> buildingName = GeneratedColumn<String>(
      'building_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _streetMeta = const VerificationMeta('street');
  @override
  late final GeneratedColumn<String> street = GeneratedColumn<String>(
      'street', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _boundaryTypeMeta =
      const VerificationMeta('boundaryType');
  @override
  late final GeneratedColumn<String> boundaryType = GeneratedColumn<String>(
      'boundary_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _boundaryMeta =
      const VerificationMeta('boundary');
  @override
  late final GeneratedColumn<String> boundary = GeneratedColumn<String>(
      'boundary', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _localityBoundaryCodeMeta =
      const VerificationMeta('localityBoundaryCode');
  @override
  late final GeneratedColumn<String> localityBoundaryCode =
      GeneratedColumn<String>('locality_boundary_code', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _localityBoundaryNameMeta =
      const VerificationMeta('localityBoundaryName');
  @override
  late final GeneratedColumn<String> localityBoundaryName =
      GeneratedColumn<String>('locality_boundary_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumnWithTypeConverter<AddressType?, int> type =
      GeneratedColumn<int>('type', aliasedName, true,
              type: DriftSqlType.int, requiredDuringInsert: false)
          .withConverter<AddressType?>($AddressTable.$convertertypen);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        relatedClientReferenceId,
        doorNo,
        latitude,
        longitude,
        locationAccuracy,
        addressLine1,
        addressLine2,
        landmark,
        city,
        pincode,
        buildingName,
        street,
        boundaryType,
        boundary,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        localityBoundaryCode,
        localityBoundaryName,
        tenantId,
        isDeleted,
        rowVersion,
        type,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'address';
  @override
  VerificationContext validateIntegrity(Insertable<Addres> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('related_client_reference_id')) {
      context.handle(
          _relatedClientReferenceIdMeta,
          relatedClientReferenceId.isAcceptableOrUnknown(
              data['related_client_reference_id']!,
              _relatedClientReferenceIdMeta));
    }
    if (data.containsKey('door_no')) {
      context.handle(_doorNoMeta,
          doorNo.isAcceptableOrUnknown(data['door_no']!, _doorNoMeta));
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    }
    if (data.containsKey('location_accuracy')) {
      context.handle(
          _locationAccuracyMeta,
          locationAccuracy.isAcceptableOrUnknown(
              data['location_accuracy']!, _locationAccuracyMeta));
    }
    if (data.containsKey('address_line1')) {
      context.handle(
          _addressLine1Meta,
          addressLine1.isAcceptableOrUnknown(
              data['address_line1']!, _addressLine1Meta));
    }
    if (data.containsKey('address_line2')) {
      context.handle(
          _addressLine2Meta,
          addressLine2.isAcceptableOrUnknown(
              data['address_line2']!, _addressLine2Meta));
    }
    if (data.containsKey('landmark')) {
      context.handle(_landmarkMeta,
          landmark.isAcceptableOrUnknown(data['landmark']!, _landmarkMeta));
    }
    if (data.containsKey('city')) {
      context.handle(
          _cityMeta, city.isAcceptableOrUnknown(data['city']!, _cityMeta));
    }
    if (data.containsKey('pincode')) {
      context.handle(_pincodeMeta,
          pincode.isAcceptableOrUnknown(data['pincode']!, _pincodeMeta));
    }
    if (data.containsKey('building_name')) {
      context.handle(
          _buildingNameMeta,
          buildingName.isAcceptableOrUnknown(
              data['building_name']!, _buildingNameMeta));
    }
    if (data.containsKey('street')) {
      context.handle(_streetMeta,
          street.isAcceptableOrUnknown(data['street']!, _streetMeta));
    }
    if (data.containsKey('boundary_type')) {
      context.handle(
          _boundaryTypeMeta,
          boundaryType.isAcceptableOrUnknown(
              data['boundary_type']!, _boundaryTypeMeta));
    }
    if (data.containsKey('boundary')) {
      context.handle(_boundaryMeta,
          boundary.isAcceptableOrUnknown(data['boundary']!, _boundaryMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('locality_boundary_code')) {
      context.handle(
          _localityBoundaryCodeMeta,
          localityBoundaryCode.isAcceptableOrUnknown(
              data['locality_boundary_code']!, _localityBoundaryCodeMeta));
    }
    if (data.containsKey('locality_boundary_name')) {
      context.handle(
          _localityBoundaryNameMeta,
          localityBoundaryName.isAcceptableOrUnknown(
              data['locality_boundary_name']!, _localityBoundaryNameMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    context.handle(_typeMeta, const VerificationResult.success());
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey =>
      {relatedClientReferenceId, auditCreatedBy};
  @override
  Addres map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Addres(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      relatedClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}related_client_reference_id']),
      doorNo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}door_no']),
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}latitude']),
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}longitude']),
      locationAccuracy: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}location_accuracy']),
      addressLine1: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address_line1']),
      addressLine2: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address_line2']),
      landmark: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}landmark']),
      city: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}city']),
      pincode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}pincode']),
      buildingName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}building_name']),
      street: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}street']),
      boundaryType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}boundary_type']),
      boundary: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}boundary']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      localityBoundaryCode: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}locality_boundary_code']),
      localityBoundaryName: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}locality_boundary_name']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      type: $AddressTable.$convertertypen.fromSql(attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}type'])),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $AddressTable createAlias(String alias) {
    return $AddressTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<AddressType, int, int> $convertertype =
      const EnumIndexConverter<AddressType>(AddressType.values);
  static JsonTypeConverter2<AddressType?, int?, int?> $convertertypen =
      JsonTypeConverter2.asNullable($convertertype);
}

class Addres extends DataClass implements Insertable<Addres> {
  final String? id;
  final String? relatedClientReferenceId;
  final String? doorNo;
  final double? latitude;
  final double? longitude;
  final double? locationAccuracy;
  final String? addressLine1;
  final String? addressLine2;
  final String? landmark;
  final String? city;
  final String? pincode;
  final String? buildingName;
  final String? street;
  final String? boundaryType;
  final String? boundary;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? localityBoundaryCode;
  final String? localityBoundaryName;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final AddressType? type;
  final String? additionalFields;
  const Addres(
      {this.id,
      this.relatedClientReferenceId,
      this.doorNo,
      this.latitude,
      this.longitude,
      this.locationAccuracy,
      this.addressLine1,
      this.addressLine2,
      this.landmark,
      this.city,
      this.pincode,
      this.buildingName,
      this.street,
      this.boundaryType,
      this.boundary,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.localityBoundaryCode,
      this.localityBoundaryName,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.type,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || relatedClientReferenceId != null) {
      map['related_client_reference_id'] =
          Variable<String>(relatedClientReferenceId);
    }
    if (!nullToAbsent || doorNo != null) {
      map['door_no'] = Variable<String>(doorNo);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || locationAccuracy != null) {
      map['location_accuracy'] = Variable<double>(locationAccuracy);
    }
    if (!nullToAbsent || addressLine1 != null) {
      map['address_line1'] = Variable<String>(addressLine1);
    }
    if (!nullToAbsent || addressLine2 != null) {
      map['address_line2'] = Variable<String>(addressLine2);
    }
    if (!nullToAbsent || landmark != null) {
      map['landmark'] = Variable<String>(landmark);
    }
    if (!nullToAbsent || city != null) {
      map['city'] = Variable<String>(city);
    }
    if (!nullToAbsent || pincode != null) {
      map['pincode'] = Variable<String>(pincode);
    }
    if (!nullToAbsent || buildingName != null) {
      map['building_name'] = Variable<String>(buildingName);
    }
    if (!nullToAbsent || street != null) {
      map['street'] = Variable<String>(street);
    }
    if (!nullToAbsent || boundaryType != null) {
      map['boundary_type'] = Variable<String>(boundaryType);
    }
    if (!nullToAbsent || boundary != null) {
      map['boundary'] = Variable<String>(boundary);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || localityBoundaryCode != null) {
      map['locality_boundary_code'] = Variable<String>(localityBoundaryCode);
    }
    if (!nullToAbsent || localityBoundaryName != null) {
      map['locality_boundary_name'] = Variable<String>(localityBoundaryName);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<int>($AddressTable.$convertertypen.toSql(type));
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  AddressCompanion toCompanion(bool nullToAbsent) {
    return AddressCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      relatedClientReferenceId: relatedClientReferenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(relatedClientReferenceId),
      doorNo:
          doorNo == null && nullToAbsent ? const Value.absent() : Value(doorNo),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      locationAccuracy: locationAccuracy == null && nullToAbsent
          ? const Value.absent()
          : Value(locationAccuracy),
      addressLine1: addressLine1 == null && nullToAbsent
          ? const Value.absent()
          : Value(addressLine1),
      addressLine2: addressLine2 == null && nullToAbsent
          ? const Value.absent()
          : Value(addressLine2),
      landmark: landmark == null && nullToAbsent
          ? const Value.absent()
          : Value(landmark),
      city: city == null && nullToAbsent ? const Value.absent() : Value(city),
      pincode: pincode == null && nullToAbsent
          ? const Value.absent()
          : Value(pincode),
      buildingName: buildingName == null && nullToAbsent
          ? const Value.absent()
          : Value(buildingName),
      street:
          street == null && nullToAbsent ? const Value.absent() : Value(street),
      boundaryType: boundaryType == null && nullToAbsent
          ? const Value.absent()
          : Value(boundaryType),
      boundary: boundary == null && nullToAbsent
          ? const Value.absent()
          : Value(boundary),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      localityBoundaryCode: localityBoundaryCode == null && nullToAbsent
          ? const Value.absent()
          : Value(localityBoundaryCode),
      localityBoundaryName: localityBoundaryName == null && nullToAbsent
          ? const Value.absent()
          : Value(localityBoundaryName),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory Addres.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Addres(
      id: serializer.fromJson<String?>(json['id']),
      relatedClientReferenceId:
          serializer.fromJson<String?>(json['relatedClientReferenceId']),
      doorNo: serializer.fromJson<String?>(json['doorNo']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      locationAccuracy: serializer.fromJson<double?>(json['locationAccuracy']),
      addressLine1: serializer.fromJson<String?>(json['addressLine1']),
      addressLine2: serializer.fromJson<String?>(json['addressLine2']),
      landmark: serializer.fromJson<String?>(json['landmark']),
      city: serializer.fromJson<String?>(json['city']),
      pincode: serializer.fromJson<String?>(json['pincode']),
      buildingName: serializer.fromJson<String?>(json['buildingName']),
      street: serializer.fromJson<String?>(json['street']),
      boundaryType: serializer.fromJson<String?>(json['boundaryType']),
      boundary: serializer.fromJson<String?>(json['boundary']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      localityBoundaryCode:
          serializer.fromJson<String?>(json['localityBoundaryCode']),
      localityBoundaryName:
          serializer.fromJson<String?>(json['localityBoundaryName']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      type: $AddressTable.$convertertypen
          .fromJson(serializer.fromJson<int?>(json['type'])),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'relatedClientReferenceId':
          serializer.toJson<String?>(relatedClientReferenceId),
      'doorNo': serializer.toJson<String?>(doorNo),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'locationAccuracy': serializer.toJson<double?>(locationAccuracy),
      'addressLine1': serializer.toJson<String?>(addressLine1),
      'addressLine2': serializer.toJson<String?>(addressLine2),
      'landmark': serializer.toJson<String?>(landmark),
      'city': serializer.toJson<String?>(city),
      'pincode': serializer.toJson<String?>(pincode),
      'buildingName': serializer.toJson<String?>(buildingName),
      'street': serializer.toJson<String?>(street),
      'boundaryType': serializer.toJson<String?>(boundaryType),
      'boundary': serializer.toJson<String?>(boundary),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'localityBoundaryCode': serializer.toJson<String?>(localityBoundaryCode),
      'localityBoundaryName': serializer.toJson<String?>(localityBoundaryName),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'type':
          serializer.toJson<int?>($AddressTable.$convertertypen.toJson(type)),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  Addres copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> relatedClientReferenceId = const Value.absent(),
          Value<String?> doorNo = const Value.absent(),
          Value<double?> latitude = const Value.absent(),
          Value<double?> longitude = const Value.absent(),
          Value<double?> locationAccuracy = const Value.absent(),
          Value<String?> addressLine1 = const Value.absent(),
          Value<String?> addressLine2 = const Value.absent(),
          Value<String?> landmark = const Value.absent(),
          Value<String?> city = const Value.absent(),
          Value<String?> pincode = const Value.absent(),
          Value<String?> buildingName = const Value.absent(),
          Value<String?> street = const Value.absent(),
          Value<String?> boundaryType = const Value.absent(),
          Value<String?> boundary = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> localityBoundaryCode = const Value.absent(),
          Value<String?> localityBoundaryName = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<AddressType?> type = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      Addres(
        id: id.present ? id.value : this.id,
        relatedClientReferenceId: relatedClientReferenceId.present
            ? relatedClientReferenceId.value
            : this.relatedClientReferenceId,
        doorNo: doorNo.present ? doorNo.value : this.doorNo,
        latitude: latitude.present ? latitude.value : this.latitude,
        longitude: longitude.present ? longitude.value : this.longitude,
        locationAccuracy: locationAccuracy.present
            ? locationAccuracy.value
            : this.locationAccuracy,
        addressLine1:
            addressLine1.present ? addressLine1.value : this.addressLine1,
        addressLine2:
            addressLine2.present ? addressLine2.value : this.addressLine2,
        landmark: landmark.present ? landmark.value : this.landmark,
        city: city.present ? city.value : this.city,
        pincode: pincode.present ? pincode.value : this.pincode,
        buildingName:
            buildingName.present ? buildingName.value : this.buildingName,
        street: street.present ? street.value : this.street,
        boundaryType:
            boundaryType.present ? boundaryType.value : this.boundaryType,
        boundary: boundary.present ? boundary.value : this.boundary,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        localityBoundaryCode: localityBoundaryCode.present
            ? localityBoundaryCode.value
            : this.localityBoundaryCode,
        localityBoundaryName: localityBoundaryName.present
            ? localityBoundaryName.value
            : this.localityBoundaryName,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        type: type.present ? type.value : this.type,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('Addres(')
          ..write('id: $id, ')
          ..write('relatedClientReferenceId: $relatedClientReferenceId, ')
          ..write('doorNo: $doorNo, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('locationAccuracy: $locationAccuracy, ')
          ..write('addressLine1: $addressLine1, ')
          ..write('addressLine2: $addressLine2, ')
          ..write('landmark: $landmark, ')
          ..write('city: $city, ')
          ..write('pincode: $pincode, ')
          ..write('buildingName: $buildingName, ')
          ..write('street: $street, ')
          ..write('boundaryType: $boundaryType, ')
          ..write('boundary: $boundary, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('localityBoundaryCode: $localityBoundaryCode, ')
          ..write('localityBoundaryName: $localityBoundaryName, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('type: $type, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        relatedClientReferenceId,
        doorNo,
        latitude,
        longitude,
        locationAccuracy,
        addressLine1,
        addressLine2,
        landmark,
        city,
        pincode,
        buildingName,
        street,
        boundaryType,
        boundary,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        localityBoundaryCode,
        localityBoundaryName,
        tenantId,
        isDeleted,
        rowVersion,
        type,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Addres &&
          other.id == this.id &&
          other.relatedClientReferenceId == this.relatedClientReferenceId &&
          other.doorNo == this.doorNo &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.locationAccuracy == this.locationAccuracy &&
          other.addressLine1 == this.addressLine1 &&
          other.addressLine2 == this.addressLine2 &&
          other.landmark == this.landmark &&
          other.city == this.city &&
          other.pincode == this.pincode &&
          other.buildingName == this.buildingName &&
          other.street == this.street &&
          other.boundaryType == this.boundaryType &&
          other.boundary == this.boundary &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.localityBoundaryCode == this.localityBoundaryCode &&
          other.localityBoundaryName == this.localityBoundaryName &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.type == this.type &&
          other.additionalFields == this.additionalFields);
}

class AddressCompanion extends UpdateCompanion<Addres> {
  final Value<String?> id;
  final Value<String?> relatedClientReferenceId;
  final Value<String?> doorNo;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<double?> locationAccuracy;
  final Value<String?> addressLine1;
  final Value<String?> addressLine2;
  final Value<String?> landmark;
  final Value<String?> city;
  final Value<String?> pincode;
  final Value<String?> buildingName;
  final Value<String?> street;
  final Value<String?> boundaryType;
  final Value<String?> boundary;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> localityBoundaryCode;
  final Value<String?> localityBoundaryName;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<AddressType?> type;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const AddressCompanion({
    this.id = const Value.absent(),
    this.relatedClientReferenceId = const Value.absent(),
    this.doorNo = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.locationAccuracy = const Value.absent(),
    this.addressLine1 = const Value.absent(),
    this.addressLine2 = const Value.absent(),
    this.landmark = const Value.absent(),
    this.city = const Value.absent(),
    this.pincode = const Value.absent(),
    this.buildingName = const Value.absent(),
    this.street = const Value.absent(),
    this.boundaryType = const Value.absent(),
    this.boundary = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.localityBoundaryCode = const Value.absent(),
    this.localityBoundaryName = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.type = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AddressCompanion.insert({
    this.id = const Value.absent(),
    this.relatedClientReferenceId = const Value.absent(),
    this.doorNo = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.locationAccuracy = const Value.absent(),
    this.addressLine1 = const Value.absent(),
    this.addressLine2 = const Value.absent(),
    this.landmark = const Value.absent(),
    this.city = const Value.absent(),
    this.pincode = const Value.absent(),
    this.buildingName = const Value.absent(),
    this.street = const Value.absent(),
    this.boundaryType = const Value.absent(),
    this.boundary = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.localityBoundaryCode = const Value.absent(),
    this.localityBoundaryName = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.type = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<Addres> custom({
    Expression<String>? id,
    Expression<String>? relatedClientReferenceId,
    Expression<String>? doorNo,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<double>? locationAccuracy,
    Expression<String>? addressLine1,
    Expression<String>? addressLine2,
    Expression<String>? landmark,
    Expression<String>? city,
    Expression<String>? pincode,
    Expression<String>? buildingName,
    Expression<String>? street,
    Expression<String>? boundaryType,
    Expression<String>? boundary,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? localityBoundaryCode,
    Expression<String>? localityBoundaryName,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? type,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (relatedClientReferenceId != null)
        'related_client_reference_id': relatedClientReferenceId,
      if (doorNo != null) 'door_no': doorNo,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (locationAccuracy != null) 'location_accuracy': locationAccuracy,
      if (addressLine1 != null) 'address_line1': addressLine1,
      if (addressLine2 != null) 'address_line2': addressLine2,
      if (landmark != null) 'landmark': landmark,
      if (city != null) 'city': city,
      if (pincode != null) 'pincode': pincode,
      if (buildingName != null) 'building_name': buildingName,
      if (street != null) 'street': street,
      if (boundaryType != null) 'boundary_type': boundaryType,
      if (boundary != null) 'boundary': boundary,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (localityBoundaryCode != null)
        'locality_boundary_code': localityBoundaryCode,
      if (localityBoundaryName != null)
        'locality_boundary_name': localityBoundaryName,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (type != null) 'type': type,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AddressCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? relatedClientReferenceId,
      Value<String?>? doorNo,
      Value<double?>? latitude,
      Value<double?>? longitude,
      Value<double?>? locationAccuracy,
      Value<String?>? addressLine1,
      Value<String?>? addressLine2,
      Value<String?>? landmark,
      Value<String?>? city,
      Value<String?>? pincode,
      Value<String?>? buildingName,
      Value<String?>? street,
      Value<String?>? boundaryType,
      Value<String?>? boundary,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? localityBoundaryCode,
      Value<String?>? localityBoundaryName,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<AddressType?>? type,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return AddressCompanion(
      id: id ?? this.id,
      relatedClientReferenceId:
          relatedClientReferenceId ?? this.relatedClientReferenceId,
      doorNo: doorNo ?? this.doorNo,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      locationAccuracy: locationAccuracy ?? this.locationAccuracy,
      addressLine1: addressLine1 ?? this.addressLine1,
      addressLine2: addressLine2 ?? this.addressLine2,
      landmark: landmark ?? this.landmark,
      city: city ?? this.city,
      pincode: pincode ?? this.pincode,
      buildingName: buildingName ?? this.buildingName,
      street: street ?? this.street,
      boundaryType: boundaryType ?? this.boundaryType,
      boundary: boundary ?? this.boundary,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      localityBoundaryCode: localityBoundaryCode ?? this.localityBoundaryCode,
      localityBoundaryName: localityBoundaryName ?? this.localityBoundaryName,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      type: type ?? this.type,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (relatedClientReferenceId.present) {
      map['related_client_reference_id'] =
          Variable<String>(relatedClientReferenceId.value);
    }
    if (doorNo.present) {
      map['door_no'] = Variable<String>(doorNo.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (locationAccuracy.present) {
      map['location_accuracy'] = Variable<double>(locationAccuracy.value);
    }
    if (addressLine1.present) {
      map['address_line1'] = Variable<String>(addressLine1.value);
    }
    if (addressLine2.present) {
      map['address_line2'] = Variable<String>(addressLine2.value);
    }
    if (landmark.present) {
      map['landmark'] = Variable<String>(landmark.value);
    }
    if (city.present) {
      map['city'] = Variable<String>(city.value);
    }
    if (pincode.present) {
      map['pincode'] = Variable<String>(pincode.value);
    }
    if (buildingName.present) {
      map['building_name'] = Variable<String>(buildingName.value);
    }
    if (street.present) {
      map['street'] = Variable<String>(street.value);
    }
    if (boundaryType.present) {
      map['boundary_type'] = Variable<String>(boundaryType.value);
    }
    if (boundary.present) {
      map['boundary'] = Variable<String>(boundary.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (localityBoundaryCode.present) {
      map['locality_boundary_code'] =
          Variable<String>(localityBoundaryCode.value);
    }
    if (localityBoundaryName.present) {
      map['locality_boundary_name'] =
          Variable<String>(localityBoundaryName.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (type.present) {
      map['type'] =
          Variable<int>($AddressTable.$convertertypen.toSql(type.value));
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AddressCompanion(')
          ..write('id: $id, ')
          ..write('relatedClientReferenceId: $relatedClientReferenceId, ')
          ..write('doorNo: $doorNo, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('locationAccuracy: $locationAccuracy, ')
          ..write('addressLine1: $addressLine1, ')
          ..write('addressLine2: $addressLine2, ')
          ..write('landmark: $landmark, ')
          ..write('city: $city, ')
          ..write('pincode: $pincode, ')
          ..write('buildingName: $buildingName, ')
          ..write('street: $street, ')
          ..write('boundaryType: $boundaryType, ')
          ..write('boundary: $boundary, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('localityBoundaryCode: $localityBoundaryCode, ')
          ..write('localityBoundaryName: $localityBoundaryName, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('type: $type, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $NameTable extends Name with TableInfo<$NameTable, NameData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $NameTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _individualClientReferenceIdMeta =
      const VerificationMeta('individualClientReferenceId');
  @override
  late final GeneratedColumn<String> individualClientReferenceId =
      GeneratedColumn<String>(
          'individual_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _givenNameMeta =
      const VerificationMeta('givenName');
  @override
  late final GeneratedColumn<String> givenName = GeneratedColumn<String>(
      'given_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _familyNameMeta =
      const VerificationMeta('familyName');
  @override
  late final GeneratedColumn<String> familyName = GeneratedColumn<String>(
      'family_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _otherNamesMeta =
      const VerificationMeta('otherNames');
  @override
  late final GeneratedColumn<String> otherNames = GeneratedColumn<String>(
      'other_names', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        individualClientReferenceId,
        givenName,
        familyName,
        otherNames,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'name';
  @override
  VerificationContext validateIntegrity(Insertable<NameData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('individual_client_reference_id')) {
      context.handle(
          _individualClientReferenceIdMeta,
          individualClientReferenceId.isAcceptableOrUnknown(
              data['individual_client_reference_id']!,
              _individualClientReferenceIdMeta));
    }
    if (data.containsKey('given_name')) {
      context.handle(_givenNameMeta,
          givenName.isAcceptableOrUnknown(data['given_name']!, _givenNameMeta));
    }
    if (data.containsKey('family_name')) {
      context.handle(
          _familyNameMeta,
          familyName.isAcceptableOrUnknown(
              data['family_name']!, _familyNameMeta));
    }
    if (data.containsKey('other_names')) {
      context.handle(
          _otherNamesMeta,
          otherNames.isAcceptableOrUnknown(
              data['other_names']!, _otherNamesMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey =>
      {individualClientReferenceId, auditCreatedBy};
  @override
  NameData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return NameData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      individualClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}individual_client_reference_id']),
      givenName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}given_name']),
      familyName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}family_name']),
      otherNames: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}other_names']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $NameTable createAlias(String alias) {
    return $NameTable(attachedDatabase, alias);
  }
}

class NameData extends DataClass implements Insertable<NameData> {
  final String? id;
  final String? individualClientReferenceId;
  final String? givenName;
  final String? familyName;
  final String? otherNames;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const NameData(
      {this.id,
      this.individualClientReferenceId,
      this.givenName,
      this.familyName,
      this.otherNames,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || individualClientReferenceId != null) {
      map['individual_client_reference_id'] =
          Variable<String>(individualClientReferenceId);
    }
    if (!nullToAbsent || givenName != null) {
      map['given_name'] = Variable<String>(givenName);
    }
    if (!nullToAbsent || familyName != null) {
      map['family_name'] = Variable<String>(familyName);
    }
    if (!nullToAbsent || otherNames != null) {
      map['other_names'] = Variable<String>(otherNames);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  NameCompanion toCompanion(bool nullToAbsent) {
    return NameCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      individualClientReferenceId:
          individualClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(individualClientReferenceId),
      givenName: givenName == null && nullToAbsent
          ? const Value.absent()
          : Value(givenName),
      familyName: familyName == null && nullToAbsent
          ? const Value.absent()
          : Value(familyName),
      otherNames: otherNames == null && nullToAbsent
          ? const Value.absent()
          : Value(otherNames),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory NameData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return NameData(
      id: serializer.fromJson<String?>(json['id']),
      individualClientReferenceId:
          serializer.fromJson<String?>(json['individualClientReferenceId']),
      givenName: serializer.fromJson<String?>(json['givenName']),
      familyName: serializer.fromJson<String?>(json['familyName']),
      otherNames: serializer.fromJson<String?>(json['otherNames']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'individualClientReferenceId':
          serializer.toJson<String?>(individualClientReferenceId),
      'givenName': serializer.toJson<String?>(givenName),
      'familyName': serializer.toJson<String?>(familyName),
      'otherNames': serializer.toJson<String?>(otherNames),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  NameData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> individualClientReferenceId = const Value.absent(),
          Value<String?> givenName = const Value.absent(),
          Value<String?> familyName = const Value.absent(),
          Value<String?> otherNames = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      NameData(
        id: id.present ? id.value : this.id,
        individualClientReferenceId: individualClientReferenceId.present
            ? individualClientReferenceId.value
            : this.individualClientReferenceId,
        givenName: givenName.present ? givenName.value : this.givenName,
        familyName: familyName.present ? familyName.value : this.familyName,
        otherNames: otherNames.present ? otherNames.value : this.otherNames,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('NameData(')
          ..write('id: $id, ')
          ..write('individualClientReferenceId: $individualClientReferenceId, ')
          ..write('givenName: $givenName, ')
          ..write('familyName: $familyName, ')
          ..write('otherNames: $otherNames, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      individualClientReferenceId,
      givenName,
      familyName,
      otherNames,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is NameData &&
          other.id == this.id &&
          other.individualClientReferenceId ==
              this.individualClientReferenceId &&
          other.givenName == this.givenName &&
          other.familyName == this.familyName &&
          other.otherNames == this.otherNames &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class NameCompanion extends UpdateCompanion<NameData> {
  final Value<String?> id;
  final Value<String?> individualClientReferenceId;
  final Value<String?> givenName;
  final Value<String?> familyName;
  final Value<String?> otherNames;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const NameCompanion({
    this.id = const Value.absent(),
    this.individualClientReferenceId = const Value.absent(),
    this.givenName = const Value.absent(),
    this.familyName = const Value.absent(),
    this.otherNames = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  NameCompanion.insert({
    this.id = const Value.absent(),
    this.individualClientReferenceId = const Value.absent(),
    this.givenName = const Value.absent(),
    this.familyName = const Value.absent(),
    this.otherNames = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<NameData> custom({
    Expression<String>? id,
    Expression<String>? individualClientReferenceId,
    Expression<String>? givenName,
    Expression<String>? familyName,
    Expression<String>? otherNames,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (individualClientReferenceId != null)
        'individual_client_reference_id': individualClientReferenceId,
      if (givenName != null) 'given_name': givenName,
      if (familyName != null) 'family_name': familyName,
      if (otherNames != null) 'other_names': otherNames,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  NameCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? individualClientReferenceId,
      Value<String?>? givenName,
      Value<String?>? familyName,
      Value<String?>? otherNames,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return NameCompanion(
      id: id ?? this.id,
      individualClientReferenceId:
          individualClientReferenceId ?? this.individualClientReferenceId,
      givenName: givenName ?? this.givenName,
      familyName: familyName ?? this.familyName,
      otherNames: otherNames ?? this.otherNames,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (individualClientReferenceId.present) {
      map['individual_client_reference_id'] =
          Variable<String>(individualClientReferenceId.value);
    }
    if (givenName.present) {
      map['given_name'] = Variable<String>(givenName.value);
    }
    if (familyName.present) {
      map['family_name'] = Variable<String>(familyName.value);
    }
    if (otherNames.present) {
      map['other_names'] = Variable<String>(otherNames.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NameCompanion(')
          ..write('id: $id, ')
          ..write('individualClientReferenceId: $individualClientReferenceId, ')
          ..write('givenName: $givenName, ')
          ..write('familyName: $familyName, ')
          ..write('otherNames: $otherNames, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BoundaryTable extends Boundary
    with TableInfo<$BoundaryTable, BoundaryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BoundaryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _labelMeta = const VerificationMeta('label');
  @override
  late final GeneratedColumn<String> label = GeneratedColumn<String>(
      'label', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<String> latitude = GeneratedColumn<String>(
      'latitude', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<String> longitude = GeneratedColumn<String>(
      'longitude', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _materializedPathMeta =
      const VerificationMeta('materializedPath');
  @override
  late final GeneratedColumn<String> materializedPath = GeneratedColumn<String>(
      'materialized_path', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _boundaryNumMeta =
      const VerificationMeta('boundaryNum');
  @override
  late final GeneratedColumn<int> boundaryNum = GeneratedColumn<int>(
      'boundary_num', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        code,
        name,
        label,
        latitude,
        longitude,
        materializedPath,
        auditCreatedBy,
        boundaryNum,
        auditCreatedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'boundary';
  @override
  VerificationContext validateIntegrity(Insertable<BoundaryData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('label')) {
      context.handle(
          _labelMeta, label.isAcceptableOrUnknown(data['label']!, _labelMeta));
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    }
    if (data.containsKey('materialized_path')) {
      context.handle(
          _materializedPathMeta,
          materializedPath.isAcceptableOrUnknown(
              data['materialized_path']!, _materializedPathMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('boundary_num')) {
      context.handle(
          _boundaryNumMeta,
          boundaryNum.isAcceptableOrUnknown(
              data['boundary_num']!, _boundaryNumMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code};
  @override
  BoundaryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BoundaryData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      label: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}label']),
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}latitude']),
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}longitude']),
      materializedPath: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}materialized_path']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      boundaryNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}boundary_num']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
    );
  }

  @override
  $BoundaryTable createAlias(String alias) {
    return $BoundaryTable(attachedDatabase, alias);
  }
}

class BoundaryData extends DataClass implements Insertable<BoundaryData> {
  final String? code;
  final String? name;
  final String? label;
  final String? latitude;
  final String? longitude;
  final String? materializedPath;
  final String? auditCreatedBy;
  final int? boundaryNum;
  final int? auditCreatedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  const BoundaryData(
      {this.code,
      this.name,
      this.label,
      this.latitude,
      this.longitude,
      this.materializedPath,
      this.auditCreatedBy,
      this.boundaryNum,
      this.auditCreatedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || label != null) {
      map['label'] = Variable<String>(label);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<String>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<String>(longitude);
    }
    if (!nullToAbsent || materializedPath != null) {
      map['materialized_path'] = Variable<String>(materializedPath);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || boundaryNum != null) {
      map['boundary_num'] = Variable<int>(boundaryNum);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    return map;
  }

  BoundaryCompanion toCompanion(bool nullToAbsent) {
    return BoundaryCompanion(
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      label:
          label == null && nullToAbsent ? const Value.absent() : Value(label),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      materializedPath: materializedPath == null && nullToAbsent
          ? const Value.absent()
          : Value(materializedPath),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      boundaryNum: boundaryNum == null && nullToAbsent
          ? const Value.absent()
          : Value(boundaryNum),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
    );
  }

  factory BoundaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BoundaryData(
      code: serializer.fromJson<String?>(json['code']),
      name: serializer.fromJson<String?>(json['name']),
      label: serializer.fromJson<String?>(json['label']),
      latitude: serializer.fromJson<String?>(json['latitude']),
      longitude: serializer.fromJson<String?>(json['longitude']),
      materializedPath: serializer.fromJson<String?>(json['materializedPath']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      boundaryNum: serializer.fromJson<int?>(json['boundaryNum']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String?>(code),
      'name': serializer.toJson<String?>(name),
      'label': serializer.toJson<String?>(label),
      'latitude': serializer.toJson<String?>(latitude),
      'longitude': serializer.toJson<String?>(longitude),
      'materializedPath': serializer.toJson<String?>(materializedPath),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'boundaryNum': serializer.toJson<int?>(boundaryNum),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
    };
  }

  BoundaryData copyWith(
          {Value<String?> code = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<String?> label = const Value.absent(),
          Value<String?> latitude = const Value.absent(),
          Value<String?> longitude = const Value.absent(),
          Value<String?> materializedPath = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<int?> boundaryNum = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent()}) =>
      BoundaryData(
        code: code.present ? code.value : this.code,
        name: name.present ? name.value : this.name,
        label: label.present ? label.value : this.label,
        latitude: latitude.present ? latitude.value : this.latitude,
        longitude: longitude.present ? longitude.value : this.longitude,
        materializedPath: materializedPath.present
            ? materializedPath.value
            : this.materializedPath,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        boundaryNum: boundaryNum.present ? boundaryNum.value : this.boundaryNum,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
      );
  @override
  String toString() {
    return (StringBuffer('BoundaryData(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('label: $label, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('materializedPath: $materializedPath, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('boundaryNum: $boundaryNum, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      code,
      name,
      label,
      latitude,
      longitude,
      materializedPath,
      auditCreatedBy,
      boundaryNum,
      auditCreatedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BoundaryData &&
          other.code == this.code &&
          other.name == this.name &&
          other.label == this.label &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.materializedPath == this.materializedPath &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.boundaryNum == this.boundaryNum &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion);
}

class BoundaryCompanion extends UpdateCompanion<BoundaryData> {
  final Value<String?> code;
  final Value<String?> name;
  final Value<String?> label;
  final Value<String?> latitude;
  final Value<String?> longitude;
  final Value<String?> materializedPath;
  final Value<String?> auditCreatedBy;
  final Value<int?> boundaryNum;
  final Value<int?> auditCreatedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int> rowid;
  const BoundaryCompanion({
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.label = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.materializedPath = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.boundaryNum = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BoundaryCompanion.insert({
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.label = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.materializedPath = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.boundaryNum = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<BoundaryData> custom({
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? label,
    Expression<String>? latitude,
    Expression<String>? longitude,
    Expression<String>? materializedPath,
    Expression<String>? auditCreatedBy,
    Expression<int>? boundaryNum,
    Expression<int>? auditCreatedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (label != null) 'label': label,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (materializedPath != null) 'materialized_path': materializedPath,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (boundaryNum != null) 'boundary_num': boundaryNum,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BoundaryCompanion copyWith(
      {Value<String?>? code,
      Value<String?>? name,
      Value<String?>? label,
      Value<String?>? latitude,
      Value<String?>? longitude,
      Value<String?>? materializedPath,
      Value<String?>? auditCreatedBy,
      Value<int?>? boundaryNum,
      Value<int?>? auditCreatedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int>? rowid}) {
    return BoundaryCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      label: label ?? this.label,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      materializedPath: materializedPath ?? this.materializedPath,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      boundaryNum: boundaryNum ?? this.boundaryNum,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (label.present) {
      map['label'] = Variable<String>(label.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<String>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<String>(longitude.value);
    }
    if (materializedPath.present) {
      map['materialized_path'] = Variable<String>(materializedPath.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (boundaryNum.present) {
      map['boundary_num'] = Variable<int>(boundaryNum.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BoundaryCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('label: $label, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('materializedPath: $materializedPath, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('boundaryNum: $boundaryNum, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DocumentTable extends Document
    with TableInfo<$DocumentTable, DocumentData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DocumentTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _documentTypeMeta =
      const VerificationMeta('documentType');
  @override
  late final GeneratedColumn<String> documentType = GeneratedColumn<String>(
      'document_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fileStoreIdMeta =
      const VerificationMeta('fileStoreId');
  @override
  late final GeneratedColumn<String> fileStoreId = GeneratedColumn<String>(
      'file_store_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _documentUidMeta =
      const VerificationMeta('documentUid');
  @override
  late final GeneratedColumn<String> documentUid = GeneratedColumn<String>(
      'document_uid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        documentType,
        fileStoreId,
        documentUid,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'document';
  @override
  VerificationContext validateIntegrity(Insertable<DocumentData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('document_type')) {
      context.handle(
          _documentTypeMeta,
          documentType.isAcceptableOrUnknown(
              data['document_type']!, _documentTypeMeta));
    }
    if (data.containsKey('file_store_id')) {
      context.handle(
          _fileStoreIdMeta,
          fileStoreId.isAcceptableOrUnknown(
              data['file_store_id']!, _fileStoreIdMeta));
    }
    if (data.containsKey('document_uid')) {
      context.handle(
          _documentUidMeta,
          documentUid.isAcceptableOrUnknown(
              data['document_uid']!, _documentUidMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  DocumentData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DocumentData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      documentType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}document_type']),
      fileStoreId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}file_store_id']),
      documentUid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}document_uid']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $DocumentTable createAlias(String alias) {
    return $DocumentTable(attachedDatabase, alias);
  }
}

class DocumentData extends DataClass implements Insertable<DocumentData> {
  final String? id;
  final String? documentType;
  final String? fileStoreId;
  final String? documentUid;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const DocumentData(
      {this.id,
      this.documentType,
      this.fileStoreId,
      this.documentUid,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || documentType != null) {
      map['document_type'] = Variable<String>(documentType);
    }
    if (!nullToAbsent || fileStoreId != null) {
      map['file_store_id'] = Variable<String>(fileStoreId);
    }
    if (!nullToAbsent || documentUid != null) {
      map['document_uid'] = Variable<String>(documentUid);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  DocumentCompanion toCompanion(bool nullToAbsent) {
    return DocumentCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      documentType: documentType == null && nullToAbsent
          ? const Value.absent()
          : Value(documentType),
      fileStoreId: fileStoreId == null && nullToAbsent
          ? const Value.absent()
          : Value(fileStoreId),
      documentUid: documentUid == null && nullToAbsent
          ? const Value.absent()
          : Value(documentUid),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory DocumentData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DocumentData(
      id: serializer.fromJson<String?>(json['id']),
      documentType: serializer.fromJson<String?>(json['documentType']),
      fileStoreId: serializer.fromJson<String?>(json['fileStoreId']),
      documentUid: serializer.fromJson<String?>(json['documentUid']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'documentType': serializer.toJson<String?>(documentType),
      'fileStoreId': serializer.toJson<String?>(fileStoreId),
      'documentUid': serializer.toJson<String?>(documentUid),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  DocumentData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> documentType = const Value.absent(),
          Value<String?> fileStoreId = const Value.absent(),
          Value<String?> documentUid = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      DocumentData(
        id: id.present ? id.value : this.id,
        documentType:
            documentType.present ? documentType.value : this.documentType,
        fileStoreId: fileStoreId.present ? fileStoreId.value : this.fileStoreId,
        documentUid: documentUid.present ? documentUid.value : this.documentUid,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('DocumentData(')
          ..write('id: $id, ')
          ..write('documentType: $documentType, ')
          ..write('fileStoreId: $fileStoreId, ')
          ..write('documentUid: $documentUid, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      documentType,
      fileStoreId,
      documentUid,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DocumentData &&
          other.id == this.id &&
          other.documentType == this.documentType &&
          other.fileStoreId == this.fileStoreId &&
          other.documentUid == this.documentUid &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class DocumentCompanion extends UpdateCompanion<DocumentData> {
  final Value<String?> id;
  final Value<String?> documentType;
  final Value<String?> fileStoreId;
  final Value<String?> documentUid;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const DocumentCompanion({
    this.id = const Value.absent(),
    this.documentType = const Value.absent(),
    this.fileStoreId = const Value.absent(),
    this.documentUid = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DocumentCompanion.insert({
    this.id = const Value.absent(),
    this.documentType = const Value.absent(),
    this.fileStoreId = const Value.absent(),
    this.documentUid = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<DocumentData> custom({
    Expression<String>? id,
    Expression<String>? documentType,
    Expression<String>? fileStoreId,
    Expression<String>? documentUid,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (documentType != null) 'document_type': documentType,
      if (fileStoreId != null) 'file_store_id': fileStoreId,
      if (documentUid != null) 'document_uid': documentUid,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DocumentCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? documentType,
      Value<String?>? fileStoreId,
      Value<String?>? documentUid,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return DocumentCompanion(
      id: id ?? this.id,
      documentType: documentType ?? this.documentType,
      fileStoreId: fileStoreId ?? this.fileStoreId,
      documentUid: documentUid ?? this.documentUid,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (documentType.present) {
      map['document_type'] = Variable<String>(documentType.value);
    }
    if (fileStoreId.present) {
      map['file_store_id'] = Variable<String>(fileStoreId.value);
    }
    if (documentUid.present) {
      map['document_uid'] = Variable<String>(documentUid.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DocumentCompanion(')
          ..write('id: $id, ')
          ..write('documentType: $documentType, ')
          ..write('fileStoreId: $fileStoreId, ')
          ..write('documentUid: $documentUid, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FacilityTable extends Facility
    with TableInfo<$FacilityTable, FacilityData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FacilityTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isPermanentMeta =
      const VerificationMeta('isPermanent');
  @override
  late final GeneratedColumn<bool> isPermanent = GeneratedColumn<bool>(
      'is_permanent', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_permanent" IN (0, 1))'));
  static const VerificationMeta _usageMeta = const VerificationMeta('usage');
  @override
  late final GeneratedColumn<String> usage = GeneratedColumn<String>(
      'usage', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _storageCapacityMeta =
      const VerificationMeta('storageCapacity');
  @override
  late final GeneratedColumn<int> storageCapacity = GeneratedColumn<int>(
      'storage_capacity', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        isPermanent,
        usage,
        storageCapacity,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'facility';
  @override
  VerificationContext validateIntegrity(Insertable<FacilityData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('is_permanent')) {
      context.handle(
          _isPermanentMeta,
          isPermanent.isAcceptableOrUnknown(
              data['is_permanent']!, _isPermanentMeta));
    }
    if (data.containsKey('usage')) {
      context.handle(
          _usageMeta, usage.isAcceptableOrUnknown(data['usage']!, _usageMeta));
    }
    if (data.containsKey('storage_capacity')) {
      context.handle(
          _storageCapacityMeta,
          storageCapacity.isAcceptableOrUnknown(
              data['storage_capacity']!, _storageCapacityMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  FacilityData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FacilityData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      isPermanent: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_permanent']),
      usage: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}usage']),
      storageCapacity: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}storage_capacity']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $FacilityTable createAlias(String alias) {
    return $FacilityTable(attachedDatabase, alias);
  }
}

class FacilityData extends DataClass implements Insertable<FacilityData> {
  final String id;
  final bool? isPermanent;
  final String? usage;
  final int? storageCapacity;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const FacilityData(
      {required this.id,
      this.isPermanent,
      this.usage,
      this.storageCapacity,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || isPermanent != null) {
      map['is_permanent'] = Variable<bool>(isPermanent);
    }
    if (!nullToAbsent || usage != null) {
      map['usage'] = Variable<String>(usage);
    }
    if (!nullToAbsent || storageCapacity != null) {
      map['storage_capacity'] = Variable<int>(storageCapacity);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  FacilityCompanion toCompanion(bool nullToAbsent) {
    return FacilityCompanion(
      id: Value(id),
      isPermanent: isPermanent == null && nullToAbsent
          ? const Value.absent()
          : Value(isPermanent),
      usage:
          usage == null && nullToAbsent ? const Value.absent() : Value(usage),
      storageCapacity: storageCapacity == null && nullToAbsent
          ? const Value.absent()
          : Value(storageCapacity),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory FacilityData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FacilityData(
      id: serializer.fromJson<String>(json['id']),
      isPermanent: serializer.fromJson<bool?>(json['isPermanent']),
      usage: serializer.fromJson<String?>(json['usage']),
      storageCapacity: serializer.fromJson<int?>(json['storageCapacity']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'isPermanent': serializer.toJson<bool?>(isPermanent),
      'usage': serializer.toJson<String?>(usage),
      'storageCapacity': serializer.toJson<int?>(storageCapacity),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  FacilityData copyWith(
          {String? id,
          Value<bool?> isPermanent = const Value.absent(),
          Value<String?> usage = const Value.absent(),
          Value<int?> storageCapacity = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      FacilityData(
        id: id ?? this.id,
        isPermanent: isPermanent.present ? isPermanent.value : this.isPermanent,
        usage: usage.present ? usage.value : this.usage,
        storageCapacity: storageCapacity.present
            ? storageCapacity.value
            : this.storageCapacity,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('FacilityData(')
          ..write('id: $id, ')
          ..write('isPermanent: $isPermanent, ')
          ..write('usage: $usage, ')
          ..write('storageCapacity: $storageCapacity, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      isPermanent,
      usage,
      storageCapacity,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FacilityData &&
          other.id == this.id &&
          other.isPermanent == this.isPermanent &&
          other.usage == this.usage &&
          other.storageCapacity == this.storageCapacity &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class FacilityCompanion extends UpdateCompanion<FacilityData> {
  final Value<String> id;
  final Value<bool?> isPermanent;
  final Value<String?> usage;
  final Value<int?> storageCapacity;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const FacilityCompanion({
    this.id = const Value.absent(),
    this.isPermanent = const Value.absent(),
    this.usage = const Value.absent(),
    this.storageCapacity = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FacilityCompanion.insert({
    required String id,
    this.isPermanent = const Value.absent(),
    this.usage = const Value.absent(),
    this.storageCapacity = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<FacilityData> custom({
    Expression<String>? id,
    Expression<bool>? isPermanent,
    Expression<String>? usage,
    Expression<int>? storageCapacity,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (isPermanent != null) 'is_permanent': isPermanent,
      if (usage != null) 'usage': usage,
      if (storageCapacity != null) 'storage_capacity': storageCapacity,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FacilityCompanion copyWith(
      {Value<String>? id,
      Value<bool?>? isPermanent,
      Value<String?>? usage,
      Value<int?>? storageCapacity,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return FacilityCompanion(
      id: id ?? this.id,
      isPermanent: isPermanent ?? this.isPermanent,
      usage: usage ?? this.usage,
      storageCapacity: storageCapacity ?? this.storageCapacity,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (isPermanent.present) {
      map['is_permanent'] = Variable<bool>(isPermanent.value);
    }
    if (usage.present) {
      map['usage'] = Variable<String>(usage.value);
    }
    if (storageCapacity.present) {
      map['storage_capacity'] = Variable<int>(storageCapacity.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FacilityCompanion(')
          ..write('id: $id, ')
          ..write('isPermanent: $isPermanent, ')
          ..write('usage: $usage, ')
          ..write('storageCapacity: $storageCapacity, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProductTable extends Product with TableInfo<$ProductTable, ProductData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _manufacturerMeta =
      const VerificationMeta('manufacturer');
  @override
  late final GeneratedColumn<String> manufacturer = GeneratedColumn<String>(
      'manufacturer', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        type,
        name,
        manufacturer,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'product';
  @override
  VerificationContext validateIntegrity(Insertable<ProductData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('manufacturer')) {
      context.handle(
          _manufacturerMeta,
          manufacturer.isAcceptableOrUnknown(
              data['manufacturer']!, _manufacturerMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  ProductData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProductData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      manufacturer: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}manufacturer']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProductTable createAlias(String alias) {
    return $ProductTable(attachedDatabase, alias);
  }
}

class ProductData extends DataClass implements Insertable<ProductData> {
  final String? id;
  final String? type;
  final String? name;
  final String? manufacturer;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ProductData(
      {this.id,
      this.type,
      this.name,
      this.manufacturer,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || manufacturer != null) {
      map['manufacturer'] = Variable<String>(manufacturer);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProductCompanion toCompanion(bool nullToAbsent) {
    return ProductCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      manufacturer: manufacturer == null && nullToAbsent
          ? const Value.absent()
          : Value(manufacturer),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProductData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProductData(
      id: serializer.fromJson<String?>(json['id']),
      type: serializer.fromJson<String?>(json['type']),
      name: serializer.fromJson<String?>(json['name']),
      manufacturer: serializer.fromJson<String?>(json['manufacturer']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'type': serializer.toJson<String?>(type),
      'name': serializer.toJson<String?>(name),
      'manufacturer': serializer.toJson<String?>(manufacturer),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProductData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<String?> manufacturer = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProductData(
        id: id.present ? id.value : this.id,
        type: type.present ? type.value : this.type,
        name: name.present ? name.value : this.name,
        manufacturer:
            manufacturer.present ? manufacturer.value : this.manufacturer,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProductData(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('name: $name, ')
          ..write('manufacturer: $manufacturer, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      type,
      name,
      manufacturer,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProductData &&
          other.id == this.id &&
          other.type == this.type &&
          other.name == this.name &&
          other.manufacturer == this.manufacturer &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ProductCompanion extends UpdateCompanion<ProductData> {
  final Value<String?> id;
  final Value<String?> type;
  final Value<String?> name;
  final Value<String?> manufacturer;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProductCompanion({
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.name = const Value.absent(),
    this.manufacturer = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProductCompanion.insert({
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.name = const Value.absent(),
    this.manufacturer = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<ProductData> custom({
    Expression<String>? id,
    Expression<String>? type,
    Expression<String>? name,
    Expression<String>? manufacturer,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (type != null) 'type': type,
      if (name != null) 'name': name,
      if (manufacturer != null) 'manufacturer': manufacturer,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProductCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? type,
      Value<String?>? name,
      Value<String?>? manufacturer,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProductCompanion(
      id: id ?? this.id,
      type: type ?? this.type,
      name: name ?? this.name,
      manufacturer: manufacturer ?? this.manufacturer,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (manufacturer.present) {
      map['manufacturer'] = Variable<String>(manufacturer.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductCompanion(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('name: $name, ')
          ..write('manufacturer: $manufacturer, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProductVariantTable extends ProductVariant
    with TableInfo<$ProductVariantTable, ProductVariantData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductVariantTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _productIdMeta =
      const VerificationMeta('productId');
  @override
  late final GeneratedColumn<String> productId = GeneratedColumn<String>(
      'product_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _skuMeta = const VerificationMeta('sku');
  @override
  late final GeneratedColumn<String> sku = GeneratedColumn<String>(
      'sku', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _variationMeta =
      const VerificationMeta('variation');
  @override
  late final GeneratedColumn<String> variation = GeneratedColumn<String>(
      'variation', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        productId,
        sku,
        variation,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'product_variant';
  @override
  VerificationContext validateIntegrity(Insertable<ProductVariantData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(_productIdMeta,
          productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta));
    }
    if (data.containsKey('sku')) {
      context.handle(
          _skuMeta, sku.isAcceptableOrUnknown(data['sku']!, _skuMeta));
    }
    if (data.containsKey('variation')) {
      context.handle(_variationMeta,
          variation.isAcceptableOrUnknown(data['variation']!, _variationMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  ProductVariantData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProductVariantData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      productId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_id']),
      sku: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sku']),
      variation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}variation']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProductVariantTable createAlias(String alias) {
    return $ProductVariantTable(attachedDatabase, alias);
  }
}

class ProductVariantData extends DataClass
    implements Insertable<ProductVariantData> {
  final String id;
  final String? productId;
  final String? sku;
  final String? variation;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ProductVariantData(
      {required this.id,
      this.productId,
      this.sku,
      this.variation,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || productId != null) {
      map['product_id'] = Variable<String>(productId);
    }
    if (!nullToAbsent || sku != null) {
      map['sku'] = Variable<String>(sku);
    }
    if (!nullToAbsent || variation != null) {
      map['variation'] = Variable<String>(variation);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProductVariantCompanion toCompanion(bool nullToAbsent) {
    return ProductVariantCompanion(
      id: Value(id),
      productId: productId == null && nullToAbsent
          ? const Value.absent()
          : Value(productId),
      sku: sku == null && nullToAbsent ? const Value.absent() : Value(sku),
      variation: variation == null && nullToAbsent
          ? const Value.absent()
          : Value(variation),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProductVariantData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProductVariantData(
      id: serializer.fromJson<String>(json['id']),
      productId: serializer.fromJson<String?>(json['productId']),
      sku: serializer.fromJson<String?>(json['sku']),
      variation: serializer.fromJson<String?>(json['variation']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'productId': serializer.toJson<String?>(productId),
      'sku': serializer.toJson<String?>(sku),
      'variation': serializer.toJson<String?>(variation),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProductVariantData copyWith(
          {String? id,
          Value<String?> productId = const Value.absent(),
          Value<String?> sku = const Value.absent(),
          Value<String?> variation = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProductVariantData(
        id: id ?? this.id,
        productId: productId.present ? productId.value : this.productId,
        sku: sku.present ? sku.value : this.sku,
        variation: variation.present ? variation.value : this.variation,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProductVariantData(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('sku: $sku, ')
          ..write('variation: $variation, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      productId,
      sku,
      variation,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProductVariantData &&
          other.id == this.id &&
          other.productId == this.productId &&
          other.sku == this.sku &&
          other.variation == this.variation &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ProductVariantCompanion extends UpdateCompanion<ProductVariantData> {
  final Value<String> id;
  final Value<String?> productId;
  final Value<String?> sku;
  final Value<String?> variation;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProductVariantCompanion({
    this.id = const Value.absent(),
    this.productId = const Value.absent(),
    this.sku = const Value.absent(),
    this.variation = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProductVariantCompanion.insert({
    required String id,
    this.productId = const Value.absent(),
    this.sku = const Value.absent(),
    this.variation = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<ProductVariantData> custom({
    Expression<String>? id,
    Expression<String>? productId,
    Expression<String>? sku,
    Expression<String>? variation,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productId != null) 'product_id': productId,
      if (sku != null) 'sku': sku,
      if (variation != null) 'variation': variation,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProductVariantCompanion copyWith(
      {Value<String>? id,
      Value<String?>? productId,
      Value<String?>? sku,
      Value<String?>? variation,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProductVariantCompanion(
      id: id ?? this.id,
      productId: productId ?? this.productId,
      sku: sku ?? this.sku,
      variation: variation ?? this.variation,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<String>(productId.value);
    }
    if (sku.present) {
      map['sku'] = Variable<String>(sku.value);
    }
    if (variation.present) {
      map['variation'] = Variable<String>(variation.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductVariantCompanion(')
          ..write('id: $id, ')
          ..write('productId: $productId, ')
          ..write('sku: $sku, ')
          ..write('variation: $variation, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectTable extends Project with TableInfo<$ProjectTable, ProjectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _projectTypeIdMeta =
      const VerificationMeta('projectTypeId');
  @override
  late final GeneratedColumn<String> projectTypeId = GeneratedColumn<String>(
      'project_type_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectNumberMeta =
      const VerificationMeta('projectNumber');
  @override
  late final GeneratedColumn<String> projectNumber = GeneratedColumn<String>(
      'project_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _subProjectTypeIdMeta =
      const VerificationMeta('subProjectTypeId');
  @override
  late final GeneratedColumn<String> subProjectTypeId = GeneratedColumn<String>(
      'sub_project_type_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isTaskEnabledMeta =
      const VerificationMeta('isTaskEnabled');
  @override
  late final GeneratedColumn<bool> isTaskEnabled = GeneratedColumn<bool>(
      'is_task_enabled', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_task_enabled" IN (0, 1))'));
  static const VerificationMeta _parentMeta = const VerificationMeta('parent');
  @override
  late final GeneratedColumn<String> parent = GeneratedColumn<String>(
      'parent', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _departmentMeta =
      const VerificationMeta('department');
  @override
  late final GeneratedColumn<String> department = GeneratedColumn<String>(
      'department', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectHierarchyMeta =
      const VerificationMeta('projectHierarchy');
  @override
  late final GeneratedColumn<String> projectHierarchy = GeneratedColumn<String>(
      'project_hierarchy', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _startDateMeta =
      const VerificationMeta('startDate');
  @override
  late final GeneratedColumn<int> startDate = GeneratedColumn<int>(
      'start_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _endDateMeta =
      const VerificationMeta('endDate');
  @override
  late final GeneratedColumn<int> endDate = GeneratedColumn<int>(
      'end_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        projectTypeId,
        projectNumber,
        subProjectTypeId,
        isTaskEnabled,
        parent,
        name,
        department,
        description,
        referenceId,
        projectHierarchy,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        startDate,
        endDate,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project';
  @override
  VerificationContext validateIntegrity(Insertable<ProjectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('project_type_id')) {
      context.handle(
          _projectTypeIdMeta,
          projectTypeId.isAcceptableOrUnknown(
              data['project_type_id']!, _projectTypeIdMeta));
    }
    if (data.containsKey('project_number')) {
      context.handle(
          _projectNumberMeta,
          projectNumber.isAcceptableOrUnknown(
              data['project_number']!, _projectNumberMeta));
    }
    if (data.containsKey('sub_project_type_id')) {
      context.handle(
          _subProjectTypeIdMeta,
          subProjectTypeId.isAcceptableOrUnknown(
              data['sub_project_type_id']!, _subProjectTypeIdMeta));
    }
    if (data.containsKey('is_task_enabled')) {
      context.handle(
          _isTaskEnabledMeta,
          isTaskEnabled.isAcceptableOrUnknown(
              data['is_task_enabled']!, _isTaskEnabledMeta));
    }
    if (data.containsKey('parent')) {
      context.handle(_parentMeta,
          parent.isAcceptableOrUnknown(data['parent']!, _parentMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('department')) {
      context.handle(
          _departmentMeta,
          department.isAcceptableOrUnknown(
              data['department']!, _departmentMeta));
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    }
    if (data.containsKey('project_hierarchy')) {
      context.handle(
          _projectHierarchyMeta,
          projectHierarchy.isAcceptableOrUnknown(
              data['project_hierarchy']!, _projectHierarchyMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  ProjectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      projectTypeId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_type_id']),
      projectNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_number']),
      subProjectTypeId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}sub_project_type_id']),
      isTaskEnabled: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_task_enabled']),
      parent: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}parent']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      department: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}department']),
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id']),
      projectHierarchy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}project_hierarchy']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      startDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}start_date']),
      endDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}end_date']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectTable createAlias(String alias) {
    return $ProjectTable(attachedDatabase, alias);
  }
}

class ProjectData extends DataClass implements Insertable<ProjectData> {
  final String id;
  final String? projectTypeId;
  final String? projectNumber;
  final String? subProjectTypeId;
  final bool? isTaskEnabled;
  final String? parent;
  final String name;
  final String? department;
  final String? description;
  final String? referenceId;
  final String? projectHierarchy;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final int? startDate;
  final int? endDate;
  final String? additionalFields;
  const ProjectData(
      {required this.id,
      this.projectTypeId,
      this.projectNumber,
      this.subProjectTypeId,
      this.isTaskEnabled,
      this.parent,
      required this.name,
      this.department,
      this.description,
      this.referenceId,
      this.projectHierarchy,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.startDate,
      this.endDate,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || projectTypeId != null) {
      map['project_type_id'] = Variable<String>(projectTypeId);
    }
    if (!nullToAbsent || projectNumber != null) {
      map['project_number'] = Variable<String>(projectNumber);
    }
    if (!nullToAbsent || subProjectTypeId != null) {
      map['sub_project_type_id'] = Variable<String>(subProjectTypeId);
    }
    if (!nullToAbsent || isTaskEnabled != null) {
      map['is_task_enabled'] = Variable<bool>(isTaskEnabled);
    }
    if (!nullToAbsent || parent != null) {
      map['parent'] = Variable<String>(parent);
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || department != null) {
      map['department'] = Variable<String>(department);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    if (!nullToAbsent || projectHierarchy != null) {
      map['project_hierarchy'] = Variable<String>(projectHierarchy);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || startDate != null) {
      map['start_date'] = Variable<int>(startDate);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<int>(endDate);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectCompanion toCompanion(bool nullToAbsent) {
    return ProjectCompanion(
      id: Value(id),
      projectTypeId: projectTypeId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectTypeId),
      projectNumber: projectNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(projectNumber),
      subProjectTypeId: subProjectTypeId == null && nullToAbsent
          ? const Value.absent()
          : Value(subProjectTypeId),
      isTaskEnabled: isTaskEnabled == null && nullToAbsent
          ? const Value.absent()
          : Value(isTaskEnabled),
      parent:
          parent == null && nullToAbsent ? const Value.absent() : Value(parent),
      name: Value(name),
      department: department == null && nullToAbsent
          ? const Value.absent()
          : Value(department),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      projectHierarchy: projectHierarchy == null && nullToAbsent
          ? const Value.absent()
          : Value(projectHierarchy),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      startDate: startDate == null && nullToAbsent
          ? const Value.absent()
          : Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectData(
      id: serializer.fromJson<String>(json['id']),
      projectTypeId: serializer.fromJson<String?>(json['projectTypeId']),
      projectNumber: serializer.fromJson<String?>(json['projectNumber']),
      subProjectTypeId: serializer.fromJson<String?>(json['subProjectTypeId']),
      isTaskEnabled: serializer.fromJson<bool?>(json['isTaskEnabled']),
      parent: serializer.fromJson<String?>(json['parent']),
      name: serializer.fromJson<String>(json['name']),
      department: serializer.fromJson<String?>(json['department']),
      description: serializer.fromJson<String?>(json['description']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      projectHierarchy: serializer.fromJson<String?>(json['projectHierarchy']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      startDate: serializer.fromJson<int?>(json['startDate']),
      endDate: serializer.fromJson<int?>(json['endDate']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'projectTypeId': serializer.toJson<String?>(projectTypeId),
      'projectNumber': serializer.toJson<String?>(projectNumber),
      'subProjectTypeId': serializer.toJson<String?>(subProjectTypeId),
      'isTaskEnabled': serializer.toJson<bool?>(isTaskEnabled),
      'parent': serializer.toJson<String?>(parent),
      'name': serializer.toJson<String>(name),
      'department': serializer.toJson<String?>(department),
      'description': serializer.toJson<String?>(description),
      'referenceId': serializer.toJson<String?>(referenceId),
      'projectHierarchy': serializer.toJson<String?>(projectHierarchy),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'startDate': serializer.toJson<int?>(startDate),
      'endDate': serializer.toJson<int?>(endDate),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectData copyWith(
          {String? id,
          Value<String?> projectTypeId = const Value.absent(),
          Value<String?> projectNumber = const Value.absent(),
          Value<String?> subProjectTypeId = const Value.absent(),
          Value<bool?> isTaskEnabled = const Value.absent(),
          Value<String?> parent = const Value.absent(),
          String? name,
          Value<String?> department = const Value.absent(),
          Value<String?> description = const Value.absent(),
          Value<String?> referenceId = const Value.absent(),
          Value<String?> projectHierarchy = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<int?> startDate = const Value.absent(),
          Value<int?> endDate = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectData(
        id: id ?? this.id,
        projectTypeId:
            projectTypeId.present ? projectTypeId.value : this.projectTypeId,
        projectNumber:
            projectNumber.present ? projectNumber.value : this.projectNumber,
        subProjectTypeId: subProjectTypeId.present
            ? subProjectTypeId.value
            : this.subProjectTypeId,
        isTaskEnabled:
            isTaskEnabled.present ? isTaskEnabled.value : this.isTaskEnabled,
        parent: parent.present ? parent.value : this.parent,
        name: name ?? this.name,
        department: department.present ? department.value : this.department,
        description: description.present ? description.value : this.description,
        referenceId: referenceId.present ? referenceId.value : this.referenceId,
        projectHierarchy: projectHierarchy.present
            ? projectHierarchy.value
            : this.projectHierarchy,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        startDate: startDate.present ? startDate.value : this.startDate,
        endDate: endDate.present ? endDate.value : this.endDate,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectData(')
          ..write('id: $id, ')
          ..write('projectTypeId: $projectTypeId, ')
          ..write('projectNumber: $projectNumber, ')
          ..write('subProjectTypeId: $subProjectTypeId, ')
          ..write('isTaskEnabled: $isTaskEnabled, ')
          ..write('parent: $parent, ')
          ..write('name: $name, ')
          ..write('department: $department, ')
          ..write('description: $description, ')
          ..write('referenceId: $referenceId, ')
          ..write('projectHierarchy: $projectHierarchy, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        projectTypeId,
        projectNumber,
        subProjectTypeId,
        isTaskEnabled,
        parent,
        name,
        department,
        description,
        referenceId,
        projectHierarchy,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        startDate,
        endDate,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectData &&
          other.id == this.id &&
          other.projectTypeId == this.projectTypeId &&
          other.projectNumber == this.projectNumber &&
          other.subProjectTypeId == this.subProjectTypeId &&
          other.isTaskEnabled == this.isTaskEnabled &&
          other.parent == this.parent &&
          other.name == this.name &&
          other.department == this.department &&
          other.description == this.description &&
          other.referenceId == this.referenceId &&
          other.projectHierarchy == this.projectHierarchy &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.additionalFields == this.additionalFields);
}

class ProjectCompanion extends UpdateCompanion<ProjectData> {
  final Value<String> id;
  final Value<String?> projectTypeId;
  final Value<String?> projectNumber;
  final Value<String?> subProjectTypeId;
  final Value<bool?> isTaskEnabled;
  final Value<String?> parent;
  final Value<String> name;
  final Value<String?> department;
  final Value<String?> description;
  final Value<String?> referenceId;
  final Value<String?> projectHierarchy;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int?> startDate;
  final Value<int?> endDate;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectCompanion({
    this.id = const Value.absent(),
    this.projectTypeId = const Value.absent(),
    this.projectNumber = const Value.absent(),
    this.subProjectTypeId = const Value.absent(),
    this.isTaskEnabled = const Value.absent(),
    this.parent = const Value.absent(),
    this.name = const Value.absent(),
    this.department = const Value.absent(),
    this.description = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.projectHierarchy = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectCompanion.insert({
    required String id,
    this.projectTypeId = const Value.absent(),
    this.projectNumber = const Value.absent(),
    this.subProjectTypeId = const Value.absent(),
    this.isTaskEnabled = const Value.absent(),
    this.parent = const Value.absent(),
    required String name,
    this.department = const Value.absent(),
    this.description = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.projectHierarchy = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        name = Value(name);
  static Insertable<ProjectData> custom({
    Expression<String>? id,
    Expression<String>? projectTypeId,
    Expression<String>? projectNumber,
    Expression<String>? subProjectTypeId,
    Expression<bool>? isTaskEnabled,
    Expression<String>? parent,
    Expression<String>? name,
    Expression<String>? department,
    Expression<String>? description,
    Expression<String>? referenceId,
    Expression<String>? projectHierarchy,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? startDate,
    Expression<int>? endDate,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (projectTypeId != null) 'project_type_id': projectTypeId,
      if (projectNumber != null) 'project_number': projectNumber,
      if (subProjectTypeId != null) 'sub_project_type_id': subProjectTypeId,
      if (isTaskEnabled != null) 'is_task_enabled': isTaskEnabled,
      if (parent != null) 'parent': parent,
      if (name != null) 'name': name,
      if (department != null) 'department': department,
      if (description != null) 'description': description,
      if (referenceId != null) 'reference_id': referenceId,
      if (projectHierarchy != null) 'project_hierarchy': projectHierarchy,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectCompanion copyWith(
      {Value<String>? id,
      Value<String?>? projectTypeId,
      Value<String?>? projectNumber,
      Value<String?>? subProjectTypeId,
      Value<bool?>? isTaskEnabled,
      Value<String?>? parent,
      Value<String>? name,
      Value<String?>? department,
      Value<String?>? description,
      Value<String?>? referenceId,
      Value<String?>? projectHierarchy,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int?>? startDate,
      Value<int?>? endDate,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectCompanion(
      id: id ?? this.id,
      projectTypeId: projectTypeId ?? this.projectTypeId,
      projectNumber: projectNumber ?? this.projectNumber,
      subProjectTypeId: subProjectTypeId ?? this.subProjectTypeId,
      isTaskEnabled: isTaskEnabled ?? this.isTaskEnabled,
      parent: parent ?? this.parent,
      name: name ?? this.name,
      department: department ?? this.department,
      description: description ?? this.description,
      referenceId: referenceId ?? this.referenceId,
      projectHierarchy: projectHierarchy ?? this.projectHierarchy,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (projectTypeId.present) {
      map['project_type_id'] = Variable<String>(projectTypeId.value);
    }
    if (projectNumber.present) {
      map['project_number'] = Variable<String>(projectNumber.value);
    }
    if (subProjectTypeId.present) {
      map['sub_project_type_id'] = Variable<String>(subProjectTypeId.value);
    }
    if (isTaskEnabled.present) {
      map['is_task_enabled'] = Variable<bool>(isTaskEnabled.value);
    }
    if (parent.present) {
      map['parent'] = Variable<String>(parent.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (department.present) {
      map['department'] = Variable<String>(department.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (projectHierarchy.present) {
      map['project_hierarchy'] = Variable<String>(projectHierarchy.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<int>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<int>(endDate.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectCompanion(')
          ..write('id: $id, ')
          ..write('projectTypeId: $projectTypeId, ')
          ..write('projectNumber: $projectNumber, ')
          ..write('subProjectTypeId: $subProjectTypeId, ')
          ..write('isTaskEnabled: $isTaskEnabled, ')
          ..write('parent: $parent, ')
          ..write('name: $name, ')
          ..write('department: $department, ')
          ..write('description: $description, ')
          ..write('referenceId: $referenceId, ')
          ..write('projectHierarchy: $projectHierarchy, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectBeneficiaryTable extends ProjectBeneficiary
    with TableInfo<$ProjectBeneficiaryTable, ProjectBeneficiaryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectBeneficiaryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _beneficiaryIdMeta =
      const VerificationMeta('beneficiaryId');
  @override
  late final GeneratedColumn<String> beneficiaryId = GeneratedColumn<String>(
      'beneficiary_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tagMeta = const VerificationMeta('tag');
  @override
  late final GeneratedColumn<String> tag = GeneratedColumn<String>(
      'tag', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _beneficiaryClientReferenceIdMeta =
      const VerificationMeta('beneficiaryClientReferenceId');
  @override
  late final GeneratedColumn<String> beneficiaryClientReferenceId =
      GeneratedColumn<String>(
          'beneficiary_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _dateOfRegistrationMeta =
      const VerificationMeta('dateOfRegistration');
  @override
  late final GeneratedColumn<int> dateOfRegistration = GeneratedColumn<int>(
      'date_of_registration', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        projectId,
        beneficiaryId,
        tag,
        beneficiaryClientReferenceId,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        dateOfRegistration,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project_beneficiary';
  @override
  VerificationContext validateIntegrity(
      Insertable<ProjectBeneficiaryData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('beneficiary_id')) {
      context.handle(
          _beneficiaryIdMeta,
          beneficiaryId.isAcceptableOrUnknown(
              data['beneficiary_id']!, _beneficiaryIdMeta));
    }
    if (data.containsKey('tag')) {
      context.handle(
          _tagMeta, tag.isAcceptableOrUnknown(data['tag']!, _tagMeta));
    }
    if (data.containsKey('beneficiary_client_reference_id')) {
      context.handle(
          _beneficiaryClientReferenceIdMeta,
          beneficiaryClientReferenceId.isAcceptableOrUnknown(
              data['beneficiary_client_reference_id']!,
              _beneficiaryClientReferenceIdMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('date_of_registration')) {
      context.handle(
          _dateOfRegistrationMeta,
          dateOfRegistration.isAcceptableOrUnknown(
              data['date_of_registration']!, _dateOfRegistrationMeta));
    } else if (isInserting) {
      context.missing(_dateOfRegistrationMeta);
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  ProjectBeneficiaryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectBeneficiaryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      beneficiaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}beneficiary_id']),
      tag: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tag']),
      beneficiaryClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}beneficiary_client_reference_id']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      dateOfRegistration: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}date_of_registration'])!,
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectBeneficiaryTable createAlias(String alias) {
    return $ProjectBeneficiaryTable(attachedDatabase, alias);
  }
}

class ProjectBeneficiaryData extends DataClass
    implements Insertable<ProjectBeneficiaryData> {
  final String? id;
  final String? projectId;
  final String? beneficiaryId;
  final String? tag;
  final String? beneficiaryClientReferenceId;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final int dateOfRegistration;
  final String? additionalFields;
  const ProjectBeneficiaryData(
      {this.id,
      this.projectId,
      this.beneficiaryId,
      this.tag,
      this.beneficiaryClientReferenceId,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      required this.dateOfRegistration,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || beneficiaryId != null) {
      map['beneficiary_id'] = Variable<String>(beneficiaryId);
    }
    if (!nullToAbsent || tag != null) {
      map['tag'] = Variable<String>(tag);
    }
    if (!nullToAbsent || beneficiaryClientReferenceId != null) {
      map['beneficiary_client_reference_id'] =
          Variable<String>(beneficiaryClientReferenceId);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    map['date_of_registration'] = Variable<int>(dateOfRegistration);
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectBeneficiaryCompanion toCompanion(bool nullToAbsent) {
    return ProjectBeneficiaryCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      beneficiaryId: beneficiaryId == null && nullToAbsent
          ? const Value.absent()
          : Value(beneficiaryId),
      tag: tag == null && nullToAbsent ? const Value.absent() : Value(tag),
      beneficiaryClientReferenceId:
          beneficiaryClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(beneficiaryClientReferenceId),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      dateOfRegistration: Value(dateOfRegistration),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectBeneficiaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectBeneficiaryData(
      id: serializer.fromJson<String?>(json['id']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      beneficiaryId: serializer.fromJson<String?>(json['beneficiaryId']),
      tag: serializer.fromJson<String?>(json['tag']),
      beneficiaryClientReferenceId:
          serializer.fromJson<String?>(json['beneficiaryClientReferenceId']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      dateOfRegistration: serializer.fromJson<int>(json['dateOfRegistration']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'projectId': serializer.toJson<String?>(projectId),
      'beneficiaryId': serializer.toJson<String?>(beneficiaryId),
      'tag': serializer.toJson<String?>(tag),
      'beneficiaryClientReferenceId':
          serializer.toJson<String?>(beneficiaryClientReferenceId),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'dateOfRegistration': serializer.toJson<int>(dateOfRegistration),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectBeneficiaryData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> beneficiaryId = const Value.absent(),
          Value<String?> tag = const Value.absent(),
          Value<String?> beneficiaryClientReferenceId = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          int? dateOfRegistration,
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectBeneficiaryData(
        id: id.present ? id.value : this.id,
        projectId: projectId.present ? projectId.value : this.projectId,
        beneficiaryId:
            beneficiaryId.present ? beneficiaryId.value : this.beneficiaryId,
        tag: tag.present ? tag.value : this.tag,
        beneficiaryClientReferenceId: beneficiaryClientReferenceId.present
            ? beneficiaryClientReferenceId.value
            : this.beneficiaryClientReferenceId,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        dateOfRegistration: dateOfRegistration ?? this.dateOfRegistration,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectBeneficiaryData(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('beneficiaryId: $beneficiaryId, ')
          ..write('tag: $tag, ')
          ..write(
              'beneficiaryClientReferenceId: $beneficiaryClientReferenceId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('dateOfRegistration: $dateOfRegistration, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      projectId,
      beneficiaryId,
      tag,
      beneficiaryClientReferenceId,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      dateOfRegistration,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectBeneficiaryData &&
          other.id == this.id &&
          other.projectId == this.projectId &&
          other.beneficiaryId == this.beneficiaryId &&
          other.tag == this.tag &&
          other.beneficiaryClientReferenceId ==
              this.beneficiaryClientReferenceId &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.dateOfRegistration == this.dateOfRegistration &&
          other.additionalFields == this.additionalFields);
}

class ProjectBeneficiaryCompanion
    extends UpdateCompanion<ProjectBeneficiaryData> {
  final Value<String?> id;
  final Value<String?> projectId;
  final Value<String?> beneficiaryId;
  final Value<String?> tag;
  final Value<String?> beneficiaryClientReferenceId;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int> dateOfRegistration;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectBeneficiaryCompanion({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.beneficiaryId = const Value.absent(),
    this.tag = const Value.absent(),
    this.beneficiaryClientReferenceId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.dateOfRegistration = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectBeneficiaryCompanion.insert({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.beneficiaryId = const Value.absent(),
    this.tag = const Value.absent(),
    this.beneficiaryClientReferenceId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    required int dateOfRegistration,
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : clientReferenceId = Value(clientReferenceId),
        dateOfRegistration = Value(dateOfRegistration);
  static Insertable<ProjectBeneficiaryData> custom({
    Expression<String>? id,
    Expression<String>? projectId,
    Expression<String>? beneficiaryId,
    Expression<String>? tag,
    Expression<String>? beneficiaryClientReferenceId,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? dateOfRegistration,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (projectId != null) 'project_id': projectId,
      if (beneficiaryId != null) 'beneficiary_id': beneficiaryId,
      if (tag != null) 'tag': tag,
      if (beneficiaryClientReferenceId != null)
        'beneficiary_client_reference_id': beneficiaryClientReferenceId,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (dateOfRegistration != null)
        'date_of_registration': dateOfRegistration,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectBeneficiaryCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? projectId,
      Value<String?>? beneficiaryId,
      Value<String?>? tag,
      Value<String?>? beneficiaryClientReferenceId,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int>? dateOfRegistration,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectBeneficiaryCompanion(
      id: id ?? this.id,
      projectId: projectId ?? this.projectId,
      beneficiaryId: beneficiaryId ?? this.beneficiaryId,
      tag: tag ?? this.tag,
      beneficiaryClientReferenceId:
          beneficiaryClientReferenceId ?? this.beneficiaryClientReferenceId,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      dateOfRegistration: dateOfRegistration ?? this.dateOfRegistration,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (beneficiaryId.present) {
      map['beneficiary_id'] = Variable<String>(beneficiaryId.value);
    }
    if (tag.present) {
      map['tag'] = Variable<String>(tag.value);
    }
    if (beneficiaryClientReferenceId.present) {
      map['beneficiary_client_reference_id'] =
          Variable<String>(beneficiaryClientReferenceId.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (dateOfRegistration.present) {
      map['date_of_registration'] = Variable<int>(dateOfRegistration.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectBeneficiaryCompanion(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('beneficiaryId: $beneficiaryId, ')
          ..write('tag: $tag, ')
          ..write(
              'beneficiaryClientReferenceId: $beneficiaryClientReferenceId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('dateOfRegistration: $dateOfRegistration, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectFacilityTable extends ProjectFacility
    with TableInfo<$ProjectFacilityTable, ProjectFacilityData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectFacilityTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _facilityIdMeta =
      const VerificationMeta('facilityId');
  @override
  late final GeneratedColumn<String> facilityId = GeneratedColumn<String>(
      'facility_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        facilityId,
        projectId,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project_facility';
  @override
  VerificationContext validateIntegrity(
      Insertable<ProjectFacilityData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('facility_id')) {
      context.handle(
          _facilityIdMeta,
          facilityId.isAcceptableOrUnknown(
              data['facility_id']!, _facilityIdMeta));
    } else if (isInserting) {
      context.missing(_facilityIdMeta);
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    } else if (isInserting) {
      context.missing(_projectIdMeta);
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  ProjectFacilityData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectFacilityData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      facilityId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}facility_id'])!,
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id'])!,
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectFacilityTable createAlias(String alias) {
    return $ProjectFacilityTable(attachedDatabase, alias);
  }
}

class ProjectFacilityData extends DataClass
    implements Insertable<ProjectFacilityData> {
  final String id;
  final String facilityId;
  final String projectId;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ProjectFacilityData(
      {required this.id,
      required this.facilityId,
      required this.projectId,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['facility_id'] = Variable<String>(facilityId);
    map['project_id'] = Variable<String>(projectId);
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectFacilityCompanion toCompanion(bool nullToAbsent) {
    return ProjectFacilityCompanion(
      id: Value(id),
      facilityId: Value(facilityId),
      projectId: Value(projectId),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectFacilityData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectFacilityData(
      id: serializer.fromJson<String>(json['id']),
      facilityId: serializer.fromJson<String>(json['facilityId']),
      projectId: serializer.fromJson<String>(json['projectId']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'facilityId': serializer.toJson<String>(facilityId),
      'projectId': serializer.toJson<String>(projectId),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectFacilityData copyWith(
          {String? id,
          String? facilityId,
          String? projectId,
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectFacilityData(
        id: id ?? this.id,
        facilityId: facilityId ?? this.facilityId,
        projectId: projectId ?? this.projectId,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectFacilityData(')
          ..write('id: $id, ')
          ..write('facilityId: $facilityId, ')
          ..write('projectId: $projectId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      facilityId,
      projectId,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectFacilityData &&
          other.id == this.id &&
          other.facilityId == this.facilityId &&
          other.projectId == this.projectId &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ProjectFacilityCompanion extends UpdateCompanion<ProjectFacilityData> {
  final Value<String> id;
  final Value<String> facilityId;
  final Value<String> projectId;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectFacilityCompanion({
    this.id = const Value.absent(),
    this.facilityId = const Value.absent(),
    this.projectId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectFacilityCompanion.insert({
    required String id,
    required String facilityId,
    required String projectId,
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        facilityId = Value(facilityId),
        projectId = Value(projectId);
  static Insertable<ProjectFacilityData> custom({
    Expression<String>? id,
    Expression<String>? facilityId,
    Expression<String>? projectId,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (facilityId != null) 'facility_id': facilityId,
      if (projectId != null) 'project_id': projectId,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectFacilityCompanion copyWith(
      {Value<String>? id,
      Value<String>? facilityId,
      Value<String>? projectId,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectFacilityCompanion(
      id: id ?? this.id,
      facilityId: facilityId ?? this.facilityId,
      projectId: projectId ?? this.projectId,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (facilityId.present) {
      map['facility_id'] = Variable<String>(facilityId.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectFacilityCompanion(')
          ..write('id: $id, ')
          ..write('facilityId: $facilityId, ')
          ..write('projectId: $projectId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectProductVariantTable extends ProjectProductVariant
    with TableInfo<$ProjectProductVariantTable, ProjectProductVariantData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectProductVariantTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _productVariantIdMeta =
      const VerificationMeta('productVariantId');
  @override
  late final GeneratedColumn<String> productVariantId = GeneratedColumn<String>(
      'product_variant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isBaseUnitVariantMeta =
      const VerificationMeta('isBaseUnitVariant');
  @override
  late final GeneratedColumn<bool> isBaseUnitVariant = GeneratedColumn<bool>(
      'is_base_unit_variant', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_base_unit_variant" IN (0, 1))'));
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        productVariantId,
        type,
        isBaseUnitVariant,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project_product_variant';
  @override
  VerificationContext validateIntegrity(
      Insertable<ProjectProductVariantData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('product_variant_id')) {
      context.handle(
          _productVariantIdMeta,
          productVariantId.isAcceptableOrUnknown(
              data['product_variant_id']!, _productVariantIdMeta));
    } else if (isInserting) {
      context.missing(_productVariantIdMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('is_base_unit_variant')) {
      context.handle(
          _isBaseUnitVariantMeta,
          isBaseUnitVariant.isAcceptableOrUnknown(
              data['is_base_unit_variant']!, _isBaseUnitVariantMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {productVariantId, auditCreatedBy};
  @override
  ProjectProductVariantData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectProductVariantData(
      productVariantId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}product_variant_id'])!,
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      isBaseUnitVariant: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}is_base_unit_variant']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectProductVariantTable createAlias(String alias) {
    return $ProjectProductVariantTable(attachedDatabase, alias);
  }
}

class ProjectProductVariantData extends DataClass
    implements Insertable<ProjectProductVariantData> {
  final String productVariantId;
  final String? type;
  final bool? isBaseUnitVariant;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ProjectProductVariantData(
      {required this.productVariantId,
      this.type,
      this.isBaseUnitVariant,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['product_variant_id'] = Variable<String>(productVariantId);
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || isBaseUnitVariant != null) {
      map['is_base_unit_variant'] = Variable<bool>(isBaseUnitVariant);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectProductVariantCompanion toCompanion(bool nullToAbsent) {
    return ProjectProductVariantCompanion(
      productVariantId: Value(productVariantId),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      isBaseUnitVariant: isBaseUnitVariant == null && nullToAbsent
          ? const Value.absent()
          : Value(isBaseUnitVariant),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectProductVariantData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectProductVariantData(
      productVariantId: serializer.fromJson<String>(json['productVariantId']),
      type: serializer.fromJson<String?>(json['type']),
      isBaseUnitVariant: serializer.fromJson<bool?>(json['isBaseUnitVariant']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'productVariantId': serializer.toJson<String>(productVariantId),
      'type': serializer.toJson<String?>(type),
      'isBaseUnitVariant': serializer.toJson<bool?>(isBaseUnitVariant),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectProductVariantData copyWith(
          {String? productVariantId,
          Value<String?> type = const Value.absent(),
          Value<bool?> isBaseUnitVariant = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectProductVariantData(
        productVariantId: productVariantId ?? this.productVariantId,
        type: type.present ? type.value : this.type,
        isBaseUnitVariant: isBaseUnitVariant.present
            ? isBaseUnitVariant.value
            : this.isBaseUnitVariant,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectProductVariantData(')
          ..write('productVariantId: $productVariantId, ')
          ..write('type: $type, ')
          ..write('isBaseUnitVariant: $isBaseUnitVariant, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      productVariantId,
      type,
      isBaseUnitVariant,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectProductVariantData &&
          other.productVariantId == this.productVariantId &&
          other.type == this.type &&
          other.isBaseUnitVariant == this.isBaseUnitVariant &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ProjectProductVariantCompanion
    extends UpdateCompanion<ProjectProductVariantData> {
  final Value<String> productVariantId;
  final Value<String?> type;
  final Value<bool?> isBaseUnitVariant;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectProductVariantCompanion({
    this.productVariantId = const Value.absent(),
    this.type = const Value.absent(),
    this.isBaseUnitVariant = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectProductVariantCompanion.insert({
    required String productVariantId,
    this.type = const Value.absent(),
    this.isBaseUnitVariant = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : productVariantId = Value(productVariantId);
  static Insertable<ProjectProductVariantData> custom({
    Expression<String>? productVariantId,
    Expression<String>? type,
    Expression<bool>? isBaseUnitVariant,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (productVariantId != null) 'product_variant_id': productVariantId,
      if (type != null) 'type': type,
      if (isBaseUnitVariant != null) 'is_base_unit_variant': isBaseUnitVariant,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectProductVariantCompanion copyWith(
      {Value<String>? productVariantId,
      Value<String?>? type,
      Value<bool?>? isBaseUnitVariant,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectProductVariantCompanion(
      productVariantId: productVariantId ?? this.productVariantId,
      type: type ?? this.type,
      isBaseUnitVariant: isBaseUnitVariant ?? this.isBaseUnitVariant,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (productVariantId.present) {
      map['product_variant_id'] = Variable<String>(productVariantId.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (isBaseUnitVariant.present) {
      map['is_base_unit_variant'] = Variable<bool>(isBaseUnitVariant.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectProductVariantCompanion(')
          ..write('productVariantId: $productVariantId, ')
          ..write('type: $type, ')
          ..write('isBaseUnitVariant: $isBaseUnitVariant, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectResourceTable extends ProjectResource
    with TableInfo<$ProjectResourceTable, ProjectResourceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectResourceTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _resourceMeta =
      const VerificationMeta('resource');
  @override
  late final GeneratedColumn<String> resource = GeneratedColumn<String>(
      'resource', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES project_product_variant (product_variant_id)'));
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        projectId,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        resource,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project_resource';
  @override
  VerificationContext validateIntegrity(
      Insertable<ProjectResourceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('resource')) {
      context.handle(_resourceMeta,
          resource.isAcceptableOrUnknown(data['resource']!, _resourceMeta));
    } else if (isInserting) {
      context.missing(_resourceMeta);
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  ProjectResourceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectResourceData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      resource: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}resource'])!,
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectResourceTable createAlias(String alias) {
    return $ProjectResourceTable(attachedDatabase, alias);
  }
}

class ProjectResourceData extends DataClass
    implements Insertable<ProjectResourceData> {
  final String? id;
  final String? projectId;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String resource;
  final String? additionalFields;
  const ProjectResourceData(
      {this.id,
      this.projectId,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      required this.resource,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    map['resource'] = Variable<String>(resource);
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectResourceCompanion toCompanion(bool nullToAbsent) {
    return ProjectResourceCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      resource: Value(resource),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectResourceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectResourceData(
      id: serializer.fromJson<String?>(json['id']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      resource: serializer.fromJson<String>(json['resource']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'projectId': serializer.toJson<String?>(projectId),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'resource': serializer.toJson<String>(resource),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectResourceData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          String? resource,
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectResourceData(
        id: id.present ? id.value : this.id,
        projectId: projectId.present ? projectId.value : this.projectId,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        resource: resource ?? this.resource,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectResourceData(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('resource: $resource, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      projectId,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      resource,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectResourceData &&
          other.id == this.id &&
          other.projectId == this.projectId &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.resource == this.resource &&
          other.additionalFields == this.additionalFields);
}

class ProjectResourceCompanion extends UpdateCompanion<ProjectResourceData> {
  final Value<String?> id;
  final Value<String?> projectId;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String> resource;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectResourceCompanion({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.resource = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectResourceCompanion.insert({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    required String resource,
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : resource = Value(resource);
  static Insertable<ProjectResourceData> custom({
    Expression<String>? id,
    Expression<String>? projectId,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? resource,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (projectId != null) 'project_id': projectId,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (resource != null) 'resource': resource,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectResourceCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? projectId,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String>? resource,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectResourceCompanion(
      id: id ?? this.id,
      projectId: projectId ?? this.projectId,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      resource: resource ?? this.resource,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (resource.present) {
      map['resource'] = Variable<String>(resource.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectResourceCompanion(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('resource: $resource, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectStaffTable extends ProjectStaff
    with TableInfo<$ProjectStaffTable, ProjectStaffData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectStaffTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _staffIdMeta =
      const VerificationMeta('staffId');
  @override
  late final GeneratedColumn<String> staffId = GeneratedColumn<String>(
      'staff_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
      'user_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _channelMeta =
      const VerificationMeta('channel');
  @override
  late final GeneratedColumn<String> channel = GeneratedColumn<String>(
      'channel', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _startDateMeta =
      const VerificationMeta('startDate');
  @override
  late final GeneratedColumn<int> startDate = GeneratedColumn<int>(
      'start_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _endDateMeta =
      const VerificationMeta('endDate');
  @override
  late final GeneratedColumn<int> endDate = GeneratedColumn<int>(
      'end_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        staffId,
        userId,
        projectId,
        channel,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        startDate,
        endDate,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project_staff';
  @override
  VerificationContext validateIntegrity(Insertable<ProjectStaffData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('staff_id')) {
      context.handle(_staffIdMeta,
          staffId.isAcceptableOrUnknown(data['staff_id']!, _staffIdMeta));
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('channel')) {
      context.handle(_channelMeta,
          channel.isAcceptableOrUnknown(data['channel']!, _channelMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  ProjectStaffData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectStaffData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      staffId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}staff_id']),
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_id']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      channel: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}channel']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      startDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}start_date']),
      endDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}end_date']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectStaffTable createAlias(String alias) {
    return $ProjectStaffTable(attachedDatabase, alias);
  }
}

class ProjectStaffData extends DataClass
    implements Insertable<ProjectStaffData> {
  final String id;
  final String? staffId;
  final String? userId;
  final String? projectId;
  final String? channel;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final int? startDate;
  final int? endDate;
  final String? additionalFields;
  const ProjectStaffData(
      {required this.id,
      this.staffId,
      this.userId,
      this.projectId,
      this.channel,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.startDate,
      this.endDate,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || staffId != null) {
      map['staff_id'] = Variable<String>(staffId);
    }
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<String>(userId);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || channel != null) {
      map['channel'] = Variable<String>(channel);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || startDate != null) {
      map['start_date'] = Variable<int>(startDate);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<int>(endDate);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectStaffCompanion toCompanion(bool nullToAbsent) {
    return ProjectStaffCompanion(
      id: Value(id),
      staffId: staffId == null && nullToAbsent
          ? const Value.absent()
          : Value(staffId),
      userId:
          userId == null && nullToAbsent ? const Value.absent() : Value(userId),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      channel: channel == null && nullToAbsent
          ? const Value.absent()
          : Value(channel),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      startDate: startDate == null && nullToAbsent
          ? const Value.absent()
          : Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectStaffData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectStaffData(
      id: serializer.fromJson<String>(json['id']),
      staffId: serializer.fromJson<String?>(json['staffId']),
      userId: serializer.fromJson<String?>(json['userId']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      channel: serializer.fromJson<String?>(json['channel']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      startDate: serializer.fromJson<int?>(json['startDate']),
      endDate: serializer.fromJson<int?>(json['endDate']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'staffId': serializer.toJson<String?>(staffId),
      'userId': serializer.toJson<String?>(userId),
      'projectId': serializer.toJson<String?>(projectId),
      'channel': serializer.toJson<String?>(channel),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'startDate': serializer.toJson<int?>(startDate),
      'endDate': serializer.toJson<int?>(endDate),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectStaffData copyWith(
          {String? id,
          Value<String?> staffId = const Value.absent(),
          Value<String?> userId = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> channel = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<int?> startDate = const Value.absent(),
          Value<int?> endDate = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectStaffData(
        id: id ?? this.id,
        staffId: staffId.present ? staffId.value : this.staffId,
        userId: userId.present ? userId.value : this.userId,
        projectId: projectId.present ? projectId.value : this.projectId,
        channel: channel.present ? channel.value : this.channel,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        startDate: startDate.present ? startDate.value : this.startDate,
        endDate: endDate.present ? endDate.value : this.endDate,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectStaffData(')
          ..write('id: $id, ')
          ..write('staffId: $staffId, ')
          ..write('userId: $userId, ')
          ..write('projectId: $projectId, ')
          ..write('channel: $channel, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      staffId,
      userId,
      projectId,
      channel,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      startDate,
      endDate,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectStaffData &&
          other.id == this.id &&
          other.staffId == this.staffId &&
          other.userId == this.userId &&
          other.projectId == this.projectId &&
          other.channel == this.channel &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.additionalFields == this.additionalFields);
}

class ProjectStaffCompanion extends UpdateCompanion<ProjectStaffData> {
  final Value<String> id;
  final Value<String?> staffId;
  final Value<String?> userId;
  final Value<String?> projectId;
  final Value<String?> channel;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int?> startDate;
  final Value<int?> endDate;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectStaffCompanion({
    this.id = const Value.absent(),
    this.staffId = const Value.absent(),
    this.userId = const Value.absent(),
    this.projectId = const Value.absent(),
    this.channel = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectStaffCompanion.insert({
    required String id,
    this.staffId = const Value.absent(),
    this.userId = const Value.absent(),
    this.projectId = const Value.absent(),
    this.channel = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<ProjectStaffData> custom({
    Expression<String>? id,
    Expression<String>? staffId,
    Expression<String>? userId,
    Expression<String>? projectId,
    Expression<String>? channel,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? startDate,
    Expression<int>? endDate,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (staffId != null) 'staff_id': staffId,
      if (userId != null) 'user_id': userId,
      if (projectId != null) 'project_id': projectId,
      if (channel != null) 'channel': channel,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectStaffCompanion copyWith(
      {Value<String>? id,
      Value<String?>? staffId,
      Value<String?>? userId,
      Value<String?>? projectId,
      Value<String?>? channel,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int?>? startDate,
      Value<int?>? endDate,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectStaffCompanion(
      id: id ?? this.id,
      staffId: staffId ?? this.staffId,
      userId: userId ?? this.userId,
      projectId: projectId ?? this.projectId,
      channel: channel ?? this.channel,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (staffId.present) {
      map['staff_id'] = Variable<String>(staffId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (channel.present) {
      map['channel'] = Variable<String>(channel.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<int>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<int>(endDate.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectStaffCompanion(')
          ..write('id: $id, ')
          ..write('staffId: $staffId, ')
          ..write('userId: $userId, ')
          ..write('projectId: $projectId, ')
          ..write('channel: $channel, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProjectTypeTable extends ProjectType
    with TableInfo<$ProjectTypeTable, ProjectTypeData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProjectTypeTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _groupMeta = const VerificationMeta('group');
  @override
  late final GeneratedColumn<String> group = GeneratedColumn<String>(
      'group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _beneficiaryTypeMeta =
      const VerificationMeta('beneficiaryType');
  @override
  late final GeneratedColumn<String> beneficiaryType = GeneratedColumn<String>(
      'beneficiary_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _eligibilityCriteriaMeta =
      const VerificationMeta('eligibilityCriteria');
  @override
  late final GeneratedColumn<String> eligibilityCriteria =
      GeneratedColumn<String>('eligibility_criteria', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _taskProcedureMeta =
      const VerificationMeta('taskProcedure');
  @override
  late final GeneratedColumn<String> taskProcedure = GeneratedColumn<String>(
      'task_procedure', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        name,
        code,
        group,
        beneficiaryType,
        eligibilityCriteria,
        taskProcedure,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'project_type';
  @override
  VerificationContext validateIntegrity(Insertable<ProjectTypeData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('group')) {
      context.handle(
          _groupMeta, group.isAcceptableOrUnknown(data['group']!, _groupMeta));
    }
    if (data.containsKey('beneficiary_type')) {
      context.handle(
          _beneficiaryTypeMeta,
          beneficiaryType.isAcceptableOrUnknown(
              data['beneficiary_type']!, _beneficiaryTypeMeta));
    }
    if (data.containsKey('eligibility_criteria')) {
      context.handle(
          _eligibilityCriteriaMeta,
          eligibilityCriteria.isAcceptableOrUnknown(
              data['eligibility_criteria']!, _eligibilityCriteriaMeta));
    }
    if (data.containsKey('task_procedure')) {
      context.handle(
          _taskProcedureMeta,
          taskProcedure.isAcceptableOrUnknown(
              data['task_procedure']!, _taskProcedureMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  ProjectTypeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProjectTypeData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      group: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}group']),
      beneficiaryType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}beneficiary_type']),
      eligibilityCriteria: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}eligibility_criteria']),
      taskProcedure: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}task_procedure']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ProjectTypeTable createAlias(String alias) {
    return $ProjectTypeTable(attachedDatabase, alias);
  }
}

class ProjectTypeData extends DataClass implements Insertable<ProjectTypeData> {
  final String? id;
  final String? name;
  final String? code;
  final String? group;
  final String? beneficiaryType;
  final String? eligibilityCriteria;
  final String? taskProcedure;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ProjectTypeData(
      {this.id,
      this.name,
      this.code,
      this.group,
      this.beneficiaryType,
      this.eligibilityCriteria,
      this.taskProcedure,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || group != null) {
      map['group'] = Variable<String>(group);
    }
    if (!nullToAbsent || beneficiaryType != null) {
      map['beneficiary_type'] = Variable<String>(beneficiaryType);
    }
    if (!nullToAbsent || eligibilityCriteria != null) {
      map['eligibility_criteria'] = Variable<String>(eligibilityCriteria);
    }
    if (!nullToAbsent || taskProcedure != null) {
      map['task_procedure'] = Variable<String>(taskProcedure);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ProjectTypeCompanion toCompanion(bool nullToAbsent) {
    return ProjectTypeCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      group:
          group == null && nullToAbsent ? const Value.absent() : Value(group),
      beneficiaryType: beneficiaryType == null && nullToAbsent
          ? const Value.absent()
          : Value(beneficiaryType),
      eligibilityCriteria: eligibilityCriteria == null && nullToAbsent
          ? const Value.absent()
          : Value(eligibilityCriteria),
      taskProcedure: taskProcedure == null && nullToAbsent
          ? const Value.absent()
          : Value(taskProcedure),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ProjectTypeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProjectTypeData(
      id: serializer.fromJson<String?>(json['id']),
      name: serializer.fromJson<String?>(json['name']),
      code: serializer.fromJson<String?>(json['code']),
      group: serializer.fromJson<String?>(json['group']),
      beneficiaryType: serializer.fromJson<String?>(json['beneficiaryType']),
      eligibilityCriteria:
          serializer.fromJson<String?>(json['eligibilityCriteria']),
      taskProcedure: serializer.fromJson<String?>(json['taskProcedure']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'name': serializer.toJson<String?>(name),
      'code': serializer.toJson<String?>(code),
      'group': serializer.toJson<String?>(group),
      'beneficiaryType': serializer.toJson<String?>(beneficiaryType),
      'eligibilityCriteria': serializer.toJson<String?>(eligibilityCriteria),
      'taskProcedure': serializer.toJson<String?>(taskProcedure),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ProjectTypeData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<String?> code = const Value.absent(),
          Value<String?> group = const Value.absent(),
          Value<String?> beneficiaryType = const Value.absent(),
          Value<String?> eligibilityCriteria = const Value.absent(),
          Value<String?> taskProcedure = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ProjectTypeData(
        id: id.present ? id.value : this.id,
        name: name.present ? name.value : this.name,
        code: code.present ? code.value : this.code,
        group: group.present ? group.value : this.group,
        beneficiaryType: beneficiaryType.present
            ? beneficiaryType.value
            : this.beneficiaryType,
        eligibilityCriteria: eligibilityCriteria.present
            ? eligibilityCriteria.value
            : this.eligibilityCriteria,
        taskProcedure:
            taskProcedure.present ? taskProcedure.value : this.taskProcedure,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ProjectTypeData(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('group: $group, ')
          ..write('beneficiaryType: $beneficiaryType, ')
          ..write('eligibilityCriteria: $eligibilityCriteria, ')
          ..write('taskProcedure: $taskProcedure, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        name,
        code,
        group,
        beneficiaryType,
        eligibilityCriteria,
        taskProcedure,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProjectTypeData &&
          other.id == this.id &&
          other.name == this.name &&
          other.code == this.code &&
          other.group == this.group &&
          other.beneficiaryType == this.beneficiaryType &&
          other.eligibilityCriteria == this.eligibilityCriteria &&
          other.taskProcedure == this.taskProcedure &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ProjectTypeCompanion extends UpdateCompanion<ProjectTypeData> {
  final Value<String?> id;
  final Value<String?> name;
  final Value<String?> code;
  final Value<String?> group;
  final Value<String?> beneficiaryType;
  final Value<String?> eligibilityCriteria;
  final Value<String?> taskProcedure;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ProjectTypeCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.group = const Value.absent(),
    this.beneficiaryType = const Value.absent(),
    this.eligibilityCriteria = const Value.absent(),
    this.taskProcedure = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProjectTypeCompanion.insert({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.group = const Value.absent(),
    this.beneficiaryType = const Value.absent(),
    this.eligibilityCriteria = const Value.absent(),
    this.taskProcedure = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<ProjectTypeData> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? code,
    Expression<String>? group,
    Expression<String>? beneficiaryType,
    Expression<String>? eligibilityCriteria,
    Expression<String>? taskProcedure,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (group != null) 'group': group,
      if (beneficiaryType != null) 'beneficiary_type': beneficiaryType,
      if (eligibilityCriteria != null)
        'eligibility_criteria': eligibilityCriteria,
      if (taskProcedure != null) 'task_procedure': taskProcedure,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProjectTypeCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? name,
      Value<String?>? code,
      Value<String?>? group,
      Value<String?>? beneficiaryType,
      Value<String?>? eligibilityCriteria,
      Value<String?>? taskProcedure,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ProjectTypeCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      code: code ?? this.code,
      group: group ?? this.group,
      beneficiaryType: beneficiaryType ?? this.beneficiaryType,
      eligibilityCriteria: eligibilityCriteria ?? this.eligibilityCriteria,
      taskProcedure: taskProcedure ?? this.taskProcedure,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (group.present) {
      map['group'] = Variable<String>(group.value);
    }
    if (beneficiaryType.present) {
      map['beneficiary_type'] = Variable<String>(beneficiaryType.value);
    }
    if (eligibilityCriteria.present) {
      map['eligibility_criteria'] = Variable<String>(eligibilityCriteria.value);
    }
    if (taskProcedure.present) {
      map['task_procedure'] = Variable<String>(taskProcedure.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProjectTypeCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('group: $group, ')
          ..write('beneficiaryType: $beneficiaryType, ')
          ..write('eligibilityCriteria: $eligibilityCriteria, ')
          ..write('taskProcedure: $taskProcedure, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $IndividualTable extends Individual
    with TableInfo<$IndividualTable, IndividualData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $IndividualTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _individualIdMeta =
      const VerificationMeta('individualId');
  @override
  late final GeneratedColumn<String> individualId = GeneratedColumn<String>(
      'individual_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
      'user_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userUuidMeta =
      const VerificationMeta('userUuid');
  @override
  late final GeneratedColumn<String> userUuid = GeneratedColumn<String>(
      'user_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _dateOfBirthMeta =
      const VerificationMeta('dateOfBirth');
  @override
  late final GeneratedColumn<String> dateOfBirth = GeneratedColumn<String>(
      'date_of_birth', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _mobileNumberMeta =
      const VerificationMeta('mobileNumber');
  @override
  late final GeneratedColumn<String> mobileNumber = GeneratedColumn<String>(
      'mobile_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _altContactNumberMeta =
      const VerificationMeta('altContactNumber');
  @override
  late final GeneratedColumn<String> altContactNumber = GeneratedColumn<String>(
      'alt_contact_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fatherNameMeta =
      const VerificationMeta('fatherName');
  @override
  late final GeneratedColumn<String> fatherName = GeneratedColumn<String>(
      'father_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _husbandNameMeta =
      const VerificationMeta('husbandName');
  @override
  late final GeneratedColumn<String> husbandName = GeneratedColumn<String>(
      'husband_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _photoMeta = const VerificationMeta('photo');
  @override
  late final GeneratedColumn<String> photo = GeneratedColumn<String>(
      'photo', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _bloodGroupMeta =
      const VerificationMeta('bloodGroup');
  @override
  late final GeneratedColumnWithTypeConverter<BloodGroup?, int> bloodGroup =
      GeneratedColumn<int>('blood_group', aliasedName, true,
              type: DriftSqlType.int, requiredDuringInsert: false)
          .withConverter<BloodGroup?>($IndividualTable.$converterbloodGroupn);
  static const VerificationMeta _genderMeta = const VerificationMeta('gender');
  @override
  late final GeneratedColumnWithTypeConverter<Gender?, int> gender =
      GeneratedColumn<int>('gender', aliasedName, true,
              type: DriftSqlType.int, requiredDuringInsert: false)
          .withConverter<Gender?>($IndividualTable.$convertergendern);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        individualId,
        userId,
        userUuid,
        dateOfBirth,
        mobileNumber,
        altContactNumber,
        email,
        fatherName,
        husbandName,
        photo,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        bloodGroup,
        gender,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'individual';
  @override
  VerificationContext validateIntegrity(Insertable<IndividualData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('individual_id')) {
      context.handle(
          _individualIdMeta,
          individualId.isAcceptableOrUnknown(
              data['individual_id']!, _individualIdMeta));
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    }
    if (data.containsKey('user_uuid')) {
      context.handle(_userUuidMeta,
          userUuid.isAcceptableOrUnknown(data['user_uuid']!, _userUuidMeta));
    }
    if (data.containsKey('date_of_birth')) {
      context.handle(
          _dateOfBirthMeta,
          dateOfBirth.isAcceptableOrUnknown(
              data['date_of_birth']!, _dateOfBirthMeta));
    }
    if (data.containsKey('mobile_number')) {
      context.handle(
          _mobileNumberMeta,
          mobileNumber.isAcceptableOrUnknown(
              data['mobile_number']!, _mobileNumberMeta));
    }
    if (data.containsKey('alt_contact_number')) {
      context.handle(
          _altContactNumberMeta,
          altContactNumber.isAcceptableOrUnknown(
              data['alt_contact_number']!, _altContactNumberMeta));
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('father_name')) {
      context.handle(
          _fatherNameMeta,
          fatherName.isAcceptableOrUnknown(
              data['father_name']!, _fatherNameMeta));
    }
    if (data.containsKey('husband_name')) {
      context.handle(
          _husbandNameMeta,
          husbandName.isAcceptableOrUnknown(
              data['husband_name']!, _husbandNameMeta));
    }
    if (data.containsKey('photo')) {
      context.handle(
          _photoMeta, photo.isAcceptableOrUnknown(data['photo']!, _photoMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    context.handle(_bloodGroupMeta, const VerificationResult.success());
    context.handle(_genderMeta, const VerificationResult.success());
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  IndividualData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return IndividualData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      individualId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}individual_id']),
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_id']),
      userUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_uuid']),
      dateOfBirth: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}date_of_birth']),
      mobileNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mobile_number']),
      altContactNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}alt_contact_number']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      fatherName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}father_name']),
      husbandName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}husband_name']),
      photo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}photo']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      bloodGroup: $IndividualTable.$converterbloodGroupn.fromSql(
          attachedDatabase.typeMapping
              .read(DriftSqlType.int, data['${effectivePrefix}blood_group'])),
      gender: $IndividualTable.$convertergendern.fromSql(attachedDatabase
          .typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}gender'])),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $IndividualTable createAlias(String alias) {
    return $IndividualTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<BloodGroup, int, int> $converterbloodGroup =
      const EnumIndexConverter<BloodGroup>(BloodGroup.values);
  static JsonTypeConverter2<BloodGroup?, int?, int?> $converterbloodGroupn =
      JsonTypeConverter2.asNullable($converterbloodGroup);
  static JsonTypeConverter2<Gender, int, int> $convertergender =
      const EnumIndexConverter<Gender>(Gender.values);
  static JsonTypeConverter2<Gender?, int?, int?> $convertergendern =
      JsonTypeConverter2.asNullable($convertergender);
}

class IndividualData extends DataClass implements Insertable<IndividualData> {
  final String? id;
  final String? individualId;
  final String? userId;
  final String? userUuid;
  final String? dateOfBirth;
  final String? mobileNumber;
  final String? altContactNumber;
  final String? email;
  final String? fatherName;
  final String? husbandName;
  final String? photo;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final BloodGroup? bloodGroup;
  final Gender? gender;
  final String? additionalFields;
  const IndividualData(
      {this.id,
      this.individualId,
      this.userId,
      this.userUuid,
      this.dateOfBirth,
      this.mobileNumber,
      this.altContactNumber,
      this.email,
      this.fatherName,
      this.husbandName,
      this.photo,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.bloodGroup,
      this.gender,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || individualId != null) {
      map['individual_id'] = Variable<String>(individualId);
    }
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<String>(userId);
    }
    if (!nullToAbsent || userUuid != null) {
      map['user_uuid'] = Variable<String>(userUuid);
    }
    if (!nullToAbsent || dateOfBirth != null) {
      map['date_of_birth'] = Variable<String>(dateOfBirth);
    }
    if (!nullToAbsent || mobileNumber != null) {
      map['mobile_number'] = Variable<String>(mobileNumber);
    }
    if (!nullToAbsent || altContactNumber != null) {
      map['alt_contact_number'] = Variable<String>(altContactNumber);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || fatherName != null) {
      map['father_name'] = Variable<String>(fatherName);
    }
    if (!nullToAbsent || husbandName != null) {
      map['husband_name'] = Variable<String>(husbandName);
    }
    if (!nullToAbsent || photo != null) {
      map['photo'] = Variable<String>(photo);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || bloodGroup != null) {
      map['blood_group'] = Variable<int>(
          $IndividualTable.$converterbloodGroupn.toSql(bloodGroup));
    }
    if (!nullToAbsent || gender != null) {
      map['gender'] =
          Variable<int>($IndividualTable.$convertergendern.toSql(gender));
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  IndividualCompanion toCompanion(bool nullToAbsent) {
    return IndividualCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      individualId: individualId == null && nullToAbsent
          ? const Value.absent()
          : Value(individualId),
      userId:
          userId == null && nullToAbsent ? const Value.absent() : Value(userId),
      userUuid: userUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(userUuid),
      dateOfBirth: dateOfBirth == null && nullToAbsent
          ? const Value.absent()
          : Value(dateOfBirth),
      mobileNumber: mobileNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(mobileNumber),
      altContactNumber: altContactNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(altContactNumber),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      fatherName: fatherName == null && nullToAbsent
          ? const Value.absent()
          : Value(fatherName),
      husbandName: husbandName == null && nullToAbsent
          ? const Value.absent()
          : Value(husbandName),
      photo:
          photo == null && nullToAbsent ? const Value.absent() : Value(photo),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      bloodGroup: bloodGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(bloodGroup),
      gender:
          gender == null && nullToAbsent ? const Value.absent() : Value(gender),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory IndividualData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return IndividualData(
      id: serializer.fromJson<String?>(json['id']),
      individualId: serializer.fromJson<String?>(json['individualId']),
      userId: serializer.fromJson<String?>(json['userId']),
      userUuid: serializer.fromJson<String?>(json['userUuid']),
      dateOfBirth: serializer.fromJson<String?>(json['dateOfBirth']),
      mobileNumber: serializer.fromJson<String?>(json['mobileNumber']),
      altContactNumber: serializer.fromJson<String?>(json['altContactNumber']),
      email: serializer.fromJson<String?>(json['email']),
      fatherName: serializer.fromJson<String?>(json['fatherName']),
      husbandName: serializer.fromJson<String?>(json['husbandName']),
      photo: serializer.fromJson<String?>(json['photo']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      bloodGroup: $IndividualTable.$converterbloodGroupn
          .fromJson(serializer.fromJson<int?>(json['bloodGroup'])),
      gender: $IndividualTable.$convertergendern
          .fromJson(serializer.fromJson<int?>(json['gender'])),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'individualId': serializer.toJson<String?>(individualId),
      'userId': serializer.toJson<String?>(userId),
      'userUuid': serializer.toJson<String?>(userUuid),
      'dateOfBirth': serializer.toJson<String?>(dateOfBirth),
      'mobileNumber': serializer.toJson<String?>(mobileNumber),
      'altContactNumber': serializer.toJson<String?>(altContactNumber),
      'email': serializer.toJson<String?>(email),
      'fatherName': serializer.toJson<String?>(fatherName),
      'husbandName': serializer.toJson<String?>(husbandName),
      'photo': serializer.toJson<String?>(photo),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'bloodGroup': serializer.toJson<int?>(
          $IndividualTable.$converterbloodGroupn.toJson(bloodGroup)),
      'gender': serializer
          .toJson<int?>($IndividualTable.$convertergendern.toJson(gender)),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  IndividualData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> individualId = const Value.absent(),
          Value<String?> userId = const Value.absent(),
          Value<String?> userUuid = const Value.absent(),
          Value<String?> dateOfBirth = const Value.absent(),
          Value<String?> mobileNumber = const Value.absent(),
          Value<String?> altContactNumber = const Value.absent(),
          Value<String?> email = const Value.absent(),
          Value<String?> fatherName = const Value.absent(),
          Value<String?> husbandName = const Value.absent(),
          Value<String?> photo = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<BloodGroup?> bloodGroup = const Value.absent(),
          Value<Gender?> gender = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      IndividualData(
        id: id.present ? id.value : this.id,
        individualId:
            individualId.present ? individualId.value : this.individualId,
        userId: userId.present ? userId.value : this.userId,
        userUuid: userUuid.present ? userUuid.value : this.userUuid,
        dateOfBirth: dateOfBirth.present ? dateOfBirth.value : this.dateOfBirth,
        mobileNumber:
            mobileNumber.present ? mobileNumber.value : this.mobileNumber,
        altContactNumber: altContactNumber.present
            ? altContactNumber.value
            : this.altContactNumber,
        email: email.present ? email.value : this.email,
        fatherName: fatherName.present ? fatherName.value : this.fatherName,
        husbandName: husbandName.present ? husbandName.value : this.husbandName,
        photo: photo.present ? photo.value : this.photo,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        bloodGroup: bloodGroup.present ? bloodGroup.value : this.bloodGroup,
        gender: gender.present ? gender.value : this.gender,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('IndividualData(')
          ..write('id: $id, ')
          ..write('individualId: $individualId, ')
          ..write('userId: $userId, ')
          ..write('userUuid: $userUuid, ')
          ..write('dateOfBirth: $dateOfBirth, ')
          ..write('mobileNumber: $mobileNumber, ')
          ..write('altContactNumber: $altContactNumber, ')
          ..write('email: $email, ')
          ..write('fatherName: $fatherName, ')
          ..write('husbandName: $husbandName, ')
          ..write('photo: $photo, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('bloodGroup: $bloodGroup, ')
          ..write('gender: $gender, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        individualId,
        userId,
        userUuid,
        dateOfBirth,
        mobileNumber,
        altContactNumber,
        email,
        fatherName,
        husbandName,
        photo,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        bloodGroup,
        gender,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is IndividualData &&
          other.id == this.id &&
          other.individualId == this.individualId &&
          other.userId == this.userId &&
          other.userUuid == this.userUuid &&
          other.dateOfBirth == this.dateOfBirth &&
          other.mobileNumber == this.mobileNumber &&
          other.altContactNumber == this.altContactNumber &&
          other.email == this.email &&
          other.fatherName == this.fatherName &&
          other.husbandName == this.husbandName &&
          other.photo == this.photo &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.bloodGroup == this.bloodGroup &&
          other.gender == this.gender &&
          other.additionalFields == this.additionalFields);
}

class IndividualCompanion extends UpdateCompanion<IndividualData> {
  final Value<String?> id;
  final Value<String?> individualId;
  final Value<String?> userId;
  final Value<String?> userUuid;
  final Value<String?> dateOfBirth;
  final Value<String?> mobileNumber;
  final Value<String?> altContactNumber;
  final Value<String?> email;
  final Value<String?> fatherName;
  final Value<String?> husbandName;
  final Value<String?> photo;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<BloodGroup?> bloodGroup;
  final Value<Gender?> gender;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const IndividualCompanion({
    this.id = const Value.absent(),
    this.individualId = const Value.absent(),
    this.userId = const Value.absent(),
    this.userUuid = const Value.absent(),
    this.dateOfBirth = const Value.absent(),
    this.mobileNumber = const Value.absent(),
    this.altContactNumber = const Value.absent(),
    this.email = const Value.absent(),
    this.fatherName = const Value.absent(),
    this.husbandName = const Value.absent(),
    this.photo = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.bloodGroup = const Value.absent(),
    this.gender = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  IndividualCompanion.insert({
    this.id = const Value.absent(),
    this.individualId = const Value.absent(),
    this.userId = const Value.absent(),
    this.userUuid = const Value.absent(),
    this.dateOfBirth = const Value.absent(),
    this.mobileNumber = const Value.absent(),
    this.altContactNumber = const Value.absent(),
    this.email = const Value.absent(),
    this.fatherName = const Value.absent(),
    this.husbandName = const Value.absent(),
    this.photo = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.bloodGroup = const Value.absent(),
    this.gender = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<IndividualData> custom({
    Expression<String>? id,
    Expression<String>? individualId,
    Expression<String>? userId,
    Expression<String>? userUuid,
    Expression<String>? dateOfBirth,
    Expression<String>? mobileNumber,
    Expression<String>? altContactNumber,
    Expression<String>? email,
    Expression<String>? fatherName,
    Expression<String>? husbandName,
    Expression<String>? photo,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? bloodGroup,
    Expression<int>? gender,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (individualId != null) 'individual_id': individualId,
      if (userId != null) 'user_id': userId,
      if (userUuid != null) 'user_uuid': userUuid,
      if (dateOfBirth != null) 'date_of_birth': dateOfBirth,
      if (mobileNumber != null) 'mobile_number': mobileNumber,
      if (altContactNumber != null) 'alt_contact_number': altContactNumber,
      if (email != null) 'email': email,
      if (fatherName != null) 'father_name': fatherName,
      if (husbandName != null) 'husband_name': husbandName,
      if (photo != null) 'photo': photo,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (bloodGroup != null) 'blood_group': bloodGroup,
      if (gender != null) 'gender': gender,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  IndividualCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? individualId,
      Value<String?>? userId,
      Value<String?>? userUuid,
      Value<String?>? dateOfBirth,
      Value<String?>? mobileNumber,
      Value<String?>? altContactNumber,
      Value<String?>? email,
      Value<String?>? fatherName,
      Value<String?>? husbandName,
      Value<String?>? photo,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<BloodGroup?>? bloodGroup,
      Value<Gender?>? gender,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return IndividualCompanion(
      id: id ?? this.id,
      individualId: individualId ?? this.individualId,
      userId: userId ?? this.userId,
      userUuid: userUuid ?? this.userUuid,
      dateOfBirth: dateOfBirth ?? this.dateOfBirth,
      mobileNumber: mobileNumber ?? this.mobileNumber,
      altContactNumber: altContactNumber ?? this.altContactNumber,
      email: email ?? this.email,
      fatherName: fatherName ?? this.fatherName,
      husbandName: husbandName ?? this.husbandName,
      photo: photo ?? this.photo,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      bloodGroup: bloodGroup ?? this.bloodGroup,
      gender: gender ?? this.gender,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (individualId.present) {
      map['individual_id'] = Variable<String>(individualId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (userUuid.present) {
      map['user_uuid'] = Variable<String>(userUuid.value);
    }
    if (dateOfBirth.present) {
      map['date_of_birth'] = Variable<String>(dateOfBirth.value);
    }
    if (mobileNumber.present) {
      map['mobile_number'] = Variable<String>(mobileNumber.value);
    }
    if (altContactNumber.present) {
      map['alt_contact_number'] = Variable<String>(altContactNumber.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (fatherName.present) {
      map['father_name'] = Variable<String>(fatherName.value);
    }
    if (husbandName.present) {
      map['husband_name'] = Variable<String>(husbandName.value);
    }
    if (photo.present) {
      map['photo'] = Variable<String>(photo.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (bloodGroup.present) {
      map['blood_group'] = Variable<int>(
          $IndividualTable.$converterbloodGroupn.toSql(bloodGroup.value));
    }
    if (gender.present) {
      map['gender'] =
          Variable<int>($IndividualTable.$convertergendern.toSql(gender.value));
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('IndividualCompanion(')
          ..write('id: $id, ')
          ..write('individualId: $individualId, ')
          ..write('userId: $userId, ')
          ..write('userUuid: $userUuid, ')
          ..write('dateOfBirth: $dateOfBirth, ')
          ..write('mobileNumber: $mobileNumber, ')
          ..write('altContactNumber: $altContactNumber, ')
          ..write('email: $email, ')
          ..write('fatherName: $fatherName, ')
          ..write('husbandName: $husbandName, ')
          ..write('photo: $photo, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('bloodGroup: $bloodGroup, ')
          ..write('gender: $gender, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $IdentifierTable extends Identifier
    with TableInfo<$IdentifierTable, IdentifierData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $IdentifierTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _identifierTypeMeta =
      const VerificationMeta('identifierType');
  @override
  late final GeneratedColumn<String> identifierType = GeneratedColumn<String>(
      'identifier_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _identifierIdMeta =
      const VerificationMeta('identifierId');
  @override
  late final GeneratedColumn<String> identifierId = GeneratedColumn<String>(
      'identifier_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        identifierType,
        identifierId,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'identifier';
  @override
  VerificationContext validateIntegrity(Insertable<IdentifierData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('identifier_type')) {
      context.handle(
          _identifierTypeMeta,
          identifierType.isAcceptableOrUnknown(
              data['identifier_type']!, _identifierTypeMeta));
    }
    if (data.containsKey('identifier_id')) {
      context.handle(
          _identifierIdMeta,
          identifierId.isAcceptableOrUnknown(
              data['identifier_id']!, _identifierIdMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  IdentifierData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return IdentifierData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      identifierType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}identifier_type']),
      identifierId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}identifier_id']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $IdentifierTable createAlias(String alias) {
    return $IdentifierTable(attachedDatabase, alias);
  }
}

class IdentifierData extends DataClass implements Insertable<IdentifierData> {
  final String? id;
  final String? identifierType;
  final String? identifierId;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const IdentifierData(
      {this.id,
      this.identifierType,
      this.identifierId,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || identifierType != null) {
      map['identifier_type'] = Variable<String>(identifierType);
    }
    if (!nullToAbsent || identifierId != null) {
      map['identifier_id'] = Variable<String>(identifierId);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  IdentifierCompanion toCompanion(bool nullToAbsent) {
    return IdentifierCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      identifierType: identifierType == null && nullToAbsent
          ? const Value.absent()
          : Value(identifierType),
      identifierId: identifierId == null && nullToAbsent
          ? const Value.absent()
          : Value(identifierId),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory IdentifierData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return IdentifierData(
      id: serializer.fromJson<String?>(json['id']),
      identifierType: serializer.fromJson<String?>(json['identifierType']),
      identifierId: serializer.fromJson<String?>(json['identifierId']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'identifierType': serializer.toJson<String?>(identifierType),
      'identifierId': serializer.toJson<String?>(identifierId),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  IdentifierData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> identifierType = const Value.absent(),
          Value<String?> identifierId = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      IdentifierData(
        id: id.present ? id.value : this.id,
        identifierType:
            identifierType.present ? identifierType.value : this.identifierType,
        identifierId:
            identifierId.present ? identifierId.value : this.identifierId,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('IdentifierData(')
          ..write('id: $id, ')
          ..write('identifierType: $identifierType, ')
          ..write('identifierId: $identifierId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      identifierType,
      identifierId,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is IdentifierData &&
          other.id == this.id &&
          other.identifierType == this.identifierType &&
          other.identifierId == this.identifierId &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class IdentifierCompanion extends UpdateCompanion<IdentifierData> {
  final Value<String?> id;
  final Value<String?> identifierType;
  final Value<String?> identifierId;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const IdentifierCompanion({
    this.id = const Value.absent(),
    this.identifierType = const Value.absent(),
    this.identifierId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  IdentifierCompanion.insert({
    this.id = const Value.absent(),
    this.identifierType = const Value.absent(),
    this.identifierId = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<IdentifierData> custom({
    Expression<String>? id,
    Expression<String>? identifierType,
    Expression<String>? identifierId,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (identifierType != null) 'identifier_type': identifierType,
      if (identifierId != null) 'identifier_id': identifierId,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  IdentifierCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? identifierType,
      Value<String?>? identifierId,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return IdentifierCompanion(
      id: id ?? this.id,
      identifierType: identifierType ?? this.identifierType,
      identifierId: identifierId ?? this.identifierId,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (identifierType.present) {
      map['identifier_type'] = Variable<String>(identifierType.value);
    }
    if (identifierId.present) {
      map['identifier_id'] = Variable<String>(identifierId.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('IdentifierCompanion(')
          ..write('id: $id, ')
          ..write('identifierType: $identifierType, ')
          ..write('identifierId: $identifierId, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StockTable extends Stock with TableInfo<$StockTable, StockData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _facilityIdMeta =
      const VerificationMeta('facilityId');
  @override
  late final GeneratedColumn<String> facilityId = GeneratedColumn<String>(
      'facility_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _productVariantIdMeta =
      const VerificationMeta('productVariantId');
  @override
  late final GeneratedColumn<String> productVariantId = GeneratedColumn<String>(
      'product_variant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdTypeMeta =
      const VerificationMeta('referenceIdType');
  @override
  late final GeneratedColumn<String> referenceIdType = GeneratedColumn<String>(
      'reference_id_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _transactingPartyIdMeta =
      const VerificationMeta('transactingPartyId');
  @override
  late final GeneratedColumn<String> transactingPartyId =
      GeneratedColumn<String>('transacting_party_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _transactingPartyTypeMeta =
      const VerificationMeta('transactingPartyType');
  @override
  late final GeneratedColumn<String> transactingPartyType =
      GeneratedColumn<String>('transacting_party_type', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  @override
  late final GeneratedColumn<String> quantity = GeneratedColumn<String>(
      'quantity', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _waybillNumberMeta =
      const VerificationMeta('waybillNumber');
  @override
  late final GeneratedColumn<String> waybillNumber = GeneratedColumn<String>(
      'waybill_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _receiverIdMeta =
      const VerificationMeta('receiverId');
  @override
  late final GeneratedColumn<String> receiverId = GeneratedColumn<String>(
      'receiver_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _receiverTypeMeta =
      const VerificationMeta('receiverType');
  @override
  late final GeneratedColumn<String> receiverType = GeneratedColumn<String>(
      'receiver_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _senderIdMeta =
      const VerificationMeta('senderId');
  @override
  late final GeneratedColumn<String> senderId = GeneratedColumn<String>(
      'sender_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _senderTypeMeta =
      const VerificationMeta('senderType');
  @override
  late final GeneratedColumn<String> senderType = GeneratedColumn<String>(
      'sender_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _transactionTypeMeta =
      const VerificationMeta('transactionType');
  @override
  late final GeneratedColumn<String> transactionType = GeneratedColumn<String>(
      'transaction_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _transactionReasonMeta =
      const VerificationMeta('transactionReason');
  @override
  late final GeneratedColumn<String> transactionReason =
      GeneratedColumn<String>('transaction_reason', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        facilityId,
        productVariantId,
        referenceId,
        referenceIdType,
        transactingPartyId,
        transactingPartyType,
        quantity,
        waybillNumber,
        receiverId,
        receiverType,
        senderId,
        senderType,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        transactionType,
        transactionReason,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock';
  @override
  VerificationContext validateIntegrity(Insertable<StockData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('facility_id')) {
      context.handle(
          _facilityIdMeta,
          facilityId.isAcceptableOrUnknown(
              data['facility_id']!, _facilityIdMeta));
    }
    if (data.containsKey('product_variant_id')) {
      context.handle(
          _productVariantIdMeta,
          productVariantId.isAcceptableOrUnknown(
              data['product_variant_id']!, _productVariantIdMeta));
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    }
    if (data.containsKey('reference_id_type')) {
      context.handle(
          _referenceIdTypeMeta,
          referenceIdType.isAcceptableOrUnknown(
              data['reference_id_type']!, _referenceIdTypeMeta));
    }
    if (data.containsKey('transacting_party_id')) {
      context.handle(
          _transactingPartyIdMeta,
          transactingPartyId.isAcceptableOrUnknown(
              data['transacting_party_id']!, _transactingPartyIdMeta));
    }
    if (data.containsKey('transacting_party_type')) {
      context.handle(
          _transactingPartyTypeMeta,
          transactingPartyType.isAcceptableOrUnknown(
              data['transacting_party_type']!, _transactingPartyTypeMeta));
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    }
    if (data.containsKey('waybill_number')) {
      context.handle(
          _waybillNumberMeta,
          waybillNumber.isAcceptableOrUnknown(
              data['waybill_number']!, _waybillNumberMeta));
    }
    if (data.containsKey('receiver_id')) {
      context.handle(
          _receiverIdMeta,
          receiverId.isAcceptableOrUnknown(
              data['receiver_id']!, _receiverIdMeta));
    }
    if (data.containsKey('receiver_type')) {
      context.handle(
          _receiverTypeMeta,
          receiverType.isAcceptableOrUnknown(
              data['receiver_type']!, _receiverTypeMeta));
    }
    if (data.containsKey('sender_id')) {
      context.handle(_senderIdMeta,
          senderId.isAcceptableOrUnknown(data['sender_id']!, _senderIdMeta));
    }
    if (data.containsKey('sender_type')) {
      context.handle(
          _senderTypeMeta,
          senderType.isAcceptableOrUnknown(
              data['sender_type']!, _senderTypeMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('transaction_type')) {
      context.handle(
          _transactionTypeMeta,
          transactionType.isAcceptableOrUnknown(
              data['transaction_type']!, _transactionTypeMeta));
    }
    if (data.containsKey('transaction_reason')) {
      context.handle(
          _transactionReasonMeta,
          transactionReason.isAcceptableOrUnknown(
              data['transaction_reason']!, _transactionReasonMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  StockData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      facilityId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}facility_id']),
      productVariantId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}product_variant_id']),
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id']),
      referenceIdType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}reference_id_type']),
      transactingPartyId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transacting_party_id']),
      transactingPartyType: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}transacting_party_type']),
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}quantity']),
      waybillNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}waybill_number']),
      receiverId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}receiver_id']),
      receiverType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}receiver_type']),
      senderId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sender_id']),
      senderType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sender_type']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      transactionType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_type']),
      transactionReason: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_reason']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $StockTable createAlias(String alias) {
    return $StockTable(attachedDatabase, alias);
  }
}

class StockData extends DataClass implements Insertable<StockData> {
  final String? id;
  final String? tenantId;
  final String? facilityId;
  final String? productVariantId;
  final String? referenceId;
  final String? referenceIdType;
  final String? transactingPartyId;
  final String? transactingPartyType;
  final String? quantity;
  final String? waybillNumber;
  final String? receiverId;
  final String? receiverType;
  final String? senderId;
  final String? senderType;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? transactionType;
  final String? transactionReason;
  final String? additionalFields;
  const StockData(
      {this.id,
      this.tenantId,
      this.facilityId,
      this.productVariantId,
      this.referenceId,
      this.referenceIdType,
      this.transactingPartyId,
      this.transactingPartyType,
      this.quantity,
      this.waybillNumber,
      this.receiverId,
      this.receiverType,
      this.senderId,
      this.senderType,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.isDeleted,
      this.rowVersion,
      this.transactionType,
      this.transactionReason,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || facilityId != null) {
      map['facility_id'] = Variable<String>(facilityId);
    }
    if (!nullToAbsent || productVariantId != null) {
      map['product_variant_id'] = Variable<String>(productVariantId);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    if (!nullToAbsent || referenceIdType != null) {
      map['reference_id_type'] = Variable<String>(referenceIdType);
    }
    if (!nullToAbsent || transactingPartyId != null) {
      map['transacting_party_id'] = Variable<String>(transactingPartyId);
    }
    if (!nullToAbsent || transactingPartyType != null) {
      map['transacting_party_type'] = Variable<String>(transactingPartyType);
    }
    if (!nullToAbsent || quantity != null) {
      map['quantity'] = Variable<String>(quantity);
    }
    if (!nullToAbsent || waybillNumber != null) {
      map['waybill_number'] = Variable<String>(waybillNumber);
    }
    if (!nullToAbsent || receiverId != null) {
      map['receiver_id'] = Variable<String>(receiverId);
    }
    if (!nullToAbsent || receiverType != null) {
      map['receiver_type'] = Variable<String>(receiverType);
    }
    if (!nullToAbsent || senderId != null) {
      map['sender_id'] = Variable<String>(senderId);
    }
    if (!nullToAbsent || senderType != null) {
      map['sender_type'] = Variable<String>(senderType);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || transactionType != null) {
      map['transaction_type'] = Variable<String>(transactionType);
    }
    if (!nullToAbsent || transactionReason != null) {
      map['transaction_reason'] = Variable<String>(transactionReason);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  StockCompanion toCompanion(bool nullToAbsent) {
    return StockCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      facilityId: facilityId == null && nullToAbsent
          ? const Value.absent()
          : Value(facilityId),
      productVariantId: productVariantId == null && nullToAbsent
          ? const Value.absent()
          : Value(productVariantId),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      referenceIdType: referenceIdType == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceIdType),
      transactingPartyId: transactingPartyId == null && nullToAbsent
          ? const Value.absent()
          : Value(transactingPartyId),
      transactingPartyType: transactingPartyType == null && nullToAbsent
          ? const Value.absent()
          : Value(transactingPartyType),
      quantity: quantity == null && nullToAbsent
          ? const Value.absent()
          : Value(quantity),
      waybillNumber: waybillNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(waybillNumber),
      receiverId: receiverId == null && nullToAbsent
          ? const Value.absent()
          : Value(receiverId),
      receiverType: receiverType == null && nullToAbsent
          ? const Value.absent()
          : Value(receiverType),
      senderId: senderId == null && nullToAbsent
          ? const Value.absent()
          : Value(senderId),
      senderType: senderType == null && nullToAbsent
          ? const Value.absent()
          : Value(senderType),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      transactionType: transactionType == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionType),
      transactionReason: transactionReason == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionReason),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory StockData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      facilityId: serializer.fromJson<String?>(json['facilityId']),
      productVariantId: serializer.fromJson<String?>(json['productVariantId']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      referenceIdType: serializer.fromJson<String?>(json['referenceIdType']),
      transactingPartyId:
          serializer.fromJson<String?>(json['transactingPartyId']),
      transactingPartyType:
          serializer.fromJson<String?>(json['transactingPartyType']),
      quantity: serializer.fromJson<String?>(json['quantity']),
      waybillNumber: serializer.fromJson<String?>(json['waybillNumber']),
      receiverId: serializer.fromJson<String?>(json['receiverId']),
      receiverType: serializer.fromJson<String?>(json['receiverType']),
      senderId: serializer.fromJson<String?>(json['senderId']),
      senderType: serializer.fromJson<String?>(json['senderType']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      transactionType: serializer.fromJson<String?>(json['transactionType']),
      transactionReason:
          serializer.fromJson<String?>(json['transactionReason']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String?>(tenantId),
      'facilityId': serializer.toJson<String?>(facilityId),
      'productVariantId': serializer.toJson<String?>(productVariantId),
      'referenceId': serializer.toJson<String?>(referenceId),
      'referenceIdType': serializer.toJson<String?>(referenceIdType),
      'transactingPartyId': serializer.toJson<String?>(transactingPartyId),
      'transactingPartyType': serializer.toJson<String?>(transactingPartyType),
      'quantity': serializer.toJson<String?>(quantity),
      'waybillNumber': serializer.toJson<String?>(waybillNumber),
      'receiverId': serializer.toJson<String?>(receiverId),
      'receiverType': serializer.toJson<String?>(receiverType),
      'senderId': serializer.toJson<String?>(senderId),
      'senderType': serializer.toJson<String?>(senderType),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'transactionType': serializer.toJson<String?>(transactionType),
      'transactionReason': serializer.toJson<String?>(transactionReason),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  StockData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> facilityId = const Value.absent(),
          Value<String?> productVariantId = const Value.absent(),
          Value<String?> referenceId = const Value.absent(),
          Value<String?> referenceIdType = const Value.absent(),
          Value<String?> transactingPartyId = const Value.absent(),
          Value<String?> transactingPartyType = const Value.absent(),
          Value<String?> quantity = const Value.absent(),
          Value<String?> waybillNumber = const Value.absent(),
          Value<String?> receiverId = const Value.absent(),
          Value<String?> receiverType = const Value.absent(),
          Value<String?> senderId = const Value.absent(),
          Value<String?> senderType = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> transactionType = const Value.absent(),
          Value<String?> transactionReason = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      StockData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        facilityId: facilityId.present ? facilityId.value : this.facilityId,
        productVariantId: productVariantId.present
            ? productVariantId.value
            : this.productVariantId,
        referenceId: referenceId.present ? referenceId.value : this.referenceId,
        referenceIdType: referenceIdType.present
            ? referenceIdType.value
            : this.referenceIdType,
        transactingPartyId: transactingPartyId.present
            ? transactingPartyId.value
            : this.transactingPartyId,
        transactingPartyType: transactingPartyType.present
            ? transactingPartyType.value
            : this.transactingPartyType,
        quantity: quantity.present ? quantity.value : this.quantity,
        waybillNumber:
            waybillNumber.present ? waybillNumber.value : this.waybillNumber,
        receiverId: receiverId.present ? receiverId.value : this.receiverId,
        receiverType:
            receiverType.present ? receiverType.value : this.receiverType,
        senderId: senderId.present ? senderId.value : this.senderId,
        senderType: senderType.present ? senderType.value : this.senderType,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        transactionType: transactionType.present
            ? transactionType.value
            : this.transactionType,
        transactionReason: transactionReason.present
            ? transactionReason.value
            : this.transactionReason,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('StockData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('facilityId: $facilityId, ')
          ..write('productVariantId: $productVariantId, ')
          ..write('referenceId: $referenceId, ')
          ..write('referenceIdType: $referenceIdType, ')
          ..write('transactingPartyId: $transactingPartyId, ')
          ..write('transactingPartyType: $transactingPartyType, ')
          ..write('quantity: $quantity, ')
          ..write('waybillNumber: $waybillNumber, ')
          ..write('receiverId: $receiverId, ')
          ..write('receiverType: $receiverType, ')
          ..write('senderId: $senderId, ')
          ..write('senderType: $senderType, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('transactionType: $transactionType, ')
          ..write('transactionReason: $transactionReason, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        tenantId,
        facilityId,
        productVariantId,
        referenceId,
        referenceIdType,
        transactingPartyId,
        transactingPartyType,
        quantity,
        waybillNumber,
        receiverId,
        receiverType,
        senderId,
        senderType,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        transactionType,
        transactionReason,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.facilityId == this.facilityId &&
          other.productVariantId == this.productVariantId &&
          other.referenceId == this.referenceId &&
          other.referenceIdType == this.referenceIdType &&
          other.transactingPartyId == this.transactingPartyId &&
          other.transactingPartyType == this.transactingPartyType &&
          other.quantity == this.quantity &&
          other.waybillNumber == this.waybillNumber &&
          other.receiverId == this.receiverId &&
          other.receiverType == this.receiverType &&
          other.senderId == this.senderId &&
          other.senderType == this.senderType &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.transactionType == this.transactionType &&
          other.transactionReason == this.transactionReason &&
          other.additionalFields == this.additionalFields);
}

class StockCompanion extends UpdateCompanion<StockData> {
  final Value<String?> id;
  final Value<String?> tenantId;
  final Value<String?> facilityId;
  final Value<String?> productVariantId;
  final Value<String?> referenceId;
  final Value<String?> referenceIdType;
  final Value<String?> transactingPartyId;
  final Value<String?> transactingPartyType;
  final Value<String?> quantity;
  final Value<String?> waybillNumber;
  final Value<String?> receiverId;
  final Value<String?> receiverType;
  final Value<String?> senderId;
  final Value<String?> senderType;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> transactionType;
  final Value<String?> transactionReason;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const StockCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.facilityId = const Value.absent(),
    this.productVariantId = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.referenceIdType = const Value.absent(),
    this.transactingPartyId = const Value.absent(),
    this.transactingPartyType = const Value.absent(),
    this.quantity = const Value.absent(),
    this.waybillNumber = const Value.absent(),
    this.receiverId = const Value.absent(),
    this.receiverType = const Value.absent(),
    this.senderId = const Value.absent(),
    this.senderType = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.transactionType = const Value.absent(),
    this.transactionReason = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  StockCompanion.insert({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.facilityId = const Value.absent(),
    this.productVariantId = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.referenceIdType = const Value.absent(),
    this.transactingPartyId = const Value.absent(),
    this.transactingPartyType = const Value.absent(),
    this.quantity = const Value.absent(),
    this.waybillNumber = const Value.absent(),
    this.receiverId = const Value.absent(),
    this.receiverType = const Value.absent(),
    this.senderId = const Value.absent(),
    this.senderType = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.transactionType = const Value.absent(),
    this.transactionReason = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<StockData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? facilityId,
    Expression<String>? productVariantId,
    Expression<String>? referenceId,
    Expression<String>? referenceIdType,
    Expression<String>? transactingPartyId,
    Expression<String>? transactingPartyType,
    Expression<String>? quantity,
    Expression<String>? waybillNumber,
    Expression<String>? receiverId,
    Expression<String>? receiverType,
    Expression<String>? senderId,
    Expression<String>? senderType,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? transactionType,
    Expression<String>? transactionReason,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (facilityId != null) 'facility_id': facilityId,
      if (productVariantId != null) 'product_variant_id': productVariantId,
      if (referenceId != null) 'reference_id': referenceId,
      if (referenceIdType != null) 'reference_id_type': referenceIdType,
      if (transactingPartyId != null)
        'transacting_party_id': transactingPartyId,
      if (transactingPartyType != null)
        'transacting_party_type': transactingPartyType,
      if (quantity != null) 'quantity': quantity,
      if (waybillNumber != null) 'waybill_number': waybillNumber,
      if (receiverId != null) 'receiver_id': receiverId,
      if (receiverType != null) 'receiver_type': receiverType,
      if (senderId != null) 'sender_id': senderId,
      if (senderType != null) 'sender_type': senderType,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (transactionType != null) 'transaction_type': transactionType,
      if (transactionReason != null) 'transaction_reason': transactionReason,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StockCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? tenantId,
      Value<String?>? facilityId,
      Value<String?>? productVariantId,
      Value<String?>? referenceId,
      Value<String?>? referenceIdType,
      Value<String?>? transactingPartyId,
      Value<String?>? transactingPartyType,
      Value<String?>? quantity,
      Value<String?>? waybillNumber,
      Value<String?>? receiverId,
      Value<String?>? receiverType,
      Value<String?>? senderId,
      Value<String?>? senderType,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? transactionType,
      Value<String?>? transactionReason,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return StockCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      facilityId: facilityId ?? this.facilityId,
      productVariantId: productVariantId ?? this.productVariantId,
      referenceId: referenceId ?? this.referenceId,
      referenceIdType: referenceIdType ?? this.referenceIdType,
      transactingPartyId: transactingPartyId ?? this.transactingPartyId,
      transactingPartyType: transactingPartyType ?? this.transactingPartyType,
      quantity: quantity ?? this.quantity,
      waybillNumber: waybillNumber ?? this.waybillNumber,
      receiverId: receiverId ?? this.receiverId,
      receiverType: receiverType ?? this.receiverType,
      senderId: senderId ?? this.senderId,
      senderType: senderType ?? this.senderType,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      transactionType: transactionType ?? this.transactionType,
      transactionReason: transactionReason ?? this.transactionReason,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (facilityId.present) {
      map['facility_id'] = Variable<String>(facilityId.value);
    }
    if (productVariantId.present) {
      map['product_variant_id'] = Variable<String>(productVariantId.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (referenceIdType.present) {
      map['reference_id_type'] = Variable<String>(referenceIdType.value);
    }
    if (transactingPartyId.present) {
      map['transacting_party_id'] = Variable<String>(transactingPartyId.value);
    }
    if (transactingPartyType.present) {
      map['transacting_party_type'] =
          Variable<String>(transactingPartyType.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<String>(quantity.value);
    }
    if (waybillNumber.present) {
      map['waybill_number'] = Variable<String>(waybillNumber.value);
    }
    if (receiverId.present) {
      map['receiver_id'] = Variable<String>(receiverId.value);
    }
    if (receiverType.present) {
      map['receiver_type'] = Variable<String>(receiverType.value);
    }
    if (senderId.present) {
      map['sender_id'] = Variable<String>(senderId.value);
    }
    if (senderType.present) {
      map['sender_type'] = Variable<String>(senderType.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (transactionType.present) {
      map['transaction_type'] = Variable<String>(transactionType.value);
    }
    if (transactionReason.present) {
      map['transaction_reason'] = Variable<String>(transactionReason.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('facilityId: $facilityId, ')
          ..write('productVariantId: $productVariantId, ')
          ..write('referenceId: $referenceId, ')
          ..write('referenceIdType: $referenceIdType, ')
          ..write('transactingPartyId: $transactingPartyId, ')
          ..write('transactingPartyType: $transactingPartyType, ')
          ..write('quantity: $quantity, ')
          ..write('waybillNumber: $waybillNumber, ')
          ..write('receiverId: $receiverId, ')
          ..write('receiverType: $receiverType, ')
          ..write('senderId: $senderId, ')
          ..write('senderType: $senderType, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('transactionType: $transactionType, ')
          ..write('transactionReason: $transactionReason, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StockReconciliationTable extends StockReconciliation
    with TableInfo<$StockReconciliationTable, StockReconciliationData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockReconciliationTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _facilityIdMeta =
      const VerificationMeta('facilityId');
  @override
  late final GeneratedColumn<String> facilityId = GeneratedColumn<String>(
      'facility_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _productVariantIdMeta =
      const VerificationMeta('productVariantId');
  @override
  late final GeneratedColumn<String> productVariantId = GeneratedColumn<String>(
      'product_variant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdTypeMeta =
      const VerificationMeta('referenceIdType');
  @override
  late final GeneratedColumn<String> referenceIdType = GeneratedColumn<String>(
      'reference_id_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _physicalCountMeta =
      const VerificationMeta('physicalCount');
  @override
  late final GeneratedColumn<int> physicalCount = GeneratedColumn<int>(
      'physical_count', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _calculatedCountMeta =
      const VerificationMeta('calculatedCount');
  @override
  late final GeneratedColumn<int> calculatedCount = GeneratedColumn<int>(
      'calculated_count', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _commentsOnReconciliationMeta =
      const VerificationMeta('commentsOnReconciliation');
  @override
  late final GeneratedColumn<String> commentsOnReconciliation =
      GeneratedColumn<String>('comments_on_reconciliation', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _dateOfReconciliationMeta =
      const VerificationMeta('dateOfReconciliation');
  @override
  late final GeneratedColumn<int> dateOfReconciliation = GeneratedColumn<int>(
      'date_of_reconciliation', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        facilityId,
        productVariantId,
        referenceId,
        referenceIdType,
        physicalCount,
        calculatedCount,
        commentsOnReconciliation,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        dateOfReconciliation,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_reconciliation';
  @override
  VerificationContext validateIntegrity(
      Insertable<StockReconciliationData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('facility_id')) {
      context.handle(
          _facilityIdMeta,
          facilityId.isAcceptableOrUnknown(
              data['facility_id']!, _facilityIdMeta));
    }
    if (data.containsKey('product_variant_id')) {
      context.handle(
          _productVariantIdMeta,
          productVariantId.isAcceptableOrUnknown(
              data['product_variant_id']!, _productVariantIdMeta));
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    }
    if (data.containsKey('reference_id_type')) {
      context.handle(
          _referenceIdTypeMeta,
          referenceIdType.isAcceptableOrUnknown(
              data['reference_id_type']!, _referenceIdTypeMeta));
    }
    if (data.containsKey('physical_count')) {
      context.handle(
          _physicalCountMeta,
          physicalCount.isAcceptableOrUnknown(
              data['physical_count']!, _physicalCountMeta));
    }
    if (data.containsKey('calculated_count')) {
      context.handle(
          _calculatedCountMeta,
          calculatedCount.isAcceptableOrUnknown(
              data['calculated_count']!, _calculatedCountMeta));
    }
    if (data.containsKey('comments_on_reconciliation')) {
      context.handle(
          _commentsOnReconciliationMeta,
          commentsOnReconciliation.isAcceptableOrUnknown(
              data['comments_on_reconciliation']!,
              _commentsOnReconciliationMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('date_of_reconciliation')) {
      context.handle(
          _dateOfReconciliationMeta,
          dateOfReconciliation.isAcceptableOrUnknown(
              data['date_of_reconciliation']!, _dateOfReconciliationMeta));
    } else if (isInserting) {
      context.missing(_dateOfReconciliationMeta);
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  StockReconciliationData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockReconciliationData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      facilityId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}facility_id']),
      productVariantId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}product_variant_id']),
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id']),
      referenceIdType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}reference_id_type']),
      physicalCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}physical_count']),
      calculatedCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}calculated_count']),
      commentsOnReconciliation: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}comments_on_reconciliation']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      dateOfReconciliation: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}date_of_reconciliation'])!,
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $StockReconciliationTable createAlias(String alias) {
    return $StockReconciliationTable(attachedDatabase, alias);
  }
}

class StockReconciliationData extends DataClass
    implements Insertable<StockReconciliationData> {
  final String? id;
  final String? tenantId;
  final String? facilityId;
  final String? productVariantId;
  final String? referenceId;
  final String? referenceIdType;
  final int? physicalCount;
  final int? calculatedCount;
  final String? commentsOnReconciliation;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final bool? isDeleted;
  final int? rowVersion;
  final int dateOfReconciliation;
  final String? additionalFields;
  const StockReconciliationData(
      {this.id,
      this.tenantId,
      this.facilityId,
      this.productVariantId,
      this.referenceId,
      this.referenceIdType,
      this.physicalCount,
      this.calculatedCount,
      this.commentsOnReconciliation,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.isDeleted,
      this.rowVersion,
      required this.dateOfReconciliation,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || facilityId != null) {
      map['facility_id'] = Variable<String>(facilityId);
    }
    if (!nullToAbsent || productVariantId != null) {
      map['product_variant_id'] = Variable<String>(productVariantId);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    if (!nullToAbsent || referenceIdType != null) {
      map['reference_id_type'] = Variable<String>(referenceIdType);
    }
    if (!nullToAbsent || physicalCount != null) {
      map['physical_count'] = Variable<int>(physicalCount);
    }
    if (!nullToAbsent || calculatedCount != null) {
      map['calculated_count'] = Variable<int>(calculatedCount);
    }
    if (!nullToAbsent || commentsOnReconciliation != null) {
      map['comments_on_reconciliation'] =
          Variable<String>(commentsOnReconciliation);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    map['date_of_reconciliation'] = Variable<int>(dateOfReconciliation);
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  StockReconciliationCompanion toCompanion(bool nullToAbsent) {
    return StockReconciliationCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      facilityId: facilityId == null && nullToAbsent
          ? const Value.absent()
          : Value(facilityId),
      productVariantId: productVariantId == null && nullToAbsent
          ? const Value.absent()
          : Value(productVariantId),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      referenceIdType: referenceIdType == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceIdType),
      physicalCount: physicalCount == null && nullToAbsent
          ? const Value.absent()
          : Value(physicalCount),
      calculatedCount: calculatedCount == null && nullToAbsent
          ? const Value.absent()
          : Value(calculatedCount),
      commentsOnReconciliation: commentsOnReconciliation == null && nullToAbsent
          ? const Value.absent()
          : Value(commentsOnReconciliation),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      dateOfReconciliation: Value(dateOfReconciliation),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory StockReconciliationData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockReconciliationData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      facilityId: serializer.fromJson<String?>(json['facilityId']),
      productVariantId: serializer.fromJson<String?>(json['productVariantId']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      referenceIdType: serializer.fromJson<String?>(json['referenceIdType']),
      physicalCount: serializer.fromJson<int?>(json['physicalCount']),
      calculatedCount: serializer.fromJson<int?>(json['calculatedCount']),
      commentsOnReconciliation:
          serializer.fromJson<String?>(json['commentsOnReconciliation']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      dateOfReconciliation:
          serializer.fromJson<int>(json['dateOfReconciliation']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String?>(tenantId),
      'facilityId': serializer.toJson<String?>(facilityId),
      'productVariantId': serializer.toJson<String?>(productVariantId),
      'referenceId': serializer.toJson<String?>(referenceId),
      'referenceIdType': serializer.toJson<String?>(referenceIdType),
      'physicalCount': serializer.toJson<int?>(physicalCount),
      'calculatedCount': serializer.toJson<int?>(calculatedCount),
      'commentsOnReconciliation':
          serializer.toJson<String?>(commentsOnReconciliation),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'dateOfReconciliation': serializer.toJson<int>(dateOfReconciliation),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  StockReconciliationData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> facilityId = const Value.absent(),
          Value<String?> productVariantId = const Value.absent(),
          Value<String?> referenceId = const Value.absent(),
          Value<String?> referenceIdType = const Value.absent(),
          Value<int?> physicalCount = const Value.absent(),
          Value<int?> calculatedCount = const Value.absent(),
          Value<String?> commentsOnReconciliation = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          int? dateOfReconciliation,
          Value<String?> additionalFields = const Value.absent()}) =>
      StockReconciliationData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        facilityId: facilityId.present ? facilityId.value : this.facilityId,
        productVariantId: productVariantId.present
            ? productVariantId.value
            : this.productVariantId,
        referenceId: referenceId.present ? referenceId.value : this.referenceId,
        referenceIdType: referenceIdType.present
            ? referenceIdType.value
            : this.referenceIdType,
        physicalCount:
            physicalCount.present ? physicalCount.value : this.physicalCount,
        calculatedCount: calculatedCount.present
            ? calculatedCount.value
            : this.calculatedCount,
        commentsOnReconciliation: commentsOnReconciliation.present
            ? commentsOnReconciliation.value
            : this.commentsOnReconciliation,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        dateOfReconciliation: dateOfReconciliation ?? this.dateOfReconciliation,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('StockReconciliationData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('facilityId: $facilityId, ')
          ..write('productVariantId: $productVariantId, ')
          ..write('referenceId: $referenceId, ')
          ..write('referenceIdType: $referenceIdType, ')
          ..write('physicalCount: $physicalCount, ')
          ..write('calculatedCount: $calculatedCount, ')
          ..write('commentsOnReconciliation: $commentsOnReconciliation, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('dateOfReconciliation: $dateOfReconciliation, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        tenantId,
        facilityId,
        productVariantId,
        referenceId,
        referenceIdType,
        physicalCount,
        calculatedCount,
        commentsOnReconciliation,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        dateOfReconciliation,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockReconciliationData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.facilityId == this.facilityId &&
          other.productVariantId == this.productVariantId &&
          other.referenceId == this.referenceId &&
          other.referenceIdType == this.referenceIdType &&
          other.physicalCount == this.physicalCount &&
          other.calculatedCount == this.calculatedCount &&
          other.commentsOnReconciliation == this.commentsOnReconciliation &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.dateOfReconciliation == this.dateOfReconciliation &&
          other.additionalFields == this.additionalFields);
}

class StockReconciliationCompanion
    extends UpdateCompanion<StockReconciliationData> {
  final Value<String?> id;
  final Value<String?> tenantId;
  final Value<String?> facilityId;
  final Value<String?> productVariantId;
  final Value<String?> referenceId;
  final Value<String?> referenceIdType;
  final Value<int?> physicalCount;
  final Value<int?> calculatedCount;
  final Value<String?> commentsOnReconciliation;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int> dateOfReconciliation;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const StockReconciliationCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.facilityId = const Value.absent(),
    this.productVariantId = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.referenceIdType = const Value.absent(),
    this.physicalCount = const Value.absent(),
    this.calculatedCount = const Value.absent(),
    this.commentsOnReconciliation = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.dateOfReconciliation = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  StockReconciliationCompanion.insert({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.facilityId = const Value.absent(),
    this.productVariantId = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.referenceIdType = const Value.absent(),
    this.physicalCount = const Value.absent(),
    this.calculatedCount = const Value.absent(),
    this.commentsOnReconciliation = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    required int dateOfReconciliation,
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : clientReferenceId = Value(clientReferenceId),
        dateOfReconciliation = Value(dateOfReconciliation);
  static Insertable<StockReconciliationData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? facilityId,
    Expression<String>? productVariantId,
    Expression<String>? referenceId,
    Expression<String>? referenceIdType,
    Expression<int>? physicalCount,
    Expression<int>? calculatedCount,
    Expression<String>? commentsOnReconciliation,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? dateOfReconciliation,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (facilityId != null) 'facility_id': facilityId,
      if (productVariantId != null) 'product_variant_id': productVariantId,
      if (referenceId != null) 'reference_id': referenceId,
      if (referenceIdType != null) 'reference_id_type': referenceIdType,
      if (physicalCount != null) 'physical_count': physicalCount,
      if (calculatedCount != null) 'calculated_count': calculatedCount,
      if (commentsOnReconciliation != null)
        'comments_on_reconciliation': commentsOnReconciliation,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (dateOfReconciliation != null)
        'date_of_reconciliation': dateOfReconciliation,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StockReconciliationCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? tenantId,
      Value<String?>? facilityId,
      Value<String?>? productVariantId,
      Value<String?>? referenceId,
      Value<String?>? referenceIdType,
      Value<int?>? physicalCount,
      Value<int?>? calculatedCount,
      Value<String?>? commentsOnReconciliation,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int>? dateOfReconciliation,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return StockReconciliationCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      facilityId: facilityId ?? this.facilityId,
      productVariantId: productVariantId ?? this.productVariantId,
      referenceId: referenceId ?? this.referenceId,
      referenceIdType: referenceIdType ?? this.referenceIdType,
      physicalCount: physicalCount ?? this.physicalCount,
      calculatedCount: calculatedCount ?? this.calculatedCount,
      commentsOnReconciliation:
          commentsOnReconciliation ?? this.commentsOnReconciliation,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      dateOfReconciliation: dateOfReconciliation ?? this.dateOfReconciliation,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (facilityId.present) {
      map['facility_id'] = Variable<String>(facilityId.value);
    }
    if (productVariantId.present) {
      map['product_variant_id'] = Variable<String>(productVariantId.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (referenceIdType.present) {
      map['reference_id_type'] = Variable<String>(referenceIdType.value);
    }
    if (physicalCount.present) {
      map['physical_count'] = Variable<int>(physicalCount.value);
    }
    if (calculatedCount.present) {
      map['calculated_count'] = Variable<int>(calculatedCount.value);
    }
    if (commentsOnReconciliation.present) {
      map['comments_on_reconciliation'] =
          Variable<String>(commentsOnReconciliation.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (dateOfReconciliation.present) {
      map['date_of_reconciliation'] = Variable<int>(dateOfReconciliation.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockReconciliationCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('facilityId: $facilityId, ')
          ..write('productVariantId: $productVariantId, ')
          ..write('referenceId: $referenceId, ')
          ..write('referenceIdType: $referenceIdType, ')
          ..write('physicalCount: $physicalCount, ')
          ..write('calculatedCount: $calculatedCount, ')
          ..write('commentsOnReconciliation: $commentsOnReconciliation, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('dateOfReconciliation: $dateOfReconciliation, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TargetTable extends Target with TableInfo<$TargetTable, TargetData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TargetTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _totalNoMeta =
      const VerificationMeta('totalNo');
  @override
  late final GeneratedColumn<double> totalNo = GeneratedColumn<double>(
      'total_no', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _targetNoMeta =
      const VerificationMeta('targetNo');
  @override
  late final GeneratedColumn<double> targetNo = GeneratedColumn<double>(
      'target_no', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _beneficiaryTypeMeta =
      const VerificationMeta('beneficiaryType');
  @override
  late final GeneratedColumnWithTypeConverter<BeneficiaryType?, int>
      beneficiaryType = GeneratedColumn<int>(
              'beneficiary_type', aliasedName, true,
              type: DriftSqlType.int, requiredDuringInsert: false)
          .withConverter<BeneficiaryType?>(
              $TargetTable.$converterbeneficiaryTypen);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        clientReferenceId,
        totalNo,
        targetNo,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        beneficiaryType,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'target';
  @override
  VerificationContext validateIntegrity(Insertable<TargetData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    }
    if (data.containsKey('total_no')) {
      context.handle(_totalNoMeta,
          totalNo.isAcceptableOrUnknown(data['total_no']!, _totalNoMeta));
    }
    if (data.containsKey('target_no')) {
      context.handle(_targetNoMeta,
          targetNo.isAcceptableOrUnknown(data['target_no']!, _targetNoMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    context.handle(_beneficiaryTypeMeta, const VerificationResult.success());
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  TargetData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TargetData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id']),
      totalNo: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_no']),
      targetNo: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}target_no']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      beneficiaryType: $TargetTable.$converterbeneficiaryTypen.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.int, data['${effectivePrefix}beneficiary_type'])),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $TargetTable createAlias(String alias) {
    return $TargetTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<BeneficiaryType, int, int>
      $converterbeneficiaryType =
      const EnumIndexConverter<BeneficiaryType>(BeneficiaryType.values);
  static JsonTypeConverter2<BeneficiaryType?, int?, int?>
      $converterbeneficiaryTypen =
      JsonTypeConverter2.asNullable($converterbeneficiaryType);
}

class TargetData extends DataClass implements Insertable<TargetData> {
  final String id;
  final String? clientReferenceId;
  final double? totalNo;
  final double? targetNo;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final BeneficiaryType? beneficiaryType;
  final String? additionalFields;
  const TargetData(
      {required this.id,
      this.clientReferenceId,
      this.totalNo,
      this.targetNo,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.beneficiaryType,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || clientReferenceId != null) {
      map['client_reference_id'] = Variable<String>(clientReferenceId);
    }
    if (!nullToAbsent || totalNo != null) {
      map['total_no'] = Variable<double>(totalNo);
    }
    if (!nullToAbsent || targetNo != null) {
      map['target_no'] = Variable<double>(targetNo);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || beneficiaryType != null) {
      map['beneficiary_type'] = Variable<int>(
          $TargetTable.$converterbeneficiaryTypen.toSql(beneficiaryType));
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  TargetCompanion toCompanion(bool nullToAbsent) {
    return TargetCompanion(
      id: Value(id),
      clientReferenceId: clientReferenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(clientReferenceId),
      totalNo: totalNo == null && nullToAbsent
          ? const Value.absent()
          : Value(totalNo),
      targetNo: targetNo == null && nullToAbsent
          ? const Value.absent()
          : Value(targetNo),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      beneficiaryType: beneficiaryType == null && nullToAbsent
          ? const Value.absent()
          : Value(beneficiaryType),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory TargetData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TargetData(
      id: serializer.fromJson<String>(json['id']),
      clientReferenceId:
          serializer.fromJson<String?>(json['clientReferenceId']),
      totalNo: serializer.fromJson<double?>(json['totalNo']),
      targetNo: serializer.fromJson<double?>(json['targetNo']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      beneficiaryType: $TargetTable.$converterbeneficiaryTypen
          .fromJson(serializer.fromJson<int?>(json['beneficiaryType'])),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'clientReferenceId': serializer.toJson<String?>(clientReferenceId),
      'totalNo': serializer.toJson<double?>(totalNo),
      'targetNo': serializer.toJson<double?>(targetNo),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'beneficiaryType': serializer.toJson<int?>(
          $TargetTable.$converterbeneficiaryTypen.toJson(beneficiaryType)),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  TargetData copyWith(
          {String? id,
          Value<String?> clientReferenceId = const Value.absent(),
          Value<double?> totalNo = const Value.absent(),
          Value<double?> targetNo = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<BeneficiaryType?> beneficiaryType = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      TargetData(
        id: id ?? this.id,
        clientReferenceId: clientReferenceId.present
            ? clientReferenceId.value
            : this.clientReferenceId,
        totalNo: totalNo.present ? totalNo.value : this.totalNo,
        targetNo: targetNo.present ? targetNo.value : this.targetNo,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        beneficiaryType: beneficiaryType.present
            ? beneficiaryType.value
            : this.beneficiaryType,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('TargetData(')
          ..write('id: $id, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('totalNo: $totalNo, ')
          ..write('targetNo: $targetNo, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('beneficiaryType: $beneficiaryType, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      clientReferenceId,
      totalNo,
      targetNo,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      beneficiaryType,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TargetData &&
          other.id == this.id &&
          other.clientReferenceId == this.clientReferenceId &&
          other.totalNo == this.totalNo &&
          other.targetNo == this.targetNo &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.beneficiaryType == this.beneficiaryType &&
          other.additionalFields == this.additionalFields);
}

class TargetCompanion extends UpdateCompanion<TargetData> {
  final Value<String> id;
  final Value<String?> clientReferenceId;
  final Value<double?> totalNo;
  final Value<double?> targetNo;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<BeneficiaryType?> beneficiaryType;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const TargetCompanion({
    this.id = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.totalNo = const Value.absent(),
    this.targetNo = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.beneficiaryType = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TargetCompanion.insert({
    required String id,
    this.clientReferenceId = const Value.absent(),
    this.totalNo = const Value.absent(),
    this.targetNo = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.beneficiaryType = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<TargetData> custom({
    Expression<String>? id,
    Expression<String>? clientReferenceId,
    Expression<double>? totalNo,
    Expression<double>? targetNo,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? beneficiaryType,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (totalNo != null) 'total_no': totalNo,
      if (targetNo != null) 'target_no': targetNo,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (beneficiaryType != null) 'beneficiary_type': beneficiaryType,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TargetCompanion copyWith(
      {Value<String>? id,
      Value<String?>? clientReferenceId,
      Value<double?>? totalNo,
      Value<double?>? targetNo,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<BeneficiaryType?>? beneficiaryType,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return TargetCompanion(
      id: id ?? this.id,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      totalNo: totalNo ?? this.totalNo,
      targetNo: targetNo ?? this.targetNo,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      beneficiaryType: beneficiaryType ?? this.beneficiaryType,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (totalNo.present) {
      map['total_no'] = Variable<double>(totalNo.value);
    }
    if (targetNo.present) {
      map['target_no'] = Variable<double>(targetNo.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (beneficiaryType.present) {
      map['beneficiary_type'] = Variable<int>(
          $TargetTable.$converterbeneficiaryTypen.toSql(beneficiaryType.value));
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TargetCompanion(')
          ..write('id: $id, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('totalNo: $totalNo, ')
          ..write('targetNo: $targetNo, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('beneficiaryType: $beneficiaryType, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ServiceTable extends Service with TableInfo<$ServiceTable, ServiceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ServiceTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientIdMeta =
      const VerificationMeta('clientId');
  @override
  late final GeneratedColumn<String> clientId = GeneratedColumn<String>(
      'client_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _serviceDefIdMeta =
      const VerificationMeta('serviceDefId');
  @override
  late final GeneratedColumn<String> serviceDefId = GeneratedColumn<String>(
      'service_def_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'));
  static const VerificationMeta _accountIdMeta =
      const VerificationMeta('accountId');
  @override
  late final GeneratedColumn<String> accountId = GeneratedColumn<String>(
      'account_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _additionalDetailsMeta =
      const VerificationMeta('additionalDetails');
  @override
  late final GeneratedColumn<String> additionalDetails =
      GeneratedColumn<String>('additional_details', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<String> createdAt = GeneratedColumn<String>(
      'created_at', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        clientId,
        serviceDefId,
        isActive,
        accountId,
        additionalDetails,
        createdAt,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'service';
  @override
  VerificationContext validateIntegrity(Insertable<ServiceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('client_id')) {
      context.handle(_clientIdMeta,
          clientId.isAcceptableOrUnknown(data['client_id']!, _clientIdMeta));
    } else if (isInserting) {
      context.missing(_clientIdMeta);
    }
    if (data.containsKey('service_def_id')) {
      context.handle(
          _serviceDefIdMeta,
          serviceDefId.isAcceptableOrUnknown(
              data['service_def_id']!, _serviceDefIdMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('account_id')) {
      context.handle(_accountIdMeta,
          accountId.isAcceptableOrUnknown(data['account_id']!, _accountIdMeta));
    }
    if (data.containsKey('additional_details')) {
      context.handle(
          _additionalDetailsMeta,
          additionalDetails.isAcceptableOrUnknown(
              data['additional_details']!, _additionalDetailsMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {clientId, auditCreatedBy};
  @override
  ServiceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ServiceData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      clientId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}client_id'])!,
      serviceDefId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}service_def_id']),
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active']),
      accountId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}account_id']),
      additionalDetails: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_details']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_at']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ServiceTable createAlias(String alias) {
    return $ServiceTable(attachedDatabase, alias);
  }
}

class ServiceData extends DataClass implements Insertable<ServiceData> {
  final String? id;
  final String clientId;
  final String? serviceDefId;
  final bool? isActive;
  final String? accountId;
  final String? additionalDetails;
  final String? createdAt;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ServiceData(
      {this.id,
      required this.clientId,
      this.serviceDefId,
      this.isActive,
      this.accountId,
      this.additionalDetails,
      this.createdAt,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    map['client_id'] = Variable<String>(clientId);
    if (!nullToAbsent || serviceDefId != null) {
      map['service_def_id'] = Variable<String>(serviceDefId);
    }
    if (!nullToAbsent || isActive != null) {
      map['is_active'] = Variable<bool>(isActive);
    }
    if (!nullToAbsent || accountId != null) {
      map['account_id'] = Variable<String>(accountId);
    }
    if (!nullToAbsent || additionalDetails != null) {
      map['additional_details'] = Variable<String>(additionalDetails);
    }
    if (!nullToAbsent || createdAt != null) {
      map['created_at'] = Variable<String>(createdAt);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ServiceCompanion toCompanion(bool nullToAbsent) {
    return ServiceCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      clientId: Value(clientId),
      serviceDefId: serviceDefId == null && nullToAbsent
          ? const Value.absent()
          : Value(serviceDefId),
      isActive: isActive == null && nullToAbsent
          ? const Value.absent()
          : Value(isActive),
      accountId: accountId == null && nullToAbsent
          ? const Value.absent()
          : Value(accountId),
      additionalDetails: additionalDetails == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalDetails),
      createdAt: createdAt == null && nullToAbsent
          ? const Value.absent()
          : Value(createdAt),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ServiceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ServiceData(
      id: serializer.fromJson<String?>(json['id']),
      clientId: serializer.fromJson<String>(json['clientId']),
      serviceDefId: serializer.fromJson<String?>(json['serviceDefId']),
      isActive: serializer.fromJson<bool?>(json['isActive']),
      accountId: serializer.fromJson<String?>(json['accountId']),
      additionalDetails:
          serializer.fromJson<String?>(json['additionalDetails']),
      createdAt: serializer.fromJson<String?>(json['createdAt']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'clientId': serializer.toJson<String>(clientId),
      'serviceDefId': serializer.toJson<String?>(serviceDefId),
      'isActive': serializer.toJson<bool?>(isActive),
      'accountId': serializer.toJson<String?>(accountId),
      'additionalDetails': serializer.toJson<String?>(additionalDetails),
      'createdAt': serializer.toJson<String?>(createdAt),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ServiceData copyWith(
          {Value<String?> id = const Value.absent(),
          String? clientId,
          Value<String?> serviceDefId = const Value.absent(),
          Value<bool?> isActive = const Value.absent(),
          Value<String?> accountId = const Value.absent(),
          Value<String?> additionalDetails = const Value.absent(),
          Value<String?> createdAt = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ServiceData(
        id: id.present ? id.value : this.id,
        clientId: clientId ?? this.clientId,
        serviceDefId:
            serviceDefId.present ? serviceDefId.value : this.serviceDefId,
        isActive: isActive.present ? isActive.value : this.isActive,
        accountId: accountId.present ? accountId.value : this.accountId,
        additionalDetails: additionalDetails.present
            ? additionalDetails.value
            : this.additionalDetails,
        createdAt: createdAt.present ? createdAt.value : this.createdAt,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ServiceData(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('serviceDefId: $serviceDefId, ')
          ..write('isActive: $isActive, ')
          ..write('accountId: $accountId, ')
          ..write('additionalDetails: $additionalDetails, ')
          ..write('createdAt: $createdAt, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      clientId,
      serviceDefId,
      isActive,
      accountId,
      additionalDetails,
      createdAt,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ServiceData &&
          other.id == this.id &&
          other.clientId == this.clientId &&
          other.serviceDefId == this.serviceDefId &&
          other.isActive == this.isActive &&
          other.accountId == this.accountId &&
          other.additionalDetails == this.additionalDetails &&
          other.createdAt == this.createdAt &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ServiceCompanion extends UpdateCompanion<ServiceData> {
  final Value<String?> id;
  final Value<String> clientId;
  final Value<String?> serviceDefId;
  final Value<bool?> isActive;
  final Value<String?> accountId;
  final Value<String?> additionalDetails;
  final Value<String?> createdAt;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ServiceCompanion({
    this.id = const Value.absent(),
    this.clientId = const Value.absent(),
    this.serviceDefId = const Value.absent(),
    this.isActive = const Value.absent(),
    this.accountId = const Value.absent(),
    this.additionalDetails = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ServiceCompanion.insert({
    this.id = const Value.absent(),
    required String clientId,
    this.serviceDefId = const Value.absent(),
    this.isActive = const Value.absent(),
    this.accountId = const Value.absent(),
    this.additionalDetails = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientId = Value(clientId);
  static Insertable<ServiceData> custom({
    Expression<String>? id,
    Expression<String>? clientId,
    Expression<String>? serviceDefId,
    Expression<bool>? isActive,
    Expression<String>? accountId,
    Expression<String>? additionalDetails,
    Expression<String>? createdAt,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientId != null) 'client_id': clientId,
      if (serviceDefId != null) 'service_def_id': serviceDefId,
      if (isActive != null) 'is_active': isActive,
      if (accountId != null) 'account_id': accountId,
      if (additionalDetails != null) 'additional_details': additionalDetails,
      if (createdAt != null) 'created_at': createdAt,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ServiceCompanion copyWith(
      {Value<String?>? id,
      Value<String>? clientId,
      Value<String?>? serviceDefId,
      Value<bool?>? isActive,
      Value<String?>? accountId,
      Value<String?>? additionalDetails,
      Value<String?>? createdAt,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ServiceCompanion(
      id: id ?? this.id,
      clientId: clientId ?? this.clientId,
      serviceDefId: serviceDefId ?? this.serviceDefId,
      isActive: isActive ?? this.isActive,
      accountId: accountId ?? this.accountId,
      additionalDetails: additionalDetails ?? this.additionalDetails,
      createdAt: createdAt ?? this.createdAt,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (clientId.present) {
      map['client_id'] = Variable<String>(clientId.value);
    }
    if (serviceDefId.present) {
      map['service_def_id'] = Variable<String>(serviceDefId.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (accountId.present) {
      map['account_id'] = Variable<String>(accountId.value);
    }
    if (additionalDetails.present) {
      map['additional_details'] = Variable<String>(additionalDetails.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<String>(createdAt.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ServiceCompanion(')
          ..write('id: $id, ')
          ..write('clientId: $clientId, ')
          ..write('serviceDefId: $serviceDefId, ')
          ..write('isActive: $isActive, ')
          ..write('accountId: $accountId, ')
          ..write('additionalDetails: $additionalDetails, ')
          ..write('createdAt: $createdAt, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ServiceAttributesTable extends ServiceAttributes
    with TableInfo<$ServiceAttributesTable, ServiceAttribute> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ServiceAttributesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _attributeCodeMeta =
      const VerificationMeta('attributeCode');
  @override
  late final GeneratedColumn<String> attributeCode = GeneratedColumn<String>(
      'attribute_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
      'value', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _dataTypeMeta =
      const VerificationMeta('dataType');
  @override
  late final GeneratedColumn<String> dataType = GeneratedColumn<String>(
      'data_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _additionalDetailsMeta =
      const VerificationMeta('additionalDetails');
  @override
  late final GeneratedColumn<String> additionalDetails =
      GeneratedColumn<String>('additional_details', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        attributeCode,
        value,
        dataType,
        referenceId,
        additionalDetails,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'service_attributes';
  @override
  VerificationContext validateIntegrity(Insertable<ServiceAttribute> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('attribute_code')) {
      context.handle(
          _attributeCodeMeta,
          attributeCode.isAcceptableOrUnknown(
              data['attribute_code']!, _attributeCodeMeta));
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value']!, _valueMeta));
    }
    if (data.containsKey('data_type')) {
      context.handle(_dataTypeMeta,
          dataType.isAcceptableOrUnknown(data['data_type']!, _dataTypeMeta));
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    }
    if (data.containsKey('additional_details')) {
      context.handle(
          _additionalDetailsMeta,
          additionalDetails.isAcceptableOrUnknown(
              data['additional_details']!, _additionalDetailsMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  ServiceAttribute map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ServiceAttribute(
      attributeCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}attribute_code']),
      value: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}value']),
      dataType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_type']),
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id']),
      additionalDetails: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_details']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ServiceAttributesTable createAlias(String alias) {
    return $ServiceAttributesTable(attachedDatabase, alias);
  }
}

class ServiceAttribute extends DataClass
    implements Insertable<ServiceAttribute> {
  final String? attributeCode;
  final String? value;
  final String? dataType;
  final String? referenceId;
  final String? additionalDetails;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ServiceAttribute(
      {this.attributeCode,
      this.value,
      this.dataType,
      this.referenceId,
      this.additionalDetails,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || attributeCode != null) {
      map['attribute_code'] = Variable<String>(attributeCode);
    }
    if (!nullToAbsent || value != null) {
      map['value'] = Variable<String>(value);
    }
    if (!nullToAbsent || dataType != null) {
      map['data_type'] = Variable<String>(dataType);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    if (!nullToAbsent || additionalDetails != null) {
      map['additional_details'] = Variable<String>(additionalDetails);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ServiceAttributesCompanion toCompanion(bool nullToAbsent) {
    return ServiceAttributesCompanion(
      attributeCode: attributeCode == null && nullToAbsent
          ? const Value.absent()
          : Value(attributeCode),
      value:
          value == null && nullToAbsent ? const Value.absent() : Value(value),
      dataType: dataType == null && nullToAbsent
          ? const Value.absent()
          : Value(dataType),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      additionalDetails: additionalDetails == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalDetails),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ServiceAttribute.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ServiceAttribute(
      attributeCode: serializer.fromJson<String?>(json['attributeCode']),
      value: serializer.fromJson<String?>(json['value']),
      dataType: serializer.fromJson<String?>(json['dataType']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      additionalDetails:
          serializer.fromJson<String?>(json['additionalDetails']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'attributeCode': serializer.toJson<String?>(attributeCode),
      'value': serializer.toJson<String?>(value),
      'dataType': serializer.toJson<String?>(dataType),
      'referenceId': serializer.toJson<String?>(referenceId),
      'additionalDetails': serializer.toJson<String?>(additionalDetails),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ServiceAttribute copyWith(
          {Value<String?> attributeCode = const Value.absent(),
          Value<String?> value = const Value.absent(),
          Value<String?> dataType = const Value.absent(),
          Value<String?> referenceId = const Value.absent(),
          Value<String?> additionalDetails = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ServiceAttribute(
        attributeCode:
            attributeCode.present ? attributeCode.value : this.attributeCode,
        value: value.present ? value.value : this.value,
        dataType: dataType.present ? dataType.value : this.dataType,
        referenceId: referenceId.present ? referenceId.value : this.referenceId,
        additionalDetails: additionalDetails.present
            ? additionalDetails.value
            : this.additionalDetails,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ServiceAttribute(')
          ..write('attributeCode: $attributeCode, ')
          ..write('value: $value, ')
          ..write('dataType: $dataType, ')
          ..write('referenceId: $referenceId, ')
          ..write('additionalDetails: $additionalDetails, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      attributeCode,
      value,
      dataType,
      referenceId,
      additionalDetails,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ServiceAttribute &&
          other.attributeCode == this.attributeCode &&
          other.value == this.value &&
          other.dataType == this.dataType &&
          other.referenceId == this.referenceId &&
          other.additionalDetails == this.additionalDetails &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ServiceAttributesCompanion extends UpdateCompanion<ServiceAttribute> {
  final Value<String?> attributeCode;
  final Value<String?> value;
  final Value<String?> dataType;
  final Value<String?> referenceId;
  final Value<String?> additionalDetails;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ServiceAttributesCompanion({
    this.attributeCode = const Value.absent(),
    this.value = const Value.absent(),
    this.dataType = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.additionalDetails = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ServiceAttributesCompanion.insert({
    this.attributeCode = const Value.absent(),
    this.value = const Value.absent(),
    this.dataType = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.additionalDetails = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<ServiceAttribute> custom({
    Expression<String>? attributeCode,
    Expression<String>? value,
    Expression<String>? dataType,
    Expression<String>? referenceId,
    Expression<String>? additionalDetails,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (attributeCode != null) 'attribute_code': attributeCode,
      if (value != null) 'value': value,
      if (dataType != null) 'data_type': dataType,
      if (referenceId != null) 'reference_id': referenceId,
      if (additionalDetails != null) 'additional_details': additionalDetails,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ServiceAttributesCompanion copyWith(
      {Value<String?>? attributeCode,
      Value<String?>? value,
      Value<String?>? dataType,
      Value<String?>? referenceId,
      Value<String?>? additionalDetails,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ServiceAttributesCompanion(
      attributeCode: attributeCode ?? this.attributeCode,
      value: value ?? this.value,
      dataType: dataType ?? this.dataType,
      referenceId: referenceId ?? this.referenceId,
      additionalDetails: additionalDetails ?? this.additionalDetails,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (attributeCode.present) {
      map['attribute_code'] = Variable<String>(attributeCode.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (dataType.present) {
      map['data_type'] = Variable<String>(dataType.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (additionalDetails.present) {
      map['additional_details'] = Variable<String>(additionalDetails.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ServiceAttributesCompanion(')
          ..write('attributeCode: $attributeCode, ')
          ..write('value: $value, ')
          ..write('dataType: $dataType, ')
          ..write('referenceId: $referenceId, ')
          ..write('additionalDetails: $additionalDetails, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ServiceDefinitionTable extends ServiceDefinition
    with TableInfo<$ServiceDefinitionTable, ServiceDefinitionData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ServiceDefinitionTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'));
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        code,
        isActive,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'service_definition';
  @override
  VerificationContext validateIntegrity(
      Insertable<ServiceDefinitionData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  ServiceDefinitionData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ServiceDefinitionData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ServiceDefinitionTable createAlias(String alias) {
    return $ServiceDefinitionTable(attachedDatabase, alias);
  }
}

class ServiceDefinitionData extends DataClass
    implements Insertable<ServiceDefinitionData> {
  final String? id;
  final String? tenantId;
  final String? code;
  final bool? isActive;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ServiceDefinitionData(
      {this.id,
      this.tenantId,
      this.code,
      this.isActive,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || isActive != null) {
      map['is_active'] = Variable<bool>(isActive);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ServiceDefinitionCompanion toCompanion(bool nullToAbsent) {
    return ServiceDefinitionCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      isActive: isActive == null && nullToAbsent
          ? const Value.absent()
          : Value(isActive),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ServiceDefinitionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ServiceDefinitionData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      code: serializer.fromJson<String?>(json['code']),
      isActive: serializer.fromJson<bool?>(json['isActive']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String?>(tenantId),
      'code': serializer.toJson<String?>(code),
      'isActive': serializer.toJson<bool?>(isActive),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ServiceDefinitionData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> code = const Value.absent(),
          Value<bool?> isActive = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ServiceDefinitionData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        code: code.present ? code.value : this.code,
        isActive: isActive.present ? isActive.value : this.isActive,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ServiceDefinitionData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('code: $code, ')
          ..write('isActive: $isActive, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      tenantId,
      code,
      isActive,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ServiceDefinitionData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.code == this.code &&
          other.isActive == this.isActive &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ServiceDefinitionCompanion
    extends UpdateCompanion<ServiceDefinitionData> {
  final Value<String?> id;
  final Value<String?> tenantId;
  final Value<String?> code;
  final Value<bool?> isActive;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ServiceDefinitionCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.code = const Value.absent(),
    this.isActive = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ServiceDefinitionCompanion.insert({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.code = const Value.absent(),
    this.isActive = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<ServiceDefinitionData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? code,
    Expression<bool>? isActive,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (code != null) 'code': code,
      if (isActive != null) 'is_active': isActive,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ServiceDefinitionCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? tenantId,
      Value<String?>? code,
      Value<bool?>? isActive,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ServiceDefinitionCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      code: code ?? this.code,
      isActive: isActive ?? this.isActive,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ServiceDefinitionCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('code: $code, ')
          ..write('isActive: $isActive, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LocalityTable extends Locality
    with TableInfo<$LocalityTable, LocalityData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LocalityTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        code,
        name,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'locality';
  @override
  VerificationContext validateIntegrity(Insertable<LocalityData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code, auditCreatedBy};
  @override
  LocalityData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LocalityData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $LocalityTable createAlias(String alias) {
    return $LocalityTable(attachedDatabase, alias);
  }
}

class LocalityData extends DataClass implements Insertable<LocalityData> {
  final String code;
  final String? name;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const LocalityData(
      {required this.code,
      this.name,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['code'] = Variable<String>(code);
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  LocalityCompanion toCompanion(bool nullToAbsent) {
    return LocalityCompanion(
      code: Value(code),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory LocalityData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LocalityData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String?>(json['name']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String?>(name),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  LocalityData copyWith(
          {String? code,
          Value<String?> name = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      LocalityData(
        code: code ?? this.code,
        name: name.present ? name.value : this.name,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('LocalityData(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      code,
      name,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LocalityData &&
          other.code == this.code &&
          other.name == this.name &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class LocalityCompanion extends UpdateCompanion<LocalityData> {
  final Value<String> code;
  final Value<String?> name;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const LocalityCompanion({
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  LocalityCompanion.insert({
    required String code,
    this.name = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : code = Value(code);
  static Insertable<LocalityData> custom({
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LocalityCompanion copyWith(
      {Value<String>? code,
      Value<String?>? name,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return LocalityCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LocalityCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StaffTable extends Staff with TableInfo<$StaffTable, StaffData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StaffTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _registerIdMeta =
      const VerificationMeta('registerId');
  @override
  late final GeneratedColumn<String> registerId = GeneratedColumn<String>(
      'register_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
      'user_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _enrollmentDateMeta =
      const VerificationMeta('enrollmentDate');
  @override
  late final GeneratedColumn<int> enrollmentDate = GeneratedColumn<int>(
      'enrollment_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _denrollmentDateMeta =
      const VerificationMeta('denrollmentDate');
  @override
  late final GeneratedColumn<int> denrollmentDate = GeneratedColumn<int>(
      'denrollment_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [id, tenantId, registerId, userId, enrollmentDate, denrollmentDate];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'staff';
  @override
  VerificationContext validateIntegrity(Insertable<StaffData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('register_id')) {
      context.handle(
          _registerIdMeta,
          registerId.isAcceptableOrUnknown(
              data['register_id']!, _registerIdMeta));
    } else if (isInserting) {
      context.missing(_registerIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('enrollment_date')) {
      context.handle(
          _enrollmentDateMeta,
          enrollmentDate.isAcceptableOrUnknown(
              data['enrollment_date']!, _enrollmentDateMeta));
    }
    if (data.containsKey('denrollment_date')) {
      context.handle(
          _denrollmentDateMeta,
          denrollmentDate.isAcceptableOrUnknown(
              data['denrollment_date']!, _denrollmentDateMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, registerId};
  @override
  StaffData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StaffData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      registerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}register_id'])!,
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_id'])!,
      enrollmentDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}enrollment_date']),
      denrollmentDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}denrollment_date']),
    );
  }

  @override
  $StaffTable createAlias(String alias) {
    return $StaffTable(attachedDatabase, alias);
  }
}

class StaffData extends DataClass implements Insertable<StaffData> {
  final String? id;
  final String tenantId;
  final String registerId;
  final String userId;
  final int? enrollmentDate;
  final int? denrollmentDate;
  const StaffData(
      {this.id,
      required this.tenantId,
      required this.registerId,
      required this.userId,
      this.enrollmentDate,
      this.denrollmentDate});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    map['tenant_id'] = Variable<String>(tenantId);
    map['register_id'] = Variable<String>(registerId);
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || enrollmentDate != null) {
      map['enrollment_date'] = Variable<int>(enrollmentDate);
    }
    if (!nullToAbsent || denrollmentDate != null) {
      map['denrollment_date'] = Variable<int>(denrollmentDate);
    }
    return map;
  }

  StaffCompanion toCompanion(bool nullToAbsent) {
    return StaffCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: Value(tenantId),
      registerId: Value(registerId),
      userId: Value(userId),
      enrollmentDate: enrollmentDate == null && nullToAbsent
          ? const Value.absent()
          : Value(enrollmentDate),
      denrollmentDate: denrollmentDate == null && nullToAbsent
          ? const Value.absent()
          : Value(denrollmentDate),
    );
  }

  factory StaffData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StaffData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String>(json['tenantId']),
      registerId: serializer.fromJson<String>(json['registerId']),
      userId: serializer.fromJson<String>(json['userId']),
      enrollmentDate: serializer.fromJson<int?>(json['enrollmentDate']),
      denrollmentDate: serializer.fromJson<int?>(json['denrollmentDate']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String>(tenantId),
      'registerId': serializer.toJson<String>(registerId),
      'userId': serializer.toJson<String>(userId),
      'enrollmentDate': serializer.toJson<int?>(enrollmentDate),
      'denrollmentDate': serializer.toJson<int?>(denrollmentDate),
    };
  }

  StaffData copyWith(
          {Value<String?> id = const Value.absent(),
          String? tenantId,
          String? registerId,
          String? userId,
          Value<int?> enrollmentDate = const Value.absent(),
          Value<int?> denrollmentDate = const Value.absent()}) =>
      StaffData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId ?? this.tenantId,
        registerId: registerId ?? this.registerId,
        userId: userId ?? this.userId,
        enrollmentDate:
            enrollmentDate.present ? enrollmentDate.value : this.enrollmentDate,
        denrollmentDate: denrollmentDate.present
            ? denrollmentDate.value
            : this.denrollmentDate,
      );
  @override
  String toString() {
    return (StringBuffer('StaffData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerId: $registerId, ')
          ..write('userId: $userId, ')
          ..write('enrollmentDate: $enrollmentDate, ')
          ..write('denrollmentDate: $denrollmentDate')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, tenantId, registerId, userId, enrollmentDate, denrollmentDate);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StaffData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.registerId == this.registerId &&
          other.userId == this.userId &&
          other.enrollmentDate == this.enrollmentDate &&
          other.denrollmentDate == this.denrollmentDate);
}

class StaffCompanion extends UpdateCompanion<StaffData> {
  final Value<String?> id;
  final Value<String> tenantId;
  final Value<String> registerId;
  final Value<String> userId;
  final Value<int?> enrollmentDate;
  final Value<int?> denrollmentDate;
  final Value<int> rowid;
  const StaffCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.registerId = const Value.absent(),
    this.userId = const Value.absent(),
    this.enrollmentDate = const Value.absent(),
    this.denrollmentDate = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  StaffCompanion.insert({
    this.id = const Value.absent(),
    required String tenantId,
    required String registerId,
    required String userId,
    this.enrollmentDate = const Value.absent(),
    this.denrollmentDate = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : tenantId = Value(tenantId),
        registerId = Value(registerId),
        userId = Value(userId);
  static Insertable<StaffData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? registerId,
    Expression<String>? userId,
    Expression<int>? enrollmentDate,
    Expression<int>? denrollmentDate,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (registerId != null) 'register_id': registerId,
      if (userId != null) 'user_id': userId,
      if (enrollmentDate != null) 'enrollment_date': enrollmentDate,
      if (denrollmentDate != null) 'denrollment_date': denrollmentDate,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StaffCompanion copyWith(
      {Value<String?>? id,
      Value<String>? tenantId,
      Value<String>? registerId,
      Value<String>? userId,
      Value<int?>? enrollmentDate,
      Value<int?>? denrollmentDate,
      Value<int>? rowid}) {
    return StaffCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      registerId: registerId ?? this.registerId,
      userId: userId ?? this.userId,
      enrollmentDate: enrollmentDate ?? this.enrollmentDate,
      denrollmentDate: denrollmentDate ?? this.denrollmentDate,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (registerId.present) {
      map['register_id'] = Variable<String>(registerId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (enrollmentDate.present) {
      map['enrollment_date'] = Variable<int>(enrollmentDate.value);
    }
    if (denrollmentDate.present) {
      map['denrollment_date'] = Variable<int>(denrollmentDate.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StaffCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('registerId: $registerId, ')
          ..write('userId: $userId, ')
          ..write('enrollmentDate: $enrollmentDate, ')
          ..write('denrollmentDate: $denrollmentDate, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AttributesTable extends Attributes
    with TableInfo<$AttributesTable, Attribute> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AttributesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _dataTypeMeta =
      const VerificationMeta('dataType');
  @override
  late final GeneratedColumn<String> dataType = GeneratedColumn<String>(
      'data_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _valuesMeta = const VerificationMeta('values');
  @override
  late final GeneratedColumn<String> values = GeneratedColumn<String>(
      'values', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<String> isActive = GeneratedColumn<String>(
      'is_active', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _requiredMeta =
      const VerificationMeta('required');
  @override
  late final GeneratedColumn<bool> required = GeneratedColumn<bool>(
      'required', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("required" IN (0, 1))'));
  static const VerificationMeta _regexMeta = const VerificationMeta('regex');
  @override
  late final GeneratedColumn<String> regex = GeneratedColumn<String>(
      'regex', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _orderMeta = const VerificationMeta('order');
  @override
  late final GeneratedColumn<int> order = GeneratedColumn<int>(
      'order', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        dataType,
        referenceId,
        tenantId,
        code,
        values,
        isActive,
        required,
        regex,
        order,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'attributes';
  @override
  VerificationContext validateIntegrity(Insertable<Attribute> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('data_type')) {
      context.handle(_dataTypeMeta,
          dataType.isAcceptableOrUnknown(data['data_type']!, _dataTypeMeta));
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    }
    if (data.containsKey('values')) {
      context.handle(_valuesMeta,
          values.isAcceptableOrUnknown(data['values']!, _valuesMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('required')) {
      context.handle(_requiredMeta,
          required.isAcceptableOrUnknown(data['required']!, _requiredMeta));
    }
    if (data.containsKey('regex')) {
      context.handle(
          _regexMeta, regex.isAcceptableOrUnknown(data['regex']!, _regexMeta));
    }
    if (data.containsKey('order')) {
      context.handle(
          _orderMeta, order.isAcceptableOrUnknown(data['order']!, _orderMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id, auditCreatedBy};
  @override
  Attribute map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Attribute(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      dataType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_type']),
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code']),
      values: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}values']),
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}is_active']),
      required: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}required']),
      regex: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}regex']),
      order: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}order']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $AttributesTable createAlias(String alias) {
    return $AttributesTable(attachedDatabase, alias);
  }
}

class Attribute extends DataClass implements Insertable<Attribute> {
  final String? id;
  final String? dataType;
  final String? referenceId;
  final String? tenantId;
  final String? code;
  final String? values;
  final String? isActive;
  final bool? required;
  final String? regex;
  final int? order;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const Attribute(
      {this.id,
      this.dataType,
      this.referenceId,
      this.tenantId,
      this.code,
      this.values,
      this.isActive,
      this.required,
      this.regex,
      this.order,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || dataType != null) {
      map['data_type'] = Variable<String>(dataType);
    }
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || values != null) {
      map['values'] = Variable<String>(values);
    }
    if (!nullToAbsent || isActive != null) {
      map['is_active'] = Variable<String>(isActive);
    }
    if (!nullToAbsent || required != null) {
      map['required'] = Variable<bool>(required);
    }
    if (!nullToAbsent || regex != null) {
      map['regex'] = Variable<String>(regex);
    }
    if (!nullToAbsent || order != null) {
      map['order'] = Variable<int>(order);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  AttributesCompanion toCompanion(bool nullToAbsent) {
    return AttributesCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      dataType: dataType == null && nullToAbsent
          ? const Value.absent()
          : Value(dataType),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      values:
          values == null && nullToAbsent ? const Value.absent() : Value(values),
      isActive: isActive == null && nullToAbsent
          ? const Value.absent()
          : Value(isActive),
      required: required == null && nullToAbsent
          ? const Value.absent()
          : Value(required),
      regex:
          regex == null && nullToAbsent ? const Value.absent() : Value(regex),
      order:
          order == null && nullToAbsent ? const Value.absent() : Value(order),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory Attribute.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Attribute(
      id: serializer.fromJson<String?>(json['id']),
      dataType: serializer.fromJson<String?>(json['dataType']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      code: serializer.fromJson<String?>(json['code']),
      values: serializer.fromJson<String?>(json['values']),
      isActive: serializer.fromJson<String?>(json['isActive']),
      required: serializer.fromJson<bool?>(json['required']),
      regex: serializer.fromJson<String?>(json['regex']),
      order: serializer.fromJson<int?>(json['order']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'dataType': serializer.toJson<String?>(dataType),
      'referenceId': serializer.toJson<String?>(referenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'code': serializer.toJson<String?>(code),
      'values': serializer.toJson<String?>(values),
      'isActive': serializer.toJson<String?>(isActive),
      'required': serializer.toJson<bool?>(required),
      'regex': serializer.toJson<String?>(regex),
      'order': serializer.toJson<int?>(order),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  Attribute copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> dataType = const Value.absent(),
          Value<String?> referenceId = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> code = const Value.absent(),
          Value<String?> values = const Value.absent(),
          Value<String?> isActive = const Value.absent(),
          Value<bool?> required = const Value.absent(),
          Value<String?> regex = const Value.absent(),
          Value<int?> order = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      Attribute(
        id: id.present ? id.value : this.id,
        dataType: dataType.present ? dataType.value : this.dataType,
        referenceId: referenceId.present ? referenceId.value : this.referenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        code: code.present ? code.value : this.code,
        values: values.present ? values.value : this.values,
        isActive: isActive.present ? isActive.value : this.isActive,
        required: required.present ? required.value : this.required,
        regex: regex.present ? regex.value : this.regex,
        order: order.present ? order.value : this.order,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('Attribute(')
          ..write('id: $id, ')
          ..write('dataType: $dataType, ')
          ..write('referenceId: $referenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('code: $code, ')
          ..write('values: $values, ')
          ..write('isActive: $isActive, ')
          ..write('required: $required, ')
          ..write('regex: $regex, ')
          ..write('order: $order, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        dataType,
        referenceId,
        tenantId,
        code,
        values,
        isActive,
        required,
        regex,
        order,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Attribute &&
          other.id == this.id &&
          other.dataType == this.dataType &&
          other.referenceId == this.referenceId &&
          other.tenantId == this.tenantId &&
          other.code == this.code &&
          other.values == this.values &&
          other.isActive == this.isActive &&
          other.required == this.required &&
          other.regex == this.regex &&
          other.order == this.order &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class AttributesCompanion extends UpdateCompanion<Attribute> {
  final Value<String?> id;
  final Value<String?> dataType;
  final Value<String?> referenceId;
  final Value<String?> tenantId;
  final Value<String?> code;
  final Value<String?> values;
  final Value<String?> isActive;
  final Value<bool?> required;
  final Value<String?> regex;
  final Value<int?> order;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const AttributesCompanion({
    this.id = const Value.absent(),
    this.dataType = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.code = const Value.absent(),
    this.values = const Value.absent(),
    this.isActive = const Value.absent(),
    this.required = const Value.absent(),
    this.regex = const Value.absent(),
    this.order = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AttributesCompanion.insert({
    this.id = const Value.absent(),
    this.dataType = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.code = const Value.absent(),
    this.values = const Value.absent(),
    this.isActive = const Value.absent(),
    this.required = const Value.absent(),
    this.regex = const Value.absent(),
    this.order = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<Attribute> custom({
    Expression<String>? id,
    Expression<String>? dataType,
    Expression<String>? referenceId,
    Expression<String>? tenantId,
    Expression<String>? code,
    Expression<String>? values,
    Expression<String>? isActive,
    Expression<bool>? required,
    Expression<String>? regex,
    Expression<int>? order,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (dataType != null) 'data_type': dataType,
      if (referenceId != null) 'reference_id': referenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (code != null) 'code': code,
      if (values != null) 'values': values,
      if (isActive != null) 'is_active': isActive,
      if (required != null) 'required': required,
      if (regex != null) 'regex': regex,
      if (order != null) 'order': order,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AttributesCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? dataType,
      Value<String?>? referenceId,
      Value<String?>? tenantId,
      Value<String?>? code,
      Value<String?>? values,
      Value<String?>? isActive,
      Value<bool?>? required,
      Value<String?>? regex,
      Value<int?>? order,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return AttributesCompanion(
      id: id ?? this.id,
      dataType: dataType ?? this.dataType,
      referenceId: referenceId ?? this.referenceId,
      tenantId: tenantId ?? this.tenantId,
      code: code ?? this.code,
      values: values ?? this.values,
      isActive: isActive ?? this.isActive,
      required: required ?? this.required,
      regex: regex ?? this.regex,
      order: order ?? this.order,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (dataType.present) {
      map['data_type'] = Variable<String>(dataType.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (values.present) {
      map['values'] = Variable<String>(values.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<String>(isActive.value);
    }
    if (required.present) {
      map['required'] = Variable<bool>(required.value);
    }
    if (regex.present) {
      map['regex'] = Variable<String>(regex.value);
    }
    if (order.present) {
      map['order'] = Variable<int>(order.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AttributesCompanion(')
          ..write('id: $id, ')
          ..write('dataType: $dataType, ')
          ..write('referenceId: $referenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('code: $code, ')
          ..write('values: $values, ')
          ..write('isActive: $isActive, ')
          ..write('required: $required, ')
          ..write('regex: $regex, ')
          ..write('order: $order, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PgrServiceTable extends PgrService
    with TableInfo<$PgrServiceTable, PgrServiceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PgrServiceTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _activeMeta = const VerificationMeta('active');
  @override
  late final GeneratedColumn<bool> active = GeneratedColumn<bool>(
      'active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("active" IN (0, 1))'));
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _serviceCodeMeta =
      const VerificationMeta('serviceCode');
  @override
  late final GeneratedColumn<String> serviceCode = GeneratedColumn<String>(
      'service_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _serviceRequestIdMeta =
      const VerificationMeta('serviceRequestId');
  @override
  late final GeneratedColumn<String> serviceRequestId = GeneratedColumn<String>(
      'service_request_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _accountIdMeta =
      const VerificationMeta('accountId');
  @override
  late final GeneratedColumn<String> accountId = GeneratedColumn<String>(
      'account_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _applicationStatusMeta =
      const VerificationMeta('applicationStatus');
  @override
  late final GeneratedColumnWithTypeConverter<PgrServiceApplicationStatus, int>
      applicationStatus = GeneratedColumn<int>(
              'application_status', aliasedName, false,
              type: DriftSqlType.int, requiredDuringInsert: true)
          .withConverter<PgrServiceApplicationStatus>(
              $PgrServiceTable.$converterapplicationStatus);
  static const VerificationMeta _sourceMeta = const VerificationMeta('source');
  @override
  late final GeneratedColumn<String> source = GeneratedColumn<String>(
      'source', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        active,
        clientReferenceId,
        id,
        tenantId,
        serviceCode,
        description,
        serviceRequestId,
        accountId,
        applicationStatus,
        source,
        auditCreatedBy,
        auditCreatedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pgr_service';
  @override
  VerificationContext validateIntegrity(Insertable<PgrServiceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('active')) {
      context.handle(_activeMeta,
          active.isAcceptableOrUnknown(data['active']!, _activeMeta));
    } else if (isInserting) {
      context.missing(_activeMeta);
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('service_code')) {
      context.handle(
          _serviceCodeMeta,
          serviceCode.isAcceptableOrUnknown(
              data['service_code']!, _serviceCodeMeta));
    } else if (isInserting) {
      context.missing(_serviceCodeMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    } else if (isInserting) {
      context.missing(_descriptionMeta);
    }
    if (data.containsKey('service_request_id')) {
      context.handle(
          _serviceRequestIdMeta,
          serviceRequestId.isAcceptableOrUnknown(
              data['service_request_id']!, _serviceRequestIdMeta));
    }
    if (data.containsKey('account_id')) {
      context.handle(_accountIdMeta,
          accountId.isAcceptableOrUnknown(data['account_id']!, _accountIdMeta));
    }
    context.handle(_applicationStatusMeta, const VerificationResult.success());
    if (data.containsKey('source')) {
      context.handle(_sourceMeta,
          source.isAcceptableOrUnknown(data['source']!, _sourceMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    } else if (isInserting) {
      context.missing(_isDeletedMeta);
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    } else if (isInserting) {
      context.missing(_rowVersionMeta);
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {clientReferenceId, auditCreatedBy};
  @override
  PgrServiceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PgrServiceData(
      active: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}active'])!,
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      serviceCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}service_code'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description'])!,
      serviceRequestId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}service_request_id']),
      accountId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}account_id']),
      applicationStatus: $PgrServiceTable.$converterapplicationStatus.fromSql(
          attachedDatabase.typeMapping.read(
              DriftSqlType.int, data['${effectivePrefix}application_status'])!),
      source: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}source']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version'])!,
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $PgrServiceTable createAlias(String alias) {
    return $PgrServiceTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<PgrServiceApplicationStatus, int, int>
      $converterapplicationStatus =
      const EnumIndexConverter<PgrServiceApplicationStatus>(
          PgrServiceApplicationStatus.values);
}

class PgrServiceData extends DataClass implements Insertable<PgrServiceData> {
  final bool active;
  final String clientReferenceId;
  final String? id;
  final String tenantId;
  final String serviceCode;
  final String description;
  final String? serviceRequestId;
  final String? accountId;
  final PgrServiceApplicationStatus applicationStatus;
  final String? source;
  final String? auditCreatedBy;
  final int? auditCreatedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool isDeleted;
  final int rowVersion;
  final String? additionalFields;
  const PgrServiceData(
      {required this.active,
      required this.clientReferenceId,
      this.id,
      required this.tenantId,
      required this.serviceCode,
      required this.description,
      this.serviceRequestId,
      this.accountId,
      required this.applicationStatus,
      this.source,
      this.auditCreatedBy,
      this.auditCreatedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.isDeleted,
      required this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['active'] = Variable<bool>(active);
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    map['tenant_id'] = Variable<String>(tenantId);
    map['service_code'] = Variable<String>(serviceCode);
    map['description'] = Variable<String>(description);
    if (!nullToAbsent || serviceRequestId != null) {
      map['service_request_id'] = Variable<String>(serviceRequestId);
    }
    if (!nullToAbsent || accountId != null) {
      map['account_id'] = Variable<String>(accountId);
    }
    {
      map['application_status'] = Variable<int>($PgrServiceTable
          .$converterapplicationStatus
          .toSql(applicationStatus));
    }
    if (!nullToAbsent || source != null) {
      map['source'] = Variable<String>(source);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['row_version'] = Variable<int>(rowVersion);
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  PgrServiceCompanion toCompanion(bool nullToAbsent) {
    return PgrServiceCompanion(
      active: Value(active),
      clientReferenceId: Value(clientReferenceId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: Value(tenantId),
      serviceCode: Value(serviceCode),
      description: Value(description),
      serviceRequestId: serviceRequestId == null && nullToAbsent
          ? const Value.absent()
          : Value(serviceRequestId),
      accountId: accountId == null && nullToAbsent
          ? const Value.absent()
          : Value(accountId),
      applicationStatus: Value(applicationStatus),
      source:
          source == null && nullToAbsent ? const Value.absent() : Value(source),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: Value(isDeleted),
      rowVersion: Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory PgrServiceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PgrServiceData(
      active: serializer.fromJson<bool>(json['active']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String>(json['tenantId']),
      serviceCode: serializer.fromJson<String>(json['serviceCode']),
      description: serializer.fromJson<String>(json['description']),
      serviceRequestId: serializer.fromJson<String?>(json['serviceRequestId']),
      accountId: serializer.fromJson<String?>(json['accountId']),
      applicationStatus: $PgrServiceTable.$converterapplicationStatus
          .fromJson(serializer.fromJson<int>(json['applicationStatus'])),
      source: serializer.fromJson<String?>(json['source']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      rowVersion: serializer.fromJson<int>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'active': serializer.toJson<bool>(active),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String>(tenantId),
      'serviceCode': serializer.toJson<String>(serviceCode),
      'description': serializer.toJson<String>(description),
      'serviceRequestId': serializer.toJson<String?>(serviceRequestId),
      'accountId': serializer.toJson<String?>(accountId),
      'applicationStatus': serializer.toJson<int>($PgrServiceTable
          .$converterapplicationStatus
          .toJson(applicationStatus)),
      'source': serializer.toJson<String?>(source),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'rowVersion': serializer.toJson<int>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  PgrServiceData copyWith(
          {bool? active,
          String? clientReferenceId,
          Value<String?> id = const Value.absent(),
          String? tenantId,
          String? serviceCode,
          String? description,
          Value<String?> serviceRequestId = const Value.absent(),
          Value<String?> accountId = const Value.absent(),
          PgrServiceApplicationStatus? applicationStatus,
          Value<String?> source = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          bool? isDeleted,
          int? rowVersion,
          Value<String?> additionalFields = const Value.absent()}) =>
      PgrServiceData(
        active: active ?? this.active,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        id: id.present ? id.value : this.id,
        tenantId: tenantId ?? this.tenantId,
        serviceCode: serviceCode ?? this.serviceCode,
        description: description ?? this.description,
        serviceRequestId: serviceRequestId.present
            ? serviceRequestId.value
            : this.serviceRequestId,
        accountId: accountId.present ? accountId.value : this.accountId,
        applicationStatus: applicationStatus ?? this.applicationStatus,
        source: source.present ? source.value : this.source,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted ?? this.isDeleted,
        rowVersion: rowVersion ?? this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('PgrServiceData(')
          ..write('active: $active, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('serviceCode: $serviceCode, ')
          ..write('description: $description, ')
          ..write('serviceRequestId: $serviceRequestId, ')
          ..write('accountId: $accountId, ')
          ..write('applicationStatus: $applicationStatus, ')
          ..write('source: $source, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      active,
      clientReferenceId,
      id,
      tenantId,
      serviceCode,
      description,
      serviceRequestId,
      accountId,
      applicationStatus,
      source,
      auditCreatedBy,
      auditCreatedTime,
      auditModifiedBy,
      auditModifiedTime,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PgrServiceData &&
          other.active == this.active &&
          other.clientReferenceId == this.clientReferenceId &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.serviceCode == this.serviceCode &&
          other.description == this.description &&
          other.serviceRequestId == this.serviceRequestId &&
          other.accountId == this.accountId &&
          other.applicationStatus == this.applicationStatus &&
          other.source == this.source &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class PgrServiceCompanion extends UpdateCompanion<PgrServiceData> {
  final Value<bool> active;
  final Value<String> clientReferenceId;
  final Value<String?> id;
  final Value<String> tenantId;
  final Value<String> serviceCode;
  final Value<String> description;
  final Value<String?> serviceRequestId;
  final Value<String?> accountId;
  final Value<PgrServiceApplicationStatus> applicationStatus;
  final Value<String?> source;
  final Value<String?> auditCreatedBy;
  final Value<int?> auditCreatedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool> isDeleted;
  final Value<int> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const PgrServiceCompanion({
    this.active = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.serviceCode = const Value.absent(),
    this.description = const Value.absent(),
    this.serviceRequestId = const Value.absent(),
    this.accountId = const Value.absent(),
    this.applicationStatus = const Value.absent(),
    this.source = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PgrServiceCompanion.insert({
    required bool active,
    required String clientReferenceId,
    this.id = const Value.absent(),
    required String tenantId,
    required String serviceCode,
    required String description,
    this.serviceRequestId = const Value.absent(),
    this.accountId = const Value.absent(),
    required PgrServiceApplicationStatus applicationStatus,
    this.source = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required bool isDeleted,
    required int rowVersion,
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : active = Value(active),
        clientReferenceId = Value(clientReferenceId),
        tenantId = Value(tenantId),
        serviceCode = Value(serviceCode),
        description = Value(description),
        applicationStatus = Value(applicationStatus),
        isDeleted = Value(isDeleted),
        rowVersion = Value(rowVersion);
  static Insertable<PgrServiceData> custom({
    Expression<bool>? active,
    Expression<String>? clientReferenceId,
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? serviceCode,
    Expression<String>? description,
    Expression<String>? serviceRequestId,
    Expression<String>? accountId,
    Expression<int>? applicationStatus,
    Expression<String>? source,
    Expression<String>? auditCreatedBy,
    Expression<int>? auditCreatedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (active != null) 'active': active,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (serviceCode != null) 'service_code': serviceCode,
      if (description != null) 'description': description,
      if (serviceRequestId != null) 'service_request_id': serviceRequestId,
      if (accountId != null) 'account_id': accountId,
      if (applicationStatus != null) 'application_status': applicationStatus,
      if (source != null) 'source': source,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PgrServiceCompanion copyWith(
      {Value<bool>? active,
      Value<String>? clientReferenceId,
      Value<String?>? id,
      Value<String>? tenantId,
      Value<String>? serviceCode,
      Value<String>? description,
      Value<String?>? serviceRequestId,
      Value<String?>? accountId,
      Value<PgrServiceApplicationStatus>? applicationStatus,
      Value<String?>? source,
      Value<String?>? auditCreatedBy,
      Value<int?>? auditCreatedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool>? isDeleted,
      Value<int>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return PgrServiceCompanion(
      active: active ?? this.active,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      serviceCode: serviceCode ?? this.serviceCode,
      description: description ?? this.description,
      serviceRequestId: serviceRequestId ?? this.serviceRequestId,
      accountId: accountId ?? this.accountId,
      applicationStatus: applicationStatus ?? this.applicationStatus,
      source: source ?? this.source,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (active.present) {
      map['active'] = Variable<bool>(active.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (serviceCode.present) {
      map['service_code'] = Variable<String>(serviceCode.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (serviceRequestId.present) {
      map['service_request_id'] = Variable<String>(serviceRequestId.value);
    }
    if (accountId.present) {
      map['account_id'] = Variable<String>(accountId.value);
    }
    if (applicationStatus.present) {
      map['application_status'] = Variable<int>($PgrServiceTable
          .$converterapplicationStatus
          .toSql(applicationStatus.value));
    }
    if (source.present) {
      map['source'] = Variable<String>(source.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PgrServiceCompanion(')
          ..write('active: $active, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('serviceCode: $serviceCode, ')
          ..write('description: $description, ')
          ..write('serviceRequestId: $serviceRequestId, ')
          ..write('accountId: $accountId, ')
          ..write('applicationStatus: $applicationStatus, ')
          ..write('source: $source, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PgrComplainantTable extends PgrComplainant
    with TableInfo<$PgrComplainantTable, PgrComplainantData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PgrComplainantTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _complaintClientReferenceIdMeta =
      const VerificationMeta('complaintClientReferenceId');
  @override
  late final GeneratedColumn<String> complaintClientReferenceId =
      GeneratedColumn<String>(
          'complaint_client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _mobileNumberMeta =
      const VerificationMeta('mobileNumber');
  @override
  late final GeneratedColumn<String> mobileNumber = GeneratedColumn<String>(
      'mobile_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _emailIdMeta =
      const VerificationMeta('emailId');
  @override
  late final GeneratedColumn<String> emailId = GeneratedColumn<String>(
      'email_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _activeMeta = const VerificationMeta('active');
  @override
  late final GeneratedColumn<bool> active = GeneratedColumn<bool>(
      'active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("active" IN (0, 1))'));
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        clientReferenceId,
        complaintClientReferenceId,
        userName,
        name,
        type,
        mobileNumber,
        emailId,
        tenantId,
        uuid,
        active,
        auditCreatedBy,
        auditCreatedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'pgr_complainant';
  @override
  VerificationContext validateIntegrity(Insertable<PgrComplainantData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('complaint_client_reference_id')) {
      context.handle(
          _complaintClientReferenceIdMeta,
          complaintClientReferenceId.isAcceptableOrUnknown(
              data['complaint_client_reference_id']!,
              _complaintClientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_complaintClientReferenceIdMeta);
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('mobile_number')) {
      context.handle(
          _mobileNumberMeta,
          mobileNumber.isAcceptableOrUnknown(
              data['mobile_number']!, _mobileNumberMeta));
    }
    if (data.containsKey('email_id')) {
      context.handle(_emailIdMeta,
          emailId.isAcceptableOrUnknown(data['email_id']!, _emailIdMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    }
    if (data.containsKey('active')) {
      context.handle(_activeMeta,
          active.isAcceptableOrUnknown(data['active']!, _activeMeta));
    } else if (isInserting) {
      context.missing(_activeMeta);
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    } else if (isInserting) {
      context.missing(_isDeletedMeta);
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    } else if (isInserting) {
      context.missing(_rowVersionMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {clientReferenceId, auditCreatedBy};
  @override
  PgrComplainantData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PgrComplainantData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      complaintClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}complaint_client_reference_id'])!,
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      mobileNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mobile_number']),
      emailId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email_id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid']),
      active: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}active'])!,
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version'])!,
    );
  }

  @override
  $PgrComplainantTable createAlias(String alias) {
    return $PgrComplainantTable(attachedDatabase, alias);
  }
}

class PgrComplainantData extends DataClass
    implements Insertable<PgrComplainantData> {
  final int? id;
  final String clientReferenceId;
  final String complaintClientReferenceId;
  final String? userName;
  final String? name;
  final String? type;
  final String? mobileNumber;
  final String? emailId;
  final String tenantId;
  final String? uuid;
  final bool active;
  final String? auditCreatedBy;
  final int? auditCreatedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool isDeleted;
  final int rowVersion;
  const PgrComplainantData(
      {this.id,
      required this.clientReferenceId,
      required this.complaintClientReferenceId,
      this.userName,
      this.name,
      this.type,
      this.mobileNumber,
      this.emailId,
      required this.tenantId,
      this.uuid,
      required this.active,
      this.auditCreatedBy,
      this.auditCreatedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.isDeleted,
      required this.rowVersion});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    map['complaint_client_reference_id'] =
        Variable<String>(complaintClientReferenceId);
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || mobileNumber != null) {
      map['mobile_number'] = Variable<String>(mobileNumber);
    }
    if (!nullToAbsent || emailId != null) {
      map['email_id'] = Variable<String>(emailId);
    }
    map['tenant_id'] = Variable<String>(tenantId);
    if (!nullToAbsent || uuid != null) {
      map['uuid'] = Variable<String>(uuid);
    }
    map['active'] = Variable<bool>(active);
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['row_version'] = Variable<int>(rowVersion);
    return map;
  }

  PgrComplainantCompanion toCompanion(bool nullToAbsent) {
    return PgrComplainantCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      clientReferenceId: Value(clientReferenceId),
      complaintClientReferenceId: Value(complaintClientReferenceId),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      mobileNumber: mobileNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(mobileNumber),
      emailId: emailId == null && nullToAbsent
          ? const Value.absent()
          : Value(emailId),
      tenantId: Value(tenantId),
      uuid: uuid == null && nullToAbsent ? const Value.absent() : Value(uuid),
      active: Value(active),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: Value(isDeleted),
      rowVersion: Value(rowVersion),
    );
  }

  factory PgrComplainantData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PgrComplainantData(
      id: serializer.fromJson<int?>(json['id']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      complaintClientReferenceId:
          serializer.fromJson<String>(json['complaintClientReferenceId']),
      userName: serializer.fromJson<String?>(json['userName']),
      name: serializer.fromJson<String?>(json['name']),
      type: serializer.fromJson<String?>(json['type']),
      mobileNumber: serializer.fromJson<String?>(json['mobileNumber']),
      emailId: serializer.fromJson<String?>(json['emailId']),
      tenantId: serializer.fromJson<String>(json['tenantId']),
      uuid: serializer.fromJson<String?>(json['uuid']),
      active: serializer.fromJson<bool>(json['active']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      rowVersion: serializer.fromJson<int>(json['rowVersion']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int?>(id),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'complaintClientReferenceId':
          serializer.toJson<String>(complaintClientReferenceId),
      'userName': serializer.toJson<String?>(userName),
      'name': serializer.toJson<String?>(name),
      'type': serializer.toJson<String?>(type),
      'mobileNumber': serializer.toJson<String?>(mobileNumber),
      'emailId': serializer.toJson<String?>(emailId),
      'tenantId': serializer.toJson<String>(tenantId),
      'uuid': serializer.toJson<String?>(uuid),
      'active': serializer.toJson<bool>(active),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'rowVersion': serializer.toJson<int>(rowVersion),
    };
  }

  PgrComplainantData copyWith(
          {Value<int?> id = const Value.absent(),
          String? clientReferenceId,
          String? complaintClientReferenceId,
          Value<String?> userName = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<String?> mobileNumber = const Value.absent(),
          Value<String?> emailId = const Value.absent(),
          String? tenantId,
          Value<String?> uuid = const Value.absent(),
          bool? active,
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          bool? isDeleted,
          int? rowVersion}) =>
      PgrComplainantData(
        id: id.present ? id.value : this.id,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        complaintClientReferenceId:
            complaintClientReferenceId ?? this.complaintClientReferenceId,
        userName: userName.present ? userName.value : this.userName,
        name: name.present ? name.value : this.name,
        type: type.present ? type.value : this.type,
        mobileNumber:
            mobileNumber.present ? mobileNumber.value : this.mobileNumber,
        emailId: emailId.present ? emailId.value : this.emailId,
        tenantId: tenantId ?? this.tenantId,
        uuid: uuid.present ? uuid.value : this.uuid,
        active: active ?? this.active,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted ?? this.isDeleted,
        rowVersion: rowVersion ?? this.rowVersion,
      );
  @override
  String toString() {
    return (StringBuffer('PgrComplainantData(')
          ..write('id: $id, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('complaintClientReferenceId: $complaintClientReferenceId, ')
          ..write('userName: $userName, ')
          ..write('name: $name, ')
          ..write('type: $type, ')
          ..write('mobileNumber: $mobileNumber, ')
          ..write('emailId: $emailId, ')
          ..write('tenantId: $tenantId, ')
          ..write('uuid: $uuid, ')
          ..write('active: $active, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      clientReferenceId,
      complaintClientReferenceId,
      userName,
      name,
      type,
      mobileNumber,
      emailId,
      tenantId,
      uuid,
      active,
      auditCreatedBy,
      auditCreatedTime,
      auditModifiedBy,
      auditModifiedTime,
      isDeleted,
      rowVersion);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PgrComplainantData &&
          other.id == this.id &&
          other.clientReferenceId == this.clientReferenceId &&
          other.complaintClientReferenceId == this.complaintClientReferenceId &&
          other.userName == this.userName &&
          other.name == this.name &&
          other.type == this.type &&
          other.mobileNumber == this.mobileNumber &&
          other.emailId == this.emailId &&
          other.tenantId == this.tenantId &&
          other.uuid == this.uuid &&
          other.active == this.active &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion);
}

class PgrComplainantCompanion extends UpdateCompanion<PgrComplainantData> {
  final Value<int?> id;
  final Value<String> clientReferenceId;
  final Value<String> complaintClientReferenceId;
  final Value<String?> userName;
  final Value<String?> name;
  final Value<String?> type;
  final Value<String?> mobileNumber;
  final Value<String?> emailId;
  final Value<String> tenantId;
  final Value<String?> uuid;
  final Value<bool> active;
  final Value<String?> auditCreatedBy;
  final Value<int?> auditCreatedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool> isDeleted;
  final Value<int> rowVersion;
  final Value<int> rowid;
  const PgrComplainantCompanion({
    this.id = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.complaintClientReferenceId = const Value.absent(),
    this.userName = const Value.absent(),
    this.name = const Value.absent(),
    this.type = const Value.absent(),
    this.mobileNumber = const Value.absent(),
    this.emailId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.uuid = const Value.absent(),
    this.active = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PgrComplainantCompanion.insert({
    this.id = const Value.absent(),
    required String clientReferenceId,
    required String complaintClientReferenceId,
    this.userName = const Value.absent(),
    this.name = const Value.absent(),
    this.type = const Value.absent(),
    this.mobileNumber = const Value.absent(),
    this.emailId = const Value.absent(),
    required String tenantId,
    this.uuid = const Value.absent(),
    required bool active,
    this.auditCreatedBy = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required bool isDeleted,
    required int rowVersion,
    this.rowid = const Value.absent(),
  })  : clientReferenceId = Value(clientReferenceId),
        complaintClientReferenceId = Value(complaintClientReferenceId),
        tenantId = Value(tenantId),
        active = Value(active),
        isDeleted = Value(isDeleted),
        rowVersion = Value(rowVersion);
  static Insertable<PgrComplainantData> custom({
    Expression<int>? id,
    Expression<String>? clientReferenceId,
    Expression<String>? complaintClientReferenceId,
    Expression<String>? userName,
    Expression<String>? name,
    Expression<String>? type,
    Expression<String>? mobileNumber,
    Expression<String>? emailId,
    Expression<String>? tenantId,
    Expression<String>? uuid,
    Expression<bool>? active,
    Expression<String>? auditCreatedBy,
    Expression<int>? auditCreatedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (complaintClientReferenceId != null)
        'complaint_client_reference_id': complaintClientReferenceId,
      if (userName != null) 'user_name': userName,
      if (name != null) 'name': name,
      if (type != null) 'type': type,
      if (mobileNumber != null) 'mobile_number': mobileNumber,
      if (emailId != null) 'email_id': emailId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (uuid != null) 'uuid': uuid,
      if (active != null) 'active': active,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PgrComplainantCompanion copyWith(
      {Value<int?>? id,
      Value<String>? clientReferenceId,
      Value<String>? complaintClientReferenceId,
      Value<String?>? userName,
      Value<String?>? name,
      Value<String?>? type,
      Value<String?>? mobileNumber,
      Value<String?>? emailId,
      Value<String>? tenantId,
      Value<String?>? uuid,
      Value<bool>? active,
      Value<String?>? auditCreatedBy,
      Value<int?>? auditCreatedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool>? isDeleted,
      Value<int>? rowVersion,
      Value<int>? rowid}) {
    return PgrComplainantCompanion(
      id: id ?? this.id,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      complaintClientReferenceId:
          complaintClientReferenceId ?? this.complaintClientReferenceId,
      userName: userName ?? this.userName,
      name: name ?? this.name,
      type: type ?? this.type,
      mobileNumber: mobileNumber ?? this.mobileNumber,
      emailId: emailId ?? this.emailId,
      tenantId: tenantId ?? this.tenantId,
      uuid: uuid ?? this.uuid,
      active: active ?? this.active,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (complaintClientReferenceId.present) {
      map['complaint_client_reference_id'] =
          Variable<String>(complaintClientReferenceId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (mobileNumber.present) {
      map['mobile_number'] = Variable<String>(mobileNumber.value);
    }
    if (emailId.present) {
      map['email_id'] = Variable<String>(emailId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (active.present) {
      map['active'] = Variable<bool>(active.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PgrComplainantCompanion(')
          ..write('id: $id, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('complaintClientReferenceId: $complaintClientReferenceId, ')
          ..write('userName: $userName, ')
          ..write('name: $name, ')
          ..write('type: $type, ')
          ..write('mobileNumber: $mobileNumber, ')
          ..write('emailId: $emailId, ')
          ..write('tenantId: $tenantId, ')
          ..write('uuid: $uuid, ')
          ..write('active: $active, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserTable extends User with TableInfo<$UserTable, UserData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _salutationMeta =
      const VerificationMeta('salutation');
  @override
  late final GeneratedColumn<String> salutation = GeneratedColumn<String>(
      'salutation', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _genderMeta = const VerificationMeta('gender');
  @override
  late final GeneratedColumn<String> gender = GeneratedColumn<String>(
      'gender', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _mobileNumberMeta =
      const VerificationMeta('mobileNumber');
  @override
  late final GeneratedColumn<String> mobileNumber = GeneratedColumn<String>(
      'mobile_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _emailIdMeta =
      const VerificationMeta('emailId');
  @override
  late final GeneratedColumn<String> emailId = GeneratedColumn<String>(
      'email_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _altContactNumberMeta =
      const VerificationMeta('altContactNumber');
  @override
  late final GeneratedColumn<String> altContactNumber = GeneratedColumn<String>(
      'alt_contact_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _panMeta = const VerificationMeta('pan');
  @override
  late final GeneratedColumn<String> pan = GeneratedColumn<String>(
      'pan', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _aadhaarNumberMeta =
      const VerificationMeta('aadhaarNumber');
  @override
  late final GeneratedColumn<String> aadhaarNumber = GeneratedColumn<String>(
      'aadhaar_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _permanentAddressMeta =
      const VerificationMeta('permanentAddress');
  @override
  late final GeneratedColumn<String> permanentAddress = GeneratedColumn<String>(
      'permanent_address', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _permanentCityMeta =
      const VerificationMeta('permanentCity');
  @override
  late final GeneratedColumn<String> permanentCity = GeneratedColumn<String>(
      'permanent_city', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _permanentPinCodeMeta =
      const VerificationMeta('permanentPinCode');
  @override
  late final GeneratedColumn<String> permanentPinCode = GeneratedColumn<String>(
      'permanent_pin_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _correspondenceAddressMeta =
      const VerificationMeta('correspondenceAddress');
  @override
  late final GeneratedColumn<String> correspondenceAddress =
      GeneratedColumn<String>('correspondence_address', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _correspondenceCityMeta =
      const VerificationMeta('correspondenceCity');
  @override
  late final GeneratedColumn<String> correspondenceCity =
      GeneratedColumn<String>('correspondence_city', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _correspondencePinCodeMeta =
      const VerificationMeta('correspondencePinCode');
  @override
  late final GeneratedColumn<String> correspondencePinCode =
      GeneratedColumn<String>('correspondence_pin_code', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _alternatemobilenumberMeta =
      const VerificationMeta('alternatemobilenumber');
  @override
  late final GeneratedColumn<String> alternatemobilenumber =
      GeneratedColumn<String>('alternatemobilenumber', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _activeMeta = const VerificationMeta('active');
  @override
  late final GeneratedColumn<bool> active = GeneratedColumn<bool>(
      'active', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("active" IN (0, 1))'));
  static const VerificationMeta _localeMeta = const VerificationMeta('locale');
  @override
  late final GeneratedColumn<String> locale = GeneratedColumn<String>(
      'locale', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _accountLockedMeta =
      const VerificationMeta('accountLocked');
  @override
  late final GeneratedColumn<bool> accountLocked = GeneratedColumn<bool>(
      'account_locked', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("account_locked" IN (0, 1))'));
  static const VerificationMeta _accountLockedDateMeta =
      const VerificationMeta('accountLockedDate');
  @override
  late final GeneratedColumn<int> accountLockedDate = GeneratedColumn<int>(
      'account_locked_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _fatherOrHusbandNameMeta =
      const VerificationMeta('fatherOrHusbandName');
  @override
  late final GeneratedColumn<String> fatherOrHusbandName =
      GeneratedColumn<String>('father_or_husband_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _relationshipMeta =
      const VerificationMeta('relationship');
  @override
  late final GeneratedColumn<String> relationship = GeneratedColumn<String>(
      'relationship', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _signatureMeta =
      const VerificationMeta('signature');
  @override
  late final GeneratedColumn<String> signature = GeneratedColumn<String>(
      'signature', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _bloodGroupMeta =
      const VerificationMeta('bloodGroup');
  @override
  late final GeneratedColumn<String> bloodGroup = GeneratedColumn<String>(
      'blood_group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _photoMeta = const VerificationMeta('photo');
  @override
  late final GeneratedColumn<String> photo = GeneratedColumn<String>(
      'photo', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _identificationMarkMeta =
      const VerificationMeta('identificationMark');
  @override
  late final GeneratedColumn<String> identificationMark =
      GeneratedColumn<String>('identification_mark', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  @override
  late final GeneratedColumn<int> createdBy = GeneratedColumn<int>(
      'created_by', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _lastModifiedByMeta =
      const VerificationMeta('lastModifiedBy');
  @override
  late final GeneratedColumn<String> lastModifiedBy = GeneratedColumn<String>(
      'last_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<String> createdDate = GeneratedColumn<String>(
      'created_date', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        userName,
        salutation,
        name,
        gender,
        mobileNumber,
        emailId,
        altContactNumber,
        pan,
        aadhaarNumber,
        permanentAddress,
        permanentCity,
        permanentPinCode,
        correspondenceAddress,
        correspondenceCity,
        correspondencePinCode,
        alternatemobilenumber,
        active,
        locale,
        type,
        accountLocked,
        accountLockedDate,
        fatherOrHusbandName,
        relationship,
        signature,
        bloodGroup,
        photo,
        identificationMark,
        createdBy,
        lastModifiedBy,
        tenantId,
        uuid,
        createdDate,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user';
  @override
  VerificationContext validateIntegrity(Insertable<UserData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    }
    if (data.containsKey('salutation')) {
      context.handle(
          _salutationMeta,
          salutation.isAcceptableOrUnknown(
              data['salutation']!, _salutationMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('gender')) {
      context.handle(_genderMeta,
          gender.isAcceptableOrUnknown(data['gender']!, _genderMeta));
    }
    if (data.containsKey('mobile_number')) {
      context.handle(
          _mobileNumberMeta,
          mobileNumber.isAcceptableOrUnknown(
              data['mobile_number']!, _mobileNumberMeta));
    }
    if (data.containsKey('email_id')) {
      context.handle(_emailIdMeta,
          emailId.isAcceptableOrUnknown(data['email_id']!, _emailIdMeta));
    }
    if (data.containsKey('alt_contact_number')) {
      context.handle(
          _altContactNumberMeta,
          altContactNumber.isAcceptableOrUnknown(
              data['alt_contact_number']!, _altContactNumberMeta));
    }
    if (data.containsKey('pan')) {
      context.handle(
          _panMeta, pan.isAcceptableOrUnknown(data['pan']!, _panMeta));
    }
    if (data.containsKey('aadhaar_number')) {
      context.handle(
          _aadhaarNumberMeta,
          aadhaarNumber.isAcceptableOrUnknown(
              data['aadhaar_number']!, _aadhaarNumberMeta));
    }
    if (data.containsKey('permanent_address')) {
      context.handle(
          _permanentAddressMeta,
          permanentAddress.isAcceptableOrUnknown(
              data['permanent_address']!, _permanentAddressMeta));
    }
    if (data.containsKey('permanent_city')) {
      context.handle(
          _permanentCityMeta,
          permanentCity.isAcceptableOrUnknown(
              data['permanent_city']!, _permanentCityMeta));
    }
    if (data.containsKey('permanent_pin_code')) {
      context.handle(
          _permanentPinCodeMeta,
          permanentPinCode.isAcceptableOrUnknown(
              data['permanent_pin_code']!, _permanentPinCodeMeta));
    }
    if (data.containsKey('correspondence_address')) {
      context.handle(
          _correspondenceAddressMeta,
          correspondenceAddress.isAcceptableOrUnknown(
              data['correspondence_address']!, _correspondenceAddressMeta));
    }
    if (data.containsKey('correspondence_city')) {
      context.handle(
          _correspondenceCityMeta,
          correspondenceCity.isAcceptableOrUnknown(
              data['correspondence_city']!, _correspondenceCityMeta));
    }
    if (data.containsKey('correspondence_pin_code')) {
      context.handle(
          _correspondencePinCodeMeta,
          correspondencePinCode.isAcceptableOrUnknown(
              data['correspondence_pin_code']!, _correspondencePinCodeMeta));
    }
    if (data.containsKey('alternatemobilenumber')) {
      context.handle(
          _alternatemobilenumberMeta,
          alternatemobilenumber.isAcceptableOrUnknown(
              data['alternatemobilenumber']!, _alternatemobilenumberMeta));
    }
    if (data.containsKey('active')) {
      context.handle(_activeMeta,
          active.isAcceptableOrUnknown(data['active']!, _activeMeta));
    }
    if (data.containsKey('locale')) {
      context.handle(_localeMeta,
          locale.isAcceptableOrUnknown(data['locale']!, _localeMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('account_locked')) {
      context.handle(
          _accountLockedMeta,
          accountLocked.isAcceptableOrUnknown(
              data['account_locked']!, _accountLockedMeta));
    }
    if (data.containsKey('account_locked_date')) {
      context.handle(
          _accountLockedDateMeta,
          accountLockedDate.isAcceptableOrUnknown(
              data['account_locked_date']!, _accountLockedDateMeta));
    }
    if (data.containsKey('father_or_husband_name')) {
      context.handle(
          _fatherOrHusbandNameMeta,
          fatherOrHusbandName.isAcceptableOrUnknown(
              data['father_or_husband_name']!, _fatherOrHusbandNameMeta));
    }
    if (data.containsKey('relationship')) {
      context.handle(
          _relationshipMeta,
          relationship.isAcceptableOrUnknown(
              data['relationship']!, _relationshipMeta));
    }
    if (data.containsKey('signature')) {
      context.handle(_signatureMeta,
          signature.isAcceptableOrUnknown(data['signature']!, _signatureMeta));
    }
    if (data.containsKey('blood_group')) {
      context.handle(
          _bloodGroupMeta,
          bloodGroup.isAcceptableOrUnknown(
              data['blood_group']!, _bloodGroupMeta));
    }
    if (data.containsKey('photo')) {
      context.handle(
          _photoMeta, photo.isAcceptableOrUnknown(data['photo']!, _photoMeta));
    }
    if (data.containsKey('identification_mark')) {
      context.handle(
          _identificationMarkMeta,
          identificationMark.isAcceptableOrUnknown(
              data['identification_mark']!, _identificationMarkMeta));
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    }
    if (data.containsKey('last_modified_by')) {
      context.handle(
          _lastModifiedByMeta,
          lastModifiedBy.isAcceptableOrUnknown(
              data['last_modified_by']!, _lastModifiedByMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid, auditCreatedBy};
  @override
  UserData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name']),
      salutation: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}salutation']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      gender: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}gender']),
      mobileNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mobile_number']),
      emailId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email_id']),
      altContactNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}alt_contact_number']),
      pan: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}pan']),
      aadhaarNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}aadhaar_number']),
      permanentAddress: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}permanent_address']),
      permanentCity: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}permanent_city']),
      permanentPinCode: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}permanent_pin_code']),
      correspondenceAddress: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}correspondence_address']),
      correspondenceCity: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}correspondence_city']),
      correspondencePinCode: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}correspondence_pin_code']),
      alternatemobilenumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}alternatemobilenumber']),
      active: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}active']),
      locale: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}locale']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      accountLocked: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}account_locked']),
      accountLockedDate: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}account_locked_date']),
      fatherOrHusbandName: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}father_or_husband_name']),
      relationship: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}relationship']),
      signature: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}signature']),
      bloodGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}blood_group']),
      photo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}photo']),
      identificationMark: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}identification_mark']),
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_by']),
      lastModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}last_modified_by']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_date']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $UserTable createAlias(String alias) {
    return $UserTable(attachedDatabase, alias);
  }
}

class UserData extends DataClass implements Insertable<UserData> {
  final String? id;
  final String? userName;
  final String? salutation;
  final String? name;
  final String? gender;
  final String? mobileNumber;
  final String? emailId;
  final String? altContactNumber;
  final String? pan;
  final String? aadhaarNumber;
  final String? permanentAddress;
  final String? permanentCity;
  final String? permanentPinCode;
  final String? correspondenceAddress;
  final String? correspondenceCity;
  final String? correspondencePinCode;
  final String? alternatemobilenumber;
  final bool? active;
  final String? locale;
  final String? type;
  final bool? accountLocked;
  final int? accountLockedDate;
  final String? fatherOrHusbandName;
  final String? relationship;
  final String? signature;
  final String? bloodGroup;
  final String? photo;
  final String? identificationMark;
  final int? createdBy;
  final String? lastModifiedBy;
  final String? tenantId;
  final String? uuid;
  final String? createdDate;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const UserData(
      {this.id,
      this.userName,
      this.salutation,
      this.name,
      this.gender,
      this.mobileNumber,
      this.emailId,
      this.altContactNumber,
      this.pan,
      this.aadhaarNumber,
      this.permanentAddress,
      this.permanentCity,
      this.permanentPinCode,
      this.correspondenceAddress,
      this.correspondenceCity,
      this.correspondencePinCode,
      this.alternatemobilenumber,
      this.active,
      this.locale,
      this.type,
      this.accountLocked,
      this.accountLockedDate,
      this.fatherOrHusbandName,
      this.relationship,
      this.signature,
      this.bloodGroup,
      this.photo,
      this.identificationMark,
      this.createdBy,
      this.lastModifiedBy,
      this.tenantId,
      this.uuid,
      this.createdDate,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || salutation != null) {
      map['salutation'] = Variable<String>(salutation);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || gender != null) {
      map['gender'] = Variable<String>(gender);
    }
    if (!nullToAbsent || mobileNumber != null) {
      map['mobile_number'] = Variable<String>(mobileNumber);
    }
    if (!nullToAbsent || emailId != null) {
      map['email_id'] = Variable<String>(emailId);
    }
    if (!nullToAbsent || altContactNumber != null) {
      map['alt_contact_number'] = Variable<String>(altContactNumber);
    }
    if (!nullToAbsent || pan != null) {
      map['pan'] = Variable<String>(pan);
    }
    if (!nullToAbsent || aadhaarNumber != null) {
      map['aadhaar_number'] = Variable<String>(aadhaarNumber);
    }
    if (!nullToAbsent || permanentAddress != null) {
      map['permanent_address'] = Variable<String>(permanentAddress);
    }
    if (!nullToAbsent || permanentCity != null) {
      map['permanent_city'] = Variable<String>(permanentCity);
    }
    if (!nullToAbsent || permanentPinCode != null) {
      map['permanent_pin_code'] = Variable<String>(permanentPinCode);
    }
    if (!nullToAbsent || correspondenceAddress != null) {
      map['correspondence_address'] = Variable<String>(correspondenceAddress);
    }
    if (!nullToAbsent || correspondenceCity != null) {
      map['correspondence_city'] = Variable<String>(correspondenceCity);
    }
    if (!nullToAbsent || correspondencePinCode != null) {
      map['correspondence_pin_code'] = Variable<String>(correspondencePinCode);
    }
    if (!nullToAbsent || alternatemobilenumber != null) {
      map['alternatemobilenumber'] = Variable<String>(alternatemobilenumber);
    }
    if (!nullToAbsent || active != null) {
      map['active'] = Variable<bool>(active);
    }
    if (!nullToAbsent || locale != null) {
      map['locale'] = Variable<String>(locale);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || accountLocked != null) {
      map['account_locked'] = Variable<bool>(accountLocked);
    }
    if (!nullToAbsent || accountLockedDate != null) {
      map['account_locked_date'] = Variable<int>(accountLockedDate);
    }
    if (!nullToAbsent || fatherOrHusbandName != null) {
      map['father_or_husband_name'] = Variable<String>(fatherOrHusbandName);
    }
    if (!nullToAbsent || relationship != null) {
      map['relationship'] = Variable<String>(relationship);
    }
    if (!nullToAbsent || signature != null) {
      map['signature'] = Variable<String>(signature);
    }
    if (!nullToAbsent || bloodGroup != null) {
      map['blood_group'] = Variable<String>(bloodGroup);
    }
    if (!nullToAbsent || photo != null) {
      map['photo'] = Variable<String>(photo);
    }
    if (!nullToAbsent || identificationMark != null) {
      map['identification_mark'] = Variable<String>(identificationMark);
    }
    if (!nullToAbsent || createdBy != null) {
      map['created_by'] = Variable<int>(createdBy);
    }
    if (!nullToAbsent || lastModifiedBy != null) {
      map['last_modified_by'] = Variable<String>(lastModifiedBy);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || uuid != null) {
      map['uuid'] = Variable<String>(uuid);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<String>(createdDate);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  UserCompanion toCompanion(bool nullToAbsent) {
    return UserCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      salutation: salutation == null && nullToAbsent
          ? const Value.absent()
          : Value(salutation),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      gender:
          gender == null && nullToAbsent ? const Value.absent() : Value(gender),
      mobileNumber: mobileNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(mobileNumber),
      emailId: emailId == null && nullToAbsent
          ? const Value.absent()
          : Value(emailId),
      altContactNumber: altContactNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(altContactNumber),
      pan: pan == null && nullToAbsent ? const Value.absent() : Value(pan),
      aadhaarNumber: aadhaarNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(aadhaarNumber),
      permanentAddress: permanentAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(permanentAddress),
      permanentCity: permanentCity == null && nullToAbsent
          ? const Value.absent()
          : Value(permanentCity),
      permanentPinCode: permanentPinCode == null && nullToAbsent
          ? const Value.absent()
          : Value(permanentPinCode),
      correspondenceAddress: correspondenceAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(correspondenceAddress),
      correspondenceCity: correspondenceCity == null && nullToAbsent
          ? const Value.absent()
          : Value(correspondenceCity),
      correspondencePinCode: correspondencePinCode == null && nullToAbsent
          ? const Value.absent()
          : Value(correspondencePinCode),
      alternatemobilenumber: alternatemobilenumber == null && nullToAbsent
          ? const Value.absent()
          : Value(alternatemobilenumber),
      active:
          active == null && nullToAbsent ? const Value.absent() : Value(active),
      locale:
          locale == null && nullToAbsent ? const Value.absent() : Value(locale),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      accountLocked: accountLocked == null && nullToAbsent
          ? const Value.absent()
          : Value(accountLocked),
      accountLockedDate: accountLockedDate == null && nullToAbsent
          ? const Value.absent()
          : Value(accountLockedDate),
      fatherOrHusbandName: fatherOrHusbandName == null && nullToAbsent
          ? const Value.absent()
          : Value(fatherOrHusbandName),
      relationship: relationship == null && nullToAbsent
          ? const Value.absent()
          : Value(relationship),
      signature: signature == null && nullToAbsent
          ? const Value.absent()
          : Value(signature),
      bloodGroup: bloodGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(bloodGroup),
      photo:
          photo == null && nullToAbsent ? const Value.absent() : Value(photo),
      identificationMark: identificationMark == null && nullToAbsent
          ? const Value.absent()
          : Value(identificationMark),
      createdBy: createdBy == null && nullToAbsent
          ? const Value.absent()
          : Value(createdBy),
      lastModifiedBy: lastModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedBy),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      uuid: uuid == null && nullToAbsent ? const Value.absent() : Value(uuid),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory UserData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserData(
      id: serializer.fromJson<String?>(json['id']),
      userName: serializer.fromJson<String?>(json['userName']),
      salutation: serializer.fromJson<String?>(json['salutation']),
      name: serializer.fromJson<String?>(json['name']),
      gender: serializer.fromJson<String?>(json['gender']),
      mobileNumber: serializer.fromJson<String?>(json['mobileNumber']),
      emailId: serializer.fromJson<String?>(json['emailId']),
      altContactNumber: serializer.fromJson<String?>(json['altContactNumber']),
      pan: serializer.fromJson<String?>(json['pan']),
      aadhaarNumber: serializer.fromJson<String?>(json['aadhaarNumber']),
      permanentAddress: serializer.fromJson<String?>(json['permanentAddress']),
      permanentCity: serializer.fromJson<String?>(json['permanentCity']),
      permanentPinCode: serializer.fromJson<String?>(json['permanentPinCode']),
      correspondenceAddress:
          serializer.fromJson<String?>(json['correspondenceAddress']),
      correspondenceCity:
          serializer.fromJson<String?>(json['correspondenceCity']),
      correspondencePinCode:
          serializer.fromJson<String?>(json['correspondencePinCode']),
      alternatemobilenumber:
          serializer.fromJson<String?>(json['alternatemobilenumber']),
      active: serializer.fromJson<bool?>(json['active']),
      locale: serializer.fromJson<String?>(json['locale']),
      type: serializer.fromJson<String?>(json['type']),
      accountLocked: serializer.fromJson<bool?>(json['accountLocked']),
      accountLockedDate: serializer.fromJson<int?>(json['accountLockedDate']),
      fatherOrHusbandName:
          serializer.fromJson<String?>(json['fatherOrHusbandName']),
      relationship: serializer.fromJson<String?>(json['relationship']),
      signature: serializer.fromJson<String?>(json['signature']),
      bloodGroup: serializer.fromJson<String?>(json['bloodGroup']),
      photo: serializer.fromJson<String?>(json['photo']),
      identificationMark:
          serializer.fromJson<String?>(json['identificationMark']),
      createdBy: serializer.fromJson<int?>(json['createdBy']),
      lastModifiedBy: serializer.fromJson<String?>(json['lastModifiedBy']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      uuid: serializer.fromJson<String?>(json['uuid']),
      createdDate: serializer.fromJson<String?>(json['createdDate']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'userName': serializer.toJson<String?>(userName),
      'salutation': serializer.toJson<String?>(salutation),
      'name': serializer.toJson<String?>(name),
      'gender': serializer.toJson<String?>(gender),
      'mobileNumber': serializer.toJson<String?>(mobileNumber),
      'emailId': serializer.toJson<String?>(emailId),
      'altContactNumber': serializer.toJson<String?>(altContactNumber),
      'pan': serializer.toJson<String?>(pan),
      'aadhaarNumber': serializer.toJson<String?>(aadhaarNumber),
      'permanentAddress': serializer.toJson<String?>(permanentAddress),
      'permanentCity': serializer.toJson<String?>(permanentCity),
      'permanentPinCode': serializer.toJson<String?>(permanentPinCode),
      'correspondenceAddress':
          serializer.toJson<String?>(correspondenceAddress),
      'correspondenceCity': serializer.toJson<String?>(correspondenceCity),
      'correspondencePinCode':
          serializer.toJson<String?>(correspondencePinCode),
      'alternatemobilenumber':
          serializer.toJson<String?>(alternatemobilenumber),
      'active': serializer.toJson<bool?>(active),
      'locale': serializer.toJson<String?>(locale),
      'type': serializer.toJson<String?>(type),
      'accountLocked': serializer.toJson<bool?>(accountLocked),
      'accountLockedDate': serializer.toJson<int?>(accountLockedDate),
      'fatherOrHusbandName': serializer.toJson<String?>(fatherOrHusbandName),
      'relationship': serializer.toJson<String?>(relationship),
      'signature': serializer.toJson<String?>(signature),
      'bloodGroup': serializer.toJson<String?>(bloodGroup),
      'photo': serializer.toJson<String?>(photo),
      'identificationMark': serializer.toJson<String?>(identificationMark),
      'createdBy': serializer.toJson<int?>(createdBy),
      'lastModifiedBy': serializer.toJson<String?>(lastModifiedBy),
      'tenantId': serializer.toJson<String?>(tenantId),
      'uuid': serializer.toJson<String?>(uuid),
      'createdDate': serializer.toJson<String?>(createdDate),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  UserData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> userName = const Value.absent(),
          Value<String?> salutation = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<String?> gender = const Value.absent(),
          Value<String?> mobileNumber = const Value.absent(),
          Value<String?> emailId = const Value.absent(),
          Value<String?> altContactNumber = const Value.absent(),
          Value<String?> pan = const Value.absent(),
          Value<String?> aadhaarNumber = const Value.absent(),
          Value<String?> permanentAddress = const Value.absent(),
          Value<String?> permanentCity = const Value.absent(),
          Value<String?> permanentPinCode = const Value.absent(),
          Value<String?> correspondenceAddress = const Value.absent(),
          Value<String?> correspondenceCity = const Value.absent(),
          Value<String?> correspondencePinCode = const Value.absent(),
          Value<String?> alternatemobilenumber = const Value.absent(),
          Value<bool?> active = const Value.absent(),
          Value<String?> locale = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<bool?> accountLocked = const Value.absent(),
          Value<int?> accountLockedDate = const Value.absent(),
          Value<String?> fatherOrHusbandName = const Value.absent(),
          Value<String?> relationship = const Value.absent(),
          Value<String?> signature = const Value.absent(),
          Value<String?> bloodGroup = const Value.absent(),
          Value<String?> photo = const Value.absent(),
          Value<String?> identificationMark = const Value.absent(),
          Value<int?> createdBy = const Value.absent(),
          Value<String?> lastModifiedBy = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> uuid = const Value.absent(),
          Value<String?> createdDate = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      UserData(
        id: id.present ? id.value : this.id,
        userName: userName.present ? userName.value : this.userName,
        salutation: salutation.present ? salutation.value : this.salutation,
        name: name.present ? name.value : this.name,
        gender: gender.present ? gender.value : this.gender,
        mobileNumber:
            mobileNumber.present ? mobileNumber.value : this.mobileNumber,
        emailId: emailId.present ? emailId.value : this.emailId,
        altContactNumber: altContactNumber.present
            ? altContactNumber.value
            : this.altContactNumber,
        pan: pan.present ? pan.value : this.pan,
        aadhaarNumber:
            aadhaarNumber.present ? aadhaarNumber.value : this.aadhaarNumber,
        permanentAddress: permanentAddress.present
            ? permanentAddress.value
            : this.permanentAddress,
        permanentCity:
            permanentCity.present ? permanentCity.value : this.permanentCity,
        permanentPinCode: permanentPinCode.present
            ? permanentPinCode.value
            : this.permanentPinCode,
        correspondenceAddress: correspondenceAddress.present
            ? correspondenceAddress.value
            : this.correspondenceAddress,
        correspondenceCity: correspondenceCity.present
            ? correspondenceCity.value
            : this.correspondenceCity,
        correspondencePinCode: correspondencePinCode.present
            ? correspondencePinCode.value
            : this.correspondencePinCode,
        alternatemobilenumber: alternatemobilenumber.present
            ? alternatemobilenumber.value
            : this.alternatemobilenumber,
        active: active.present ? active.value : this.active,
        locale: locale.present ? locale.value : this.locale,
        type: type.present ? type.value : this.type,
        accountLocked:
            accountLocked.present ? accountLocked.value : this.accountLocked,
        accountLockedDate: accountLockedDate.present
            ? accountLockedDate.value
            : this.accountLockedDate,
        fatherOrHusbandName: fatherOrHusbandName.present
            ? fatherOrHusbandName.value
            : this.fatherOrHusbandName,
        relationship:
            relationship.present ? relationship.value : this.relationship,
        signature: signature.present ? signature.value : this.signature,
        bloodGroup: bloodGroup.present ? bloodGroup.value : this.bloodGroup,
        photo: photo.present ? photo.value : this.photo,
        identificationMark: identificationMark.present
            ? identificationMark.value
            : this.identificationMark,
        createdBy: createdBy.present ? createdBy.value : this.createdBy,
        lastModifiedBy:
            lastModifiedBy.present ? lastModifiedBy.value : this.lastModifiedBy,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        uuid: uuid.present ? uuid.value : this.uuid,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('UserData(')
          ..write('id: $id, ')
          ..write('userName: $userName, ')
          ..write('salutation: $salutation, ')
          ..write('name: $name, ')
          ..write('gender: $gender, ')
          ..write('mobileNumber: $mobileNumber, ')
          ..write('emailId: $emailId, ')
          ..write('altContactNumber: $altContactNumber, ')
          ..write('pan: $pan, ')
          ..write('aadhaarNumber: $aadhaarNumber, ')
          ..write('permanentAddress: $permanentAddress, ')
          ..write('permanentCity: $permanentCity, ')
          ..write('permanentPinCode: $permanentPinCode, ')
          ..write('correspondenceAddress: $correspondenceAddress, ')
          ..write('correspondenceCity: $correspondenceCity, ')
          ..write('correspondencePinCode: $correspondencePinCode, ')
          ..write('alternatemobilenumber: $alternatemobilenumber, ')
          ..write('active: $active, ')
          ..write('locale: $locale, ')
          ..write('type: $type, ')
          ..write('accountLocked: $accountLocked, ')
          ..write('accountLockedDate: $accountLockedDate, ')
          ..write('fatherOrHusbandName: $fatherOrHusbandName, ')
          ..write('relationship: $relationship, ')
          ..write('signature: $signature, ')
          ..write('bloodGroup: $bloodGroup, ')
          ..write('photo: $photo, ')
          ..write('identificationMark: $identificationMark, ')
          ..write('createdBy: $createdBy, ')
          ..write('lastModifiedBy: $lastModifiedBy, ')
          ..write('tenantId: $tenantId, ')
          ..write('uuid: $uuid, ')
          ..write('createdDate: $createdDate, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        userName,
        salutation,
        name,
        gender,
        mobileNumber,
        emailId,
        altContactNumber,
        pan,
        aadhaarNumber,
        permanentAddress,
        permanentCity,
        permanentPinCode,
        correspondenceAddress,
        correspondenceCity,
        correspondencePinCode,
        alternatemobilenumber,
        active,
        locale,
        type,
        accountLocked,
        accountLockedDate,
        fatherOrHusbandName,
        relationship,
        signature,
        bloodGroup,
        photo,
        identificationMark,
        createdBy,
        lastModifiedBy,
        tenantId,
        uuid,
        createdDate,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        isDeleted,
        rowVersion,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserData &&
          other.id == this.id &&
          other.userName == this.userName &&
          other.salutation == this.salutation &&
          other.name == this.name &&
          other.gender == this.gender &&
          other.mobileNumber == this.mobileNumber &&
          other.emailId == this.emailId &&
          other.altContactNumber == this.altContactNumber &&
          other.pan == this.pan &&
          other.aadhaarNumber == this.aadhaarNumber &&
          other.permanentAddress == this.permanentAddress &&
          other.permanentCity == this.permanentCity &&
          other.permanentPinCode == this.permanentPinCode &&
          other.correspondenceAddress == this.correspondenceAddress &&
          other.correspondenceCity == this.correspondenceCity &&
          other.correspondencePinCode == this.correspondencePinCode &&
          other.alternatemobilenumber == this.alternatemobilenumber &&
          other.active == this.active &&
          other.locale == this.locale &&
          other.type == this.type &&
          other.accountLocked == this.accountLocked &&
          other.accountLockedDate == this.accountLockedDate &&
          other.fatherOrHusbandName == this.fatherOrHusbandName &&
          other.relationship == this.relationship &&
          other.signature == this.signature &&
          other.bloodGroup == this.bloodGroup &&
          other.photo == this.photo &&
          other.identificationMark == this.identificationMark &&
          other.createdBy == this.createdBy &&
          other.lastModifiedBy == this.lastModifiedBy &&
          other.tenantId == this.tenantId &&
          other.uuid == this.uuid &&
          other.createdDate == this.createdDate &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class UserCompanion extends UpdateCompanion<UserData> {
  final Value<String?> id;
  final Value<String?> userName;
  final Value<String?> salutation;
  final Value<String?> name;
  final Value<String?> gender;
  final Value<String?> mobileNumber;
  final Value<String?> emailId;
  final Value<String?> altContactNumber;
  final Value<String?> pan;
  final Value<String?> aadhaarNumber;
  final Value<String?> permanentAddress;
  final Value<String?> permanentCity;
  final Value<String?> permanentPinCode;
  final Value<String?> correspondenceAddress;
  final Value<String?> correspondenceCity;
  final Value<String?> correspondencePinCode;
  final Value<String?> alternatemobilenumber;
  final Value<bool?> active;
  final Value<String?> locale;
  final Value<String?> type;
  final Value<bool?> accountLocked;
  final Value<int?> accountLockedDate;
  final Value<String?> fatherOrHusbandName;
  final Value<String?> relationship;
  final Value<String?> signature;
  final Value<String?> bloodGroup;
  final Value<String?> photo;
  final Value<String?> identificationMark;
  final Value<int?> createdBy;
  final Value<String?> lastModifiedBy;
  final Value<String?> tenantId;
  final Value<String?> uuid;
  final Value<String?> createdDate;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const UserCompanion({
    this.id = const Value.absent(),
    this.userName = const Value.absent(),
    this.salutation = const Value.absent(),
    this.name = const Value.absent(),
    this.gender = const Value.absent(),
    this.mobileNumber = const Value.absent(),
    this.emailId = const Value.absent(),
    this.altContactNumber = const Value.absent(),
    this.pan = const Value.absent(),
    this.aadhaarNumber = const Value.absent(),
    this.permanentAddress = const Value.absent(),
    this.permanentCity = const Value.absent(),
    this.permanentPinCode = const Value.absent(),
    this.correspondenceAddress = const Value.absent(),
    this.correspondenceCity = const Value.absent(),
    this.correspondencePinCode = const Value.absent(),
    this.alternatemobilenumber = const Value.absent(),
    this.active = const Value.absent(),
    this.locale = const Value.absent(),
    this.type = const Value.absent(),
    this.accountLocked = const Value.absent(),
    this.accountLockedDate = const Value.absent(),
    this.fatherOrHusbandName = const Value.absent(),
    this.relationship = const Value.absent(),
    this.signature = const Value.absent(),
    this.bloodGroup = const Value.absent(),
    this.photo = const Value.absent(),
    this.identificationMark = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.lastModifiedBy = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.uuid = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserCompanion.insert({
    this.id = const Value.absent(),
    this.userName = const Value.absent(),
    this.salutation = const Value.absent(),
    this.name = const Value.absent(),
    this.gender = const Value.absent(),
    this.mobileNumber = const Value.absent(),
    this.emailId = const Value.absent(),
    this.altContactNumber = const Value.absent(),
    this.pan = const Value.absent(),
    this.aadhaarNumber = const Value.absent(),
    this.permanentAddress = const Value.absent(),
    this.permanentCity = const Value.absent(),
    this.permanentPinCode = const Value.absent(),
    this.correspondenceAddress = const Value.absent(),
    this.correspondenceCity = const Value.absent(),
    this.correspondencePinCode = const Value.absent(),
    this.alternatemobilenumber = const Value.absent(),
    this.active = const Value.absent(),
    this.locale = const Value.absent(),
    this.type = const Value.absent(),
    this.accountLocked = const Value.absent(),
    this.accountLockedDate = const Value.absent(),
    this.fatherOrHusbandName = const Value.absent(),
    this.relationship = const Value.absent(),
    this.signature = const Value.absent(),
    this.bloodGroup = const Value.absent(),
    this.photo = const Value.absent(),
    this.identificationMark = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.lastModifiedBy = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.uuid = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<UserData> custom({
    Expression<String>? id,
    Expression<String>? userName,
    Expression<String>? salutation,
    Expression<String>? name,
    Expression<String>? gender,
    Expression<String>? mobileNumber,
    Expression<String>? emailId,
    Expression<String>? altContactNumber,
    Expression<String>? pan,
    Expression<String>? aadhaarNumber,
    Expression<String>? permanentAddress,
    Expression<String>? permanentCity,
    Expression<String>? permanentPinCode,
    Expression<String>? correspondenceAddress,
    Expression<String>? correspondenceCity,
    Expression<String>? correspondencePinCode,
    Expression<String>? alternatemobilenumber,
    Expression<bool>? active,
    Expression<String>? locale,
    Expression<String>? type,
    Expression<bool>? accountLocked,
    Expression<int>? accountLockedDate,
    Expression<String>? fatherOrHusbandName,
    Expression<String>? relationship,
    Expression<String>? signature,
    Expression<String>? bloodGroup,
    Expression<String>? photo,
    Expression<String>? identificationMark,
    Expression<int>? createdBy,
    Expression<String>? lastModifiedBy,
    Expression<String>? tenantId,
    Expression<String>? uuid,
    Expression<String>? createdDate,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userName != null) 'user_name': userName,
      if (salutation != null) 'salutation': salutation,
      if (name != null) 'name': name,
      if (gender != null) 'gender': gender,
      if (mobileNumber != null) 'mobile_number': mobileNumber,
      if (emailId != null) 'email_id': emailId,
      if (altContactNumber != null) 'alt_contact_number': altContactNumber,
      if (pan != null) 'pan': pan,
      if (aadhaarNumber != null) 'aadhaar_number': aadhaarNumber,
      if (permanentAddress != null) 'permanent_address': permanentAddress,
      if (permanentCity != null) 'permanent_city': permanentCity,
      if (permanentPinCode != null) 'permanent_pin_code': permanentPinCode,
      if (correspondenceAddress != null)
        'correspondence_address': correspondenceAddress,
      if (correspondenceCity != null) 'correspondence_city': correspondenceCity,
      if (correspondencePinCode != null)
        'correspondence_pin_code': correspondencePinCode,
      if (alternatemobilenumber != null)
        'alternatemobilenumber': alternatemobilenumber,
      if (active != null) 'active': active,
      if (locale != null) 'locale': locale,
      if (type != null) 'type': type,
      if (accountLocked != null) 'account_locked': accountLocked,
      if (accountLockedDate != null) 'account_locked_date': accountLockedDate,
      if (fatherOrHusbandName != null)
        'father_or_husband_name': fatherOrHusbandName,
      if (relationship != null) 'relationship': relationship,
      if (signature != null) 'signature': signature,
      if (bloodGroup != null) 'blood_group': bloodGroup,
      if (photo != null) 'photo': photo,
      if (identificationMark != null) 'identification_mark': identificationMark,
      if (createdBy != null) 'created_by': createdBy,
      if (lastModifiedBy != null) 'last_modified_by': lastModifiedBy,
      if (tenantId != null) 'tenant_id': tenantId,
      if (uuid != null) 'uuid': uuid,
      if (createdDate != null) 'created_date': createdDate,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? userName,
      Value<String?>? salutation,
      Value<String?>? name,
      Value<String?>? gender,
      Value<String?>? mobileNumber,
      Value<String?>? emailId,
      Value<String?>? altContactNumber,
      Value<String?>? pan,
      Value<String?>? aadhaarNumber,
      Value<String?>? permanentAddress,
      Value<String?>? permanentCity,
      Value<String?>? permanentPinCode,
      Value<String?>? correspondenceAddress,
      Value<String?>? correspondenceCity,
      Value<String?>? correspondencePinCode,
      Value<String?>? alternatemobilenumber,
      Value<bool?>? active,
      Value<String?>? locale,
      Value<String?>? type,
      Value<bool?>? accountLocked,
      Value<int?>? accountLockedDate,
      Value<String?>? fatherOrHusbandName,
      Value<String?>? relationship,
      Value<String?>? signature,
      Value<String?>? bloodGroup,
      Value<String?>? photo,
      Value<String?>? identificationMark,
      Value<int?>? createdBy,
      Value<String?>? lastModifiedBy,
      Value<String?>? tenantId,
      Value<String?>? uuid,
      Value<String?>? createdDate,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return UserCompanion(
      id: id ?? this.id,
      userName: userName ?? this.userName,
      salutation: salutation ?? this.salutation,
      name: name ?? this.name,
      gender: gender ?? this.gender,
      mobileNumber: mobileNumber ?? this.mobileNumber,
      emailId: emailId ?? this.emailId,
      altContactNumber: altContactNumber ?? this.altContactNumber,
      pan: pan ?? this.pan,
      aadhaarNumber: aadhaarNumber ?? this.aadhaarNumber,
      permanentAddress: permanentAddress ?? this.permanentAddress,
      permanentCity: permanentCity ?? this.permanentCity,
      permanentPinCode: permanentPinCode ?? this.permanentPinCode,
      correspondenceAddress:
          correspondenceAddress ?? this.correspondenceAddress,
      correspondenceCity: correspondenceCity ?? this.correspondenceCity,
      correspondencePinCode:
          correspondencePinCode ?? this.correspondencePinCode,
      alternatemobilenumber:
          alternatemobilenumber ?? this.alternatemobilenumber,
      active: active ?? this.active,
      locale: locale ?? this.locale,
      type: type ?? this.type,
      accountLocked: accountLocked ?? this.accountLocked,
      accountLockedDate: accountLockedDate ?? this.accountLockedDate,
      fatherOrHusbandName: fatherOrHusbandName ?? this.fatherOrHusbandName,
      relationship: relationship ?? this.relationship,
      signature: signature ?? this.signature,
      bloodGroup: bloodGroup ?? this.bloodGroup,
      photo: photo ?? this.photo,
      identificationMark: identificationMark ?? this.identificationMark,
      createdBy: createdBy ?? this.createdBy,
      lastModifiedBy: lastModifiedBy ?? this.lastModifiedBy,
      tenantId: tenantId ?? this.tenantId,
      uuid: uuid ?? this.uuid,
      createdDate: createdDate ?? this.createdDate,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (salutation.present) {
      map['salutation'] = Variable<String>(salutation.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (gender.present) {
      map['gender'] = Variable<String>(gender.value);
    }
    if (mobileNumber.present) {
      map['mobile_number'] = Variable<String>(mobileNumber.value);
    }
    if (emailId.present) {
      map['email_id'] = Variable<String>(emailId.value);
    }
    if (altContactNumber.present) {
      map['alt_contact_number'] = Variable<String>(altContactNumber.value);
    }
    if (pan.present) {
      map['pan'] = Variable<String>(pan.value);
    }
    if (aadhaarNumber.present) {
      map['aadhaar_number'] = Variable<String>(aadhaarNumber.value);
    }
    if (permanentAddress.present) {
      map['permanent_address'] = Variable<String>(permanentAddress.value);
    }
    if (permanentCity.present) {
      map['permanent_city'] = Variable<String>(permanentCity.value);
    }
    if (permanentPinCode.present) {
      map['permanent_pin_code'] = Variable<String>(permanentPinCode.value);
    }
    if (correspondenceAddress.present) {
      map['correspondence_address'] =
          Variable<String>(correspondenceAddress.value);
    }
    if (correspondenceCity.present) {
      map['correspondence_city'] = Variable<String>(correspondenceCity.value);
    }
    if (correspondencePinCode.present) {
      map['correspondence_pin_code'] =
          Variable<String>(correspondencePinCode.value);
    }
    if (alternatemobilenumber.present) {
      map['alternatemobilenumber'] =
          Variable<String>(alternatemobilenumber.value);
    }
    if (active.present) {
      map['active'] = Variable<bool>(active.value);
    }
    if (locale.present) {
      map['locale'] = Variable<String>(locale.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (accountLocked.present) {
      map['account_locked'] = Variable<bool>(accountLocked.value);
    }
    if (accountLockedDate.present) {
      map['account_locked_date'] = Variable<int>(accountLockedDate.value);
    }
    if (fatherOrHusbandName.present) {
      map['father_or_husband_name'] =
          Variable<String>(fatherOrHusbandName.value);
    }
    if (relationship.present) {
      map['relationship'] = Variable<String>(relationship.value);
    }
    if (signature.present) {
      map['signature'] = Variable<String>(signature.value);
    }
    if (bloodGroup.present) {
      map['blood_group'] = Variable<String>(bloodGroup.value);
    }
    if (photo.present) {
      map['photo'] = Variable<String>(photo.value);
    }
    if (identificationMark.present) {
      map['identification_mark'] = Variable<String>(identificationMark.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<int>(createdBy.value);
    }
    if (lastModifiedBy.present) {
      map['last_modified_by'] = Variable<String>(lastModifiedBy.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<String>(createdDate.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserCompanion(')
          ..write('id: $id, ')
          ..write('userName: $userName, ')
          ..write('salutation: $salutation, ')
          ..write('name: $name, ')
          ..write('gender: $gender, ')
          ..write('mobileNumber: $mobileNumber, ')
          ..write('emailId: $emailId, ')
          ..write('altContactNumber: $altContactNumber, ')
          ..write('pan: $pan, ')
          ..write('aadhaarNumber: $aadhaarNumber, ')
          ..write('permanentAddress: $permanentAddress, ')
          ..write('permanentCity: $permanentCity, ')
          ..write('permanentPinCode: $permanentPinCode, ')
          ..write('correspondenceAddress: $correspondenceAddress, ')
          ..write('correspondenceCity: $correspondenceCity, ')
          ..write('correspondencePinCode: $correspondencePinCode, ')
          ..write('alternatemobilenumber: $alternatemobilenumber, ')
          ..write('active: $active, ')
          ..write('locale: $locale, ')
          ..write('type: $type, ')
          ..write('accountLocked: $accountLocked, ')
          ..write('accountLockedDate: $accountLockedDate, ')
          ..write('fatherOrHusbandName: $fatherOrHusbandName, ')
          ..write('relationship: $relationship, ')
          ..write('signature: $signature, ')
          ..write('bloodGroup: $bloodGroup, ')
          ..write('photo: $photo, ')
          ..write('identificationMark: $identificationMark, ')
          ..write('createdBy: $createdBy, ')
          ..write('lastModifiedBy: $lastModifiedBy, ')
          ..write('tenantId: $tenantId, ')
          ..write('uuid: $uuid, ')
          ..write('createdDate: $createdDate, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DownsyncTable extends Downsync
    with TableInfo<$DownsyncTable, DownsyncData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DownsyncTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _localityMeta =
      const VerificationMeta('locality');
  @override
  late final GeneratedColumn<String> locality = GeneratedColumn<String>(
      'locality', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _offsetMeta = const VerificationMeta('offset');
  @override
  late final GeneratedColumn<int> offset = GeneratedColumn<int>(
      'offset', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _limitMeta = const VerificationMeta('limit');
  @override
  late final GeneratedColumn<int> limit = GeneratedColumn<int>(
      'limit', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _lastSyncedTimeMeta =
      const VerificationMeta('lastSyncedTime');
  @override
  late final GeneratedColumn<int> lastSyncedTime = GeneratedColumn<int>(
      'last_synced_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _totalCountMeta =
      const VerificationMeta('totalCount');
  @override
  late final GeneratedColumn<int> totalCount = GeneratedColumn<int>(
      'total_count', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _boundaryNameMeta =
      const VerificationMeta('boundaryName');
  @override
  late final GeneratedColumn<String> boundaryName = GeneratedColumn<String>(
      'boundary_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        locality,
        projectId,
        offset,
        limit,
        lastSyncedTime,
        totalCount,
        boundaryName,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'downsync';
  @override
  VerificationContext validateIntegrity(Insertable<DownsyncData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('locality')) {
      context.handle(_localityMeta,
          locality.isAcceptableOrUnknown(data['locality']!, _localityMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('offset')) {
      context.handle(_offsetMeta,
          offset.isAcceptableOrUnknown(data['offset']!, _offsetMeta));
    }
    if (data.containsKey('limit')) {
      context.handle(
          _limitMeta, limit.isAcceptableOrUnknown(data['limit']!, _limitMeta));
    }
    if (data.containsKey('last_synced_time')) {
      context.handle(
          _lastSyncedTimeMeta,
          lastSyncedTime.isAcceptableOrUnknown(
              data['last_synced_time']!, _lastSyncedTimeMeta));
    }
    if (data.containsKey('total_count')) {
      context.handle(
          _totalCountMeta,
          totalCount.isAcceptableOrUnknown(
              data['total_count']!, _totalCountMeta));
    }
    if (data.containsKey('boundary_name')) {
      context.handle(
          _boundaryNameMeta,
          boundaryName.isAcceptableOrUnknown(
              data['boundary_name']!, _boundaryNameMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {locality, auditCreatedBy};
  @override
  DownsyncData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DownsyncData(
      locality: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}locality']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      offset: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}offset']),
      limit: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}limit']),
      lastSyncedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}last_synced_time']),
      totalCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}total_count']),
      boundaryName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}boundary_name']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $DownsyncTable createAlias(String alias) {
    return $DownsyncTable(attachedDatabase, alias);
  }
}

class DownsyncData extends DataClass implements Insertable<DownsyncData> {
  final String? locality;
  final String? projectId;
  final int? offset;
  final int? limit;
  final int? lastSyncedTime;
  final int? totalCount;
  final String? boundaryName;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const DownsyncData(
      {this.locality,
      this.projectId,
      this.offset,
      this.limit,
      this.lastSyncedTime,
      this.totalCount,
      this.boundaryName,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || locality != null) {
      map['locality'] = Variable<String>(locality);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || offset != null) {
      map['offset'] = Variable<int>(offset);
    }
    if (!nullToAbsent || limit != null) {
      map['limit'] = Variable<int>(limit);
    }
    if (!nullToAbsent || lastSyncedTime != null) {
      map['last_synced_time'] = Variable<int>(lastSyncedTime);
    }
    if (!nullToAbsent || totalCount != null) {
      map['total_count'] = Variable<int>(totalCount);
    }
    if (!nullToAbsent || boundaryName != null) {
      map['boundary_name'] = Variable<String>(boundaryName);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  DownsyncCompanion toCompanion(bool nullToAbsent) {
    return DownsyncCompanion(
      locality: locality == null && nullToAbsent
          ? const Value.absent()
          : Value(locality),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      offset:
          offset == null && nullToAbsent ? const Value.absent() : Value(offset),
      limit:
          limit == null && nullToAbsent ? const Value.absent() : Value(limit),
      lastSyncedTime: lastSyncedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncedTime),
      totalCount: totalCount == null && nullToAbsent
          ? const Value.absent()
          : Value(totalCount),
      boundaryName: boundaryName == null && nullToAbsent
          ? const Value.absent()
          : Value(boundaryName),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory DownsyncData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DownsyncData(
      locality: serializer.fromJson<String?>(json['locality']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      offset: serializer.fromJson<int?>(json['offset']),
      limit: serializer.fromJson<int?>(json['limit']),
      lastSyncedTime: serializer.fromJson<int?>(json['lastSyncedTime']),
      totalCount: serializer.fromJson<int?>(json['totalCount']),
      boundaryName: serializer.fromJson<String?>(json['boundaryName']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'locality': serializer.toJson<String?>(locality),
      'projectId': serializer.toJson<String?>(projectId),
      'offset': serializer.toJson<int?>(offset),
      'limit': serializer.toJson<int?>(limit),
      'lastSyncedTime': serializer.toJson<int?>(lastSyncedTime),
      'totalCount': serializer.toJson<int?>(totalCount),
      'boundaryName': serializer.toJson<String?>(boundaryName),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  DownsyncData copyWith(
          {Value<String?> locality = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<int?> offset = const Value.absent(),
          Value<int?> limit = const Value.absent(),
          Value<int?> lastSyncedTime = const Value.absent(),
          Value<int?> totalCount = const Value.absent(),
          Value<String?> boundaryName = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      DownsyncData(
        locality: locality.present ? locality.value : this.locality,
        projectId: projectId.present ? projectId.value : this.projectId,
        offset: offset.present ? offset.value : this.offset,
        limit: limit.present ? limit.value : this.limit,
        lastSyncedTime:
            lastSyncedTime.present ? lastSyncedTime.value : this.lastSyncedTime,
        totalCount: totalCount.present ? totalCount.value : this.totalCount,
        boundaryName:
            boundaryName.present ? boundaryName.value : this.boundaryName,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('DownsyncData(')
          ..write('locality: $locality, ')
          ..write('projectId: $projectId, ')
          ..write('offset: $offset, ')
          ..write('limit: $limit, ')
          ..write('lastSyncedTime: $lastSyncedTime, ')
          ..write('totalCount: $totalCount, ')
          ..write('boundaryName: $boundaryName, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      locality,
      projectId,
      offset,
      limit,
      lastSyncedTime,
      totalCount,
      boundaryName,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DownsyncData &&
          other.locality == this.locality &&
          other.projectId == this.projectId &&
          other.offset == this.offset &&
          other.limit == this.limit &&
          other.lastSyncedTime == this.lastSyncedTime &&
          other.totalCount == this.totalCount &&
          other.boundaryName == this.boundaryName &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class DownsyncCompanion extends UpdateCompanion<DownsyncData> {
  final Value<String?> locality;
  final Value<String?> projectId;
  final Value<int?> offset;
  final Value<int?> limit;
  final Value<int?> lastSyncedTime;
  final Value<int?> totalCount;
  final Value<String?> boundaryName;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const DownsyncCompanion({
    this.locality = const Value.absent(),
    this.projectId = const Value.absent(),
    this.offset = const Value.absent(),
    this.limit = const Value.absent(),
    this.lastSyncedTime = const Value.absent(),
    this.totalCount = const Value.absent(),
    this.boundaryName = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DownsyncCompanion.insert({
    this.locality = const Value.absent(),
    this.projectId = const Value.absent(),
    this.offset = const Value.absent(),
    this.limit = const Value.absent(),
    this.lastSyncedTime = const Value.absent(),
    this.totalCount = const Value.absent(),
    this.boundaryName = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<DownsyncData> custom({
    Expression<String>? locality,
    Expression<String>? projectId,
    Expression<int>? offset,
    Expression<int>? limit,
    Expression<int>? lastSyncedTime,
    Expression<int>? totalCount,
    Expression<String>? boundaryName,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (locality != null) 'locality': locality,
      if (projectId != null) 'project_id': projectId,
      if (offset != null) 'offset': offset,
      if (limit != null) 'limit': limit,
      if (lastSyncedTime != null) 'last_synced_time': lastSyncedTime,
      if (totalCount != null) 'total_count': totalCount,
      if (boundaryName != null) 'boundary_name': boundaryName,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DownsyncCompanion copyWith(
      {Value<String?>? locality,
      Value<String?>? projectId,
      Value<int?>? offset,
      Value<int?>? limit,
      Value<int?>? lastSyncedTime,
      Value<int?>? totalCount,
      Value<String?>? boundaryName,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return DownsyncCompanion(
      locality: locality ?? this.locality,
      projectId: projectId ?? this.projectId,
      offset: offset ?? this.offset,
      limit: limit ?? this.limit,
      lastSyncedTime: lastSyncedTime ?? this.lastSyncedTime,
      totalCount: totalCount ?? this.totalCount,
      boundaryName: boundaryName ?? this.boundaryName,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (locality.present) {
      map['locality'] = Variable<String>(locality.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (offset.present) {
      map['offset'] = Variable<int>(offset.value);
    }
    if (limit.present) {
      map['limit'] = Variable<int>(limit.value);
    }
    if (lastSyncedTime.present) {
      map['last_synced_time'] = Variable<int>(lastSyncedTime.value);
    }
    if (totalCount.present) {
      map['total_count'] = Variable<int>(totalCount.value);
    }
    if (boundaryName.present) {
      map['boundary_name'] = Variable<String>(boundaryName.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DownsyncCompanion(')
          ..write('locality: $locality, ')
          ..write('projectId: $projectId, ')
          ..write('offset: $offset, ')
          ..write('limit: $limit, ')
          ..write('lastSyncedTime: $lastSyncedTime, ')
          ..write('totalCount: $totalCount, ')
          ..write('boundaryName: $boundaryName, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DownsyncCriteriaTable extends DownsyncCriteria
    with TableInfo<$DownsyncCriteriaTable, DownsyncCriteriaData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DownsyncCriteriaTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _localityMeta =
      const VerificationMeta('locality');
  @override
  late final GeneratedColumn<String> locality = GeneratedColumn<String>(
      'locality', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _offsetMeta = const VerificationMeta('offset');
  @override
  late final GeneratedColumn<int> offset = GeneratedColumn<int>(
      'offset', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _limitMeta = const VerificationMeta('limit');
  @override
  late final GeneratedColumn<int> limit = GeneratedColumn<int>(
      'limit', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastSyncedTimeMeta =
      const VerificationMeta('lastSyncedTime');
  @override
  late final GeneratedColumn<int> lastSyncedTime = GeneratedColumn<int>(
      'last_synced_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _totalCountMeta =
      const VerificationMeta('totalCount');
  @override
  late final GeneratedColumn<int> totalCount = GeneratedColumn<int>(
      'total_count', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        locality,
        tenantId,
        offset,
        limit,
        projectId,
        lastSyncedTime,
        totalCount,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'downsync_criteria';
  @override
  VerificationContext validateIntegrity(
      Insertable<DownsyncCriteriaData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('locality')) {
      context.handle(_localityMeta,
          locality.isAcceptableOrUnknown(data['locality']!, _localityMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('offset')) {
      context.handle(_offsetMeta,
          offset.isAcceptableOrUnknown(data['offset']!, _offsetMeta));
    }
    if (data.containsKey('limit')) {
      context.handle(
          _limitMeta, limit.isAcceptableOrUnknown(data['limit']!, _limitMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('last_synced_time')) {
      context.handle(
          _lastSyncedTimeMeta,
          lastSyncedTime.isAcceptableOrUnknown(
              data['last_synced_time']!, _lastSyncedTimeMeta));
    }
    if (data.containsKey('total_count')) {
      context.handle(
          _totalCountMeta,
          totalCount.isAcceptableOrUnknown(
              data['total_count']!, _totalCountMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  DownsyncCriteriaData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DownsyncCriteriaData(
      locality: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}locality']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      offset: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}offset']),
      limit: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}limit']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      lastSyncedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}last_synced_time']),
      totalCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}total_count']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $DownsyncCriteriaTable createAlias(String alias) {
    return $DownsyncCriteriaTable(attachedDatabase, alias);
  }
}

class DownsyncCriteriaData extends DataClass
    implements Insertable<DownsyncCriteriaData> {
  final String? locality;
  final String? tenantId;
  final int? offset;
  final int? limit;
  final String? projectId;
  final int? lastSyncedTime;
  final int? totalCount;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const DownsyncCriteriaData(
      {this.locality,
      this.tenantId,
      this.offset,
      this.limit,
      this.projectId,
      this.lastSyncedTime,
      this.totalCount,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || locality != null) {
      map['locality'] = Variable<String>(locality);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || offset != null) {
      map['offset'] = Variable<int>(offset);
    }
    if (!nullToAbsent || limit != null) {
      map['limit'] = Variable<int>(limit);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || lastSyncedTime != null) {
      map['last_synced_time'] = Variable<int>(lastSyncedTime);
    }
    if (!nullToAbsent || totalCount != null) {
      map['total_count'] = Variable<int>(totalCount);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  DownsyncCriteriaCompanion toCompanion(bool nullToAbsent) {
    return DownsyncCriteriaCompanion(
      locality: locality == null && nullToAbsent
          ? const Value.absent()
          : Value(locality),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      offset:
          offset == null && nullToAbsent ? const Value.absent() : Value(offset),
      limit:
          limit == null && nullToAbsent ? const Value.absent() : Value(limit),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      lastSyncedTime: lastSyncedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncedTime),
      totalCount: totalCount == null && nullToAbsent
          ? const Value.absent()
          : Value(totalCount),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory DownsyncCriteriaData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DownsyncCriteriaData(
      locality: serializer.fromJson<String?>(json['locality']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      offset: serializer.fromJson<int?>(json['offset']),
      limit: serializer.fromJson<int?>(json['limit']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      lastSyncedTime: serializer.fromJson<int?>(json['lastSyncedTime']),
      totalCount: serializer.fromJson<int?>(json['totalCount']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'locality': serializer.toJson<String?>(locality),
      'tenantId': serializer.toJson<String?>(tenantId),
      'offset': serializer.toJson<int?>(offset),
      'limit': serializer.toJson<int?>(limit),
      'projectId': serializer.toJson<String?>(projectId),
      'lastSyncedTime': serializer.toJson<int?>(lastSyncedTime),
      'totalCount': serializer.toJson<int?>(totalCount),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  DownsyncCriteriaData copyWith(
          {Value<String?> locality = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<int?> offset = const Value.absent(),
          Value<int?> limit = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<int?> lastSyncedTime = const Value.absent(),
          Value<int?> totalCount = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      DownsyncCriteriaData(
        locality: locality.present ? locality.value : this.locality,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        offset: offset.present ? offset.value : this.offset,
        limit: limit.present ? limit.value : this.limit,
        projectId: projectId.present ? projectId.value : this.projectId,
        lastSyncedTime:
            lastSyncedTime.present ? lastSyncedTime.value : this.lastSyncedTime,
        totalCount: totalCount.present ? totalCount.value : this.totalCount,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('DownsyncCriteriaData(')
          ..write('locality: $locality, ')
          ..write('tenantId: $tenantId, ')
          ..write('offset: $offset, ')
          ..write('limit: $limit, ')
          ..write('projectId: $projectId, ')
          ..write('lastSyncedTime: $lastSyncedTime, ')
          ..write('totalCount: $totalCount, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      locality,
      tenantId,
      offset,
      limit,
      projectId,
      lastSyncedTime,
      totalCount,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DownsyncCriteriaData &&
          other.locality == this.locality &&
          other.tenantId == this.tenantId &&
          other.offset == this.offset &&
          other.limit == this.limit &&
          other.projectId == this.projectId &&
          other.lastSyncedTime == this.lastSyncedTime &&
          other.totalCount == this.totalCount &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class DownsyncCriteriaCompanion extends UpdateCompanion<DownsyncCriteriaData> {
  final Value<String?> locality;
  final Value<String?> tenantId;
  final Value<int?> offset;
  final Value<int?> limit;
  final Value<String?> projectId;
  final Value<int?> lastSyncedTime;
  final Value<int?> totalCount;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const DownsyncCriteriaCompanion({
    this.locality = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.offset = const Value.absent(),
    this.limit = const Value.absent(),
    this.projectId = const Value.absent(),
    this.lastSyncedTime = const Value.absent(),
    this.totalCount = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DownsyncCriteriaCompanion.insert({
    this.locality = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.offset = const Value.absent(),
    this.limit = const Value.absent(),
    this.projectId = const Value.absent(),
    this.lastSyncedTime = const Value.absent(),
    this.totalCount = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<DownsyncCriteriaData> custom({
    Expression<String>? locality,
    Expression<String>? tenantId,
    Expression<int>? offset,
    Expression<int>? limit,
    Expression<String>? projectId,
    Expression<int>? lastSyncedTime,
    Expression<int>? totalCount,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (locality != null) 'locality': locality,
      if (tenantId != null) 'tenant_id': tenantId,
      if (offset != null) 'offset': offset,
      if (limit != null) 'limit': limit,
      if (projectId != null) 'project_id': projectId,
      if (lastSyncedTime != null) 'last_synced_time': lastSyncedTime,
      if (totalCount != null) 'total_count': totalCount,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DownsyncCriteriaCompanion copyWith(
      {Value<String?>? locality,
      Value<String?>? tenantId,
      Value<int?>? offset,
      Value<int?>? limit,
      Value<String?>? projectId,
      Value<int?>? lastSyncedTime,
      Value<int?>? totalCount,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return DownsyncCriteriaCompanion(
      locality: locality ?? this.locality,
      tenantId: tenantId ?? this.tenantId,
      offset: offset ?? this.offset,
      limit: limit ?? this.limit,
      projectId: projectId ?? this.projectId,
      lastSyncedTime: lastSyncedTime ?? this.lastSyncedTime,
      totalCount: totalCount ?? this.totalCount,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (locality.present) {
      map['locality'] = Variable<String>(locality.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (offset.present) {
      map['offset'] = Variable<int>(offset.value);
    }
    if (limit.present) {
      map['limit'] = Variable<int>(limit.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (lastSyncedTime.present) {
      map['last_synced_time'] = Variable<int>(lastSyncedTime.value);
    }
    if (totalCount.present) {
      map['total_count'] = Variable<int>(totalCount.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DownsyncCriteriaCompanion(')
          ..write('locality: $locality, ')
          ..write('tenantId: $tenantId, ')
          ..write('offset: $offset, ')
          ..write('limit: $limit, ')
          ..write('projectId: $projectId, ')
          ..write('lastSyncedTime: $lastSyncedTime, ')
          ..write('totalCount: $totalCount, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $HFReferralTable extends HFReferral
    with TableInfo<$HFReferralTable, HFReferralData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $HFReferralTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectFacilityIdMeta =
      const VerificationMeta('projectFacilityId');
  @override
  late final GeneratedColumn<String> projectFacilityId =
      GeneratedColumn<String>('project_facility_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _symptomSurveyIdMeta =
      const VerificationMeta('symptomSurveyId');
  @override
  late final GeneratedColumn<String> symptomSurveyId = GeneratedColumn<String>(
      'symptom_survey_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _beneficiaryIdMeta =
      const VerificationMeta('beneficiaryId');
  @override
  late final GeneratedColumn<String> beneficiaryId = GeneratedColumn<String>(
      'beneficiary_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referralCodeMeta =
      const VerificationMeta('referralCode');
  @override
  late final GeneratedColumn<String> referralCode = GeneratedColumn<String>(
      'referral_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nationalLevelIdMeta =
      const VerificationMeta('nationalLevelId');
  @override
  late final GeneratedColumn<String> nationalLevelId = GeneratedColumn<String>(
      'national_level_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _symptomMeta =
      const VerificationMeta('symptom');
  @override
  late final GeneratedColumn<String> symptom = GeneratedColumn<String>(
      'symptom', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        name,
        projectId,
        projectFacilityId,
        symptomSurveyId,
        beneficiaryId,
        referralCode,
        nationalLevelId,
        symptom,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'h_f_referral';
  @override
  VerificationContext validateIntegrity(Insertable<HFReferralData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('project_facility_id')) {
      context.handle(
          _projectFacilityIdMeta,
          projectFacilityId.isAcceptableOrUnknown(
              data['project_facility_id']!, _projectFacilityIdMeta));
    }
    if (data.containsKey('symptom_survey_id')) {
      context.handle(
          _symptomSurveyIdMeta,
          symptomSurveyId.isAcceptableOrUnknown(
              data['symptom_survey_id']!, _symptomSurveyIdMeta));
    }
    if (data.containsKey('beneficiary_id')) {
      context.handle(
          _beneficiaryIdMeta,
          beneficiaryId.isAcceptableOrUnknown(
              data['beneficiary_id']!, _beneficiaryIdMeta));
    }
    if (data.containsKey('referral_code')) {
      context.handle(
          _referralCodeMeta,
          referralCode.isAcceptableOrUnknown(
              data['referral_code']!, _referralCodeMeta));
    }
    if (data.containsKey('national_level_id')) {
      context.handle(
          _nationalLevelIdMeta,
          nationalLevelId.isAcceptableOrUnknown(
              data['national_level_id']!, _nationalLevelIdMeta));
    }
    if (data.containsKey('symptom')) {
      context.handle(_symptomMeta,
          symptom.isAcceptableOrUnknown(data['symptom']!, _symptomMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  HFReferralData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return HFReferralData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      projectFacilityId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}project_facility_id']),
      symptomSurveyId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}symptom_survey_id']),
      beneficiaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}beneficiary_id']),
      referralCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}referral_code']),
      nationalLevelId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}national_level_id']),
      symptom: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}symptom']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $HFReferralTable createAlias(String alias) {
    return $HFReferralTable(attachedDatabase, alias);
  }
}

class HFReferralData extends DataClass implements Insertable<HFReferralData> {
  final String? id;
  final String? tenantId;
  final String? name;
  final String? projectId;
  final String? projectFacilityId;
  final String? symptomSurveyId;
  final String? beneficiaryId;
  final String? referralCode;
  final String? nationalLevelId;
  final String? symptom;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const HFReferralData(
      {this.id,
      this.tenantId,
      this.name,
      this.projectId,
      this.projectFacilityId,
      this.symptomSurveyId,
      this.beneficiaryId,
      this.referralCode,
      this.nationalLevelId,
      this.symptom,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || projectFacilityId != null) {
      map['project_facility_id'] = Variable<String>(projectFacilityId);
    }
    if (!nullToAbsent || symptomSurveyId != null) {
      map['symptom_survey_id'] = Variable<String>(symptomSurveyId);
    }
    if (!nullToAbsent || beneficiaryId != null) {
      map['beneficiary_id'] = Variable<String>(beneficiaryId);
    }
    if (!nullToAbsent || referralCode != null) {
      map['referral_code'] = Variable<String>(referralCode);
    }
    if (!nullToAbsent || nationalLevelId != null) {
      map['national_level_id'] = Variable<String>(nationalLevelId);
    }
    if (!nullToAbsent || symptom != null) {
      map['symptom'] = Variable<String>(symptom);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  HFReferralCompanion toCompanion(bool nullToAbsent) {
    return HFReferralCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      projectFacilityId: projectFacilityId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectFacilityId),
      symptomSurveyId: symptomSurveyId == null && nullToAbsent
          ? const Value.absent()
          : Value(symptomSurveyId),
      beneficiaryId: beneficiaryId == null && nullToAbsent
          ? const Value.absent()
          : Value(beneficiaryId),
      referralCode: referralCode == null && nullToAbsent
          ? const Value.absent()
          : Value(referralCode),
      nationalLevelId: nationalLevelId == null && nullToAbsent
          ? const Value.absent()
          : Value(nationalLevelId),
      symptom: symptom == null && nullToAbsent
          ? const Value.absent()
          : Value(symptom),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory HFReferralData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return HFReferralData(
      id: serializer.fromJson<String?>(json['id']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      name: serializer.fromJson<String?>(json['name']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      projectFacilityId:
          serializer.fromJson<String?>(json['projectFacilityId']),
      symptomSurveyId: serializer.fromJson<String?>(json['symptomSurveyId']),
      beneficiaryId: serializer.fromJson<String?>(json['beneficiaryId']),
      referralCode: serializer.fromJson<String?>(json['referralCode']),
      nationalLevelId: serializer.fromJson<String?>(json['nationalLevelId']),
      symptom: serializer.fromJson<String?>(json['symptom']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'tenantId': serializer.toJson<String?>(tenantId),
      'name': serializer.toJson<String?>(name),
      'projectId': serializer.toJson<String?>(projectId),
      'projectFacilityId': serializer.toJson<String?>(projectFacilityId),
      'symptomSurveyId': serializer.toJson<String?>(symptomSurveyId),
      'beneficiaryId': serializer.toJson<String?>(beneficiaryId),
      'referralCode': serializer.toJson<String?>(referralCode),
      'nationalLevelId': serializer.toJson<String?>(nationalLevelId),
      'symptom': serializer.toJson<String?>(symptom),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  HFReferralData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> name = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> projectFacilityId = const Value.absent(),
          Value<String?> symptomSurveyId = const Value.absent(),
          Value<String?> beneficiaryId = const Value.absent(),
          Value<String?> referralCode = const Value.absent(),
          Value<String?> nationalLevelId = const Value.absent(),
          Value<String?> symptom = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      HFReferralData(
        id: id.present ? id.value : this.id,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        name: name.present ? name.value : this.name,
        projectId: projectId.present ? projectId.value : this.projectId,
        projectFacilityId: projectFacilityId.present
            ? projectFacilityId.value
            : this.projectFacilityId,
        symptomSurveyId: symptomSurveyId.present
            ? symptomSurveyId.value
            : this.symptomSurveyId,
        beneficiaryId:
            beneficiaryId.present ? beneficiaryId.value : this.beneficiaryId,
        referralCode:
            referralCode.present ? referralCode.value : this.referralCode,
        nationalLevelId: nationalLevelId.present
            ? nationalLevelId.value
            : this.nationalLevelId,
        symptom: symptom.present ? symptom.value : this.symptom,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('HFReferralData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('name: $name, ')
          ..write('projectId: $projectId, ')
          ..write('projectFacilityId: $projectFacilityId, ')
          ..write('symptomSurveyId: $symptomSurveyId, ')
          ..write('beneficiaryId: $beneficiaryId, ')
          ..write('referralCode: $referralCode, ')
          ..write('nationalLevelId: $nationalLevelId, ')
          ..write('symptom: $symptom, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        tenantId,
        name,
        projectId,
        projectFacilityId,
        symptomSurveyId,
        beneficiaryId,
        referralCode,
        nationalLevelId,
        symptom,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        isDeleted,
        rowVersion,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is HFReferralData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.name == this.name &&
          other.projectId == this.projectId &&
          other.projectFacilityId == this.projectFacilityId &&
          other.symptomSurveyId == this.symptomSurveyId &&
          other.beneficiaryId == this.beneficiaryId &&
          other.referralCode == this.referralCode &&
          other.nationalLevelId == this.nationalLevelId &&
          other.symptom == this.symptom &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class HFReferralCompanion extends UpdateCompanion<HFReferralData> {
  final Value<String?> id;
  final Value<String?> tenantId;
  final Value<String?> name;
  final Value<String?> projectId;
  final Value<String?> projectFacilityId;
  final Value<String?> symptomSurveyId;
  final Value<String?> beneficiaryId;
  final Value<String?> referralCode;
  final Value<String?> nationalLevelId;
  final Value<String?> symptom;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const HFReferralCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.name = const Value.absent(),
    this.projectId = const Value.absent(),
    this.projectFacilityId = const Value.absent(),
    this.symptomSurveyId = const Value.absent(),
    this.beneficiaryId = const Value.absent(),
    this.referralCode = const Value.absent(),
    this.nationalLevelId = const Value.absent(),
    this.symptom = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  HFReferralCompanion.insert({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.name = const Value.absent(),
    this.projectId = const Value.absent(),
    this.projectFacilityId = const Value.absent(),
    this.symptomSurveyId = const Value.absent(),
    this.beneficiaryId = const Value.absent(),
    this.referralCode = const Value.absent(),
    this.nationalLevelId = const Value.absent(),
    this.symptom = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<HFReferralData> custom({
    Expression<String>? id,
    Expression<String>? tenantId,
    Expression<String>? name,
    Expression<String>? projectId,
    Expression<String>? projectFacilityId,
    Expression<String>? symptomSurveyId,
    Expression<String>? beneficiaryId,
    Expression<String>? referralCode,
    Expression<String>? nationalLevelId,
    Expression<String>? symptom,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (name != null) 'name': name,
      if (projectId != null) 'project_id': projectId,
      if (projectFacilityId != null) 'project_facility_id': projectFacilityId,
      if (symptomSurveyId != null) 'symptom_survey_id': symptomSurveyId,
      if (beneficiaryId != null) 'beneficiary_id': beneficiaryId,
      if (referralCode != null) 'referral_code': referralCode,
      if (nationalLevelId != null) 'national_level_id': nationalLevelId,
      if (symptom != null) 'symptom': symptom,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  HFReferralCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? tenantId,
      Value<String?>? name,
      Value<String?>? projectId,
      Value<String?>? projectFacilityId,
      Value<String?>? symptomSurveyId,
      Value<String?>? beneficiaryId,
      Value<String?>? referralCode,
      Value<String?>? nationalLevelId,
      Value<String?>? symptom,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return HFReferralCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      name: name ?? this.name,
      projectId: projectId ?? this.projectId,
      projectFacilityId: projectFacilityId ?? this.projectFacilityId,
      symptomSurveyId: symptomSurveyId ?? this.symptomSurveyId,
      beneficiaryId: beneficiaryId ?? this.beneficiaryId,
      referralCode: referralCode ?? this.referralCode,
      nationalLevelId: nationalLevelId ?? this.nationalLevelId,
      symptom: symptom ?? this.symptom,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (projectFacilityId.present) {
      map['project_facility_id'] = Variable<String>(projectFacilityId.value);
    }
    if (symptomSurveyId.present) {
      map['symptom_survey_id'] = Variable<String>(symptomSurveyId.value);
    }
    if (beneficiaryId.present) {
      map['beneficiary_id'] = Variable<String>(beneficiaryId.value);
    }
    if (referralCode.present) {
      map['referral_code'] = Variable<String>(referralCode.value);
    }
    if (nationalLevelId.present) {
      map['national_level_id'] = Variable<String>(nationalLevelId.value);
    }
    if (symptom.present) {
      map['symptom'] = Variable<String>(symptom.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('HFReferralCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('name: $name, ')
          ..write('projectId: $projectId, ')
          ..write('projectFacilityId: $projectFacilityId, ')
          ..write('symptomSurveyId: $symptomSurveyId, ')
          ..write('beneficiaryId: $beneficiaryId, ')
          ..write('referralCode: $referralCode, ')
          ..write('nationalLevelId: $nationalLevelId, ')
          ..write('symptom: $symptom, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $HouseholdTable extends Household
    with TableInfo<$HouseholdTable, HouseholdData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $HouseholdTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _memberCountMeta =
      const VerificationMeta('memberCount');
  @override
  late final GeneratedColumn<int> memberCount = GeneratedColumn<int>(
      'member_count', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
      'latitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
      'longitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        memberCount,
        latitude,
        longitude,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'household';
  @override
  VerificationContext validateIntegrity(Insertable<HouseholdData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('member_count')) {
      context.handle(
          _memberCountMeta,
          memberCount.isAcceptableOrUnknown(
              data['member_count']!, _memberCountMeta));
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  HouseholdData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return HouseholdData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      memberCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}member_count']),
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}latitude']),
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}longitude']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $HouseholdTable createAlias(String alias) {
    return $HouseholdTable(attachedDatabase, alias);
  }
}

class HouseholdData extends DataClass implements Insertable<HouseholdData> {
  final String? id;
  final int? memberCount;
  final double? latitude;
  final double? longitude;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const HouseholdData(
      {this.id,
      this.memberCount,
      this.latitude,
      this.longitude,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || memberCount != null) {
      map['member_count'] = Variable<int>(memberCount);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  HouseholdCompanion toCompanion(bool nullToAbsent) {
    return HouseholdCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      memberCount: memberCount == null && nullToAbsent
          ? const Value.absent()
          : Value(memberCount),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory HouseholdData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return HouseholdData(
      id: serializer.fromJson<String?>(json['id']),
      memberCount: serializer.fromJson<int?>(json['memberCount']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'memberCount': serializer.toJson<int?>(memberCount),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  HouseholdData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<int?> memberCount = const Value.absent(),
          Value<double?> latitude = const Value.absent(),
          Value<double?> longitude = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      HouseholdData(
        id: id.present ? id.value : this.id,
        memberCount: memberCount.present ? memberCount.value : this.memberCount,
        latitude: latitude.present ? latitude.value : this.latitude,
        longitude: longitude.present ? longitude.value : this.longitude,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('HouseholdData(')
          ..write('id: $id, ')
          ..write('memberCount: $memberCount, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      memberCount,
      latitude,
      longitude,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is HouseholdData &&
          other.id == this.id &&
          other.memberCount == this.memberCount &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class HouseholdCompanion extends UpdateCompanion<HouseholdData> {
  final Value<String?> id;
  final Value<int?> memberCount;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const HouseholdCompanion({
    this.id = const Value.absent(),
    this.memberCount = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  HouseholdCompanion.insert({
    this.id = const Value.absent(),
    this.memberCount = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<HouseholdData> custom({
    Expression<String>? id,
    Expression<int>? memberCount,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (memberCount != null) 'member_count': memberCount,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  HouseholdCompanion copyWith(
      {Value<String?>? id,
      Value<int?>? memberCount,
      Value<double?>? latitude,
      Value<double?>? longitude,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return HouseholdCompanion(
      id: id ?? this.id,
      memberCount: memberCount ?? this.memberCount,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (memberCount.present) {
      map['member_count'] = Variable<int>(memberCount.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('HouseholdCompanion(')
          ..write('id: $id, ')
          ..write('memberCount: $memberCount, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $HouseholdMemberTable extends HouseholdMember
    with TableInfo<$HouseholdMemberTable, HouseholdMemberData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $HouseholdMemberTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _householdIdMeta =
      const VerificationMeta('householdId');
  @override
  late final GeneratedColumn<String> householdId = GeneratedColumn<String>(
      'household_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _householdClientReferenceIdMeta =
      const VerificationMeta('householdClientReferenceId');
  @override
  late final GeneratedColumn<String> householdClientReferenceId =
      GeneratedColumn<String>(
          'household_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _individualIdMeta =
      const VerificationMeta('individualId');
  @override
  late final GeneratedColumn<String> individualId = GeneratedColumn<String>(
      'individual_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _individualClientReferenceIdMeta =
      const VerificationMeta('individualClientReferenceId');
  @override
  late final GeneratedColumn<String> individualClientReferenceId =
      GeneratedColumn<String>(
          'individual_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isHeadOfHouseholdMeta =
      const VerificationMeta('isHeadOfHousehold');
  @override
  late final GeneratedColumn<bool> isHeadOfHousehold = GeneratedColumn<bool>(
      'is_head_of_household', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_head_of_household" IN (0, 1))'));
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        householdId,
        householdClientReferenceId,
        individualId,
        individualClientReferenceId,
        isHeadOfHousehold,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'household_member';
  @override
  VerificationContext validateIntegrity(
      Insertable<HouseholdMemberData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('household_id')) {
      context.handle(
          _householdIdMeta,
          householdId.isAcceptableOrUnknown(
              data['household_id']!, _householdIdMeta));
    }
    if (data.containsKey('household_client_reference_id')) {
      context.handle(
          _householdClientReferenceIdMeta,
          householdClientReferenceId.isAcceptableOrUnknown(
              data['household_client_reference_id']!,
              _householdClientReferenceIdMeta));
    }
    if (data.containsKey('individual_id')) {
      context.handle(
          _individualIdMeta,
          individualId.isAcceptableOrUnknown(
              data['individual_id']!, _individualIdMeta));
    }
    if (data.containsKey('individual_client_reference_id')) {
      context.handle(
          _individualClientReferenceIdMeta,
          individualClientReferenceId.isAcceptableOrUnknown(
              data['individual_client_reference_id']!,
              _individualClientReferenceIdMeta));
    }
    if (data.containsKey('is_head_of_household')) {
      context.handle(
          _isHeadOfHouseholdMeta,
          isHeadOfHousehold.isAcceptableOrUnknown(
              data['is_head_of_household']!, _isHeadOfHouseholdMeta));
    } else if (isInserting) {
      context.missing(_isHeadOfHouseholdMeta);
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  HouseholdMemberData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return HouseholdMemberData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      householdId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}household_id']),
      householdClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}household_client_reference_id']),
      individualId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}individual_id']),
      individualClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}individual_client_reference_id']),
      isHeadOfHousehold: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}is_head_of_household'])!,
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $HouseholdMemberTable createAlias(String alias) {
    return $HouseholdMemberTable(attachedDatabase, alias);
  }
}

class HouseholdMemberData extends DataClass
    implements Insertable<HouseholdMemberData> {
  final String? id;
  final String? householdId;
  final String? householdClientReferenceId;
  final String? individualId;
  final String? individualClientReferenceId;
  final bool isHeadOfHousehold;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const HouseholdMemberData(
      {this.id,
      this.householdId,
      this.householdClientReferenceId,
      this.individualId,
      this.individualClientReferenceId,
      required this.isHeadOfHousehold,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || householdId != null) {
      map['household_id'] = Variable<String>(householdId);
    }
    if (!nullToAbsent || householdClientReferenceId != null) {
      map['household_client_reference_id'] =
          Variable<String>(householdClientReferenceId);
    }
    if (!nullToAbsent || individualId != null) {
      map['individual_id'] = Variable<String>(individualId);
    }
    if (!nullToAbsent || individualClientReferenceId != null) {
      map['individual_client_reference_id'] =
          Variable<String>(individualClientReferenceId);
    }
    map['is_head_of_household'] = Variable<bool>(isHeadOfHousehold);
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  HouseholdMemberCompanion toCompanion(bool nullToAbsent) {
    return HouseholdMemberCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      householdId: householdId == null && nullToAbsent
          ? const Value.absent()
          : Value(householdId),
      householdClientReferenceId:
          householdClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(householdClientReferenceId),
      individualId: individualId == null && nullToAbsent
          ? const Value.absent()
          : Value(individualId),
      individualClientReferenceId:
          individualClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(individualClientReferenceId),
      isHeadOfHousehold: Value(isHeadOfHousehold),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory HouseholdMemberData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return HouseholdMemberData(
      id: serializer.fromJson<String?>(json['id']),
      householdId: serializer.fromJson<String?>(json['householdId']),
      householdClientReferenceId:
          serializer.fromJson<String?>(json['householdClientReferenceId']),
      individualId: serializer.fromJson<String?>(json['individualId']),
      individualClientReferenceId:
          serializer.fromJson<String?>(json['individualClientReferenceId']),
      isHeadOfHousehold: serializer.fromJson<bool>(json['isHeadOfHousehold']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'householdId': serializer.toJson<String?>(householdId),
      'householdClientReferenceId':
          serializer.toJson<String?>(householdClientReferenceId),
      'individualId': serializer.toJson<String?>(individualId),
      'individualClientReferenceId':
          serializer.toJson<String?>(individualClientReferenceId),
      'isHeadOfHousehold': serializer.toJson<bool>(isHeadOfHousehold),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  HouseholdMemberData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> householdId = const Value.absent(),
          Value<String?> householdClientReferenceId = const Value.absent(),
          Value<String?> individualId = const Value.absent(),
          Value<String?> individualClientReferenceId = const Value.absent(),
          bool? isHeadOfHousehold,
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      HouseholdMemberData(
        id: id.present ? id.value : this.id,
        householdId: householdId.present ? householdId.value : this.householdId,
        householdClientReferenceId: householdClientReferenceId.present
            ? householdClientReferenceId.value
            : this.householdClientReferenceId,
        individualId:
            individualId.present ? individualId.value : this.individualId,
        individualClientReferenceId: individualClientReferenceId.present
            ? individualClientReferenceId.value
            : this.individualClientReferenceId,
        isHeadOfHousehold: isHeadOfHousehold ?? this.isHeadOfHousehold,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('HouseholdMemberData(')
          ..write('id: $id, ')
          ..write('householdId: $householdId, ')
          ..write('householdClientReferenceId: $householdClientReferenceId, ')
          ..write('individualId: $individualId, ')
          ..write('individualClientReferenceId: $individualClientReferenceId, ')
          ..write('isHeadOfHousehold: $isHeadOfHousehold, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      householdId,
      householdClientReferenceId,
      individualId,
      individualClientReferenceId,
      isHeadOfHousehold,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is HouseholdMemberData &&
          other.id == this.id &&
          other.householdId == this.householdId &&
          other.householdClientReferenceId == this.householdClientReferenceId &&
          other.individualId == this.individualId &&
          other.individualClientReferenceId ==
              this.individualClientReferenceId &&
          other.isHeadOfHousehold == this.isHeadOfHousehold &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class HouseholdMemberCompanion extends UpdateCompanion<HouseholdMemberData> {
  final Value<String?> id;
  final Value<String?> householdId;
  final Value<String?> householdClientReferenceId;
  final Value<String?> individualId;
  final Value<String?> individualClientReferenceId;
  final Value<bool> isHeadOfHousehold;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const HouseholdMemberCompanion({
    this.id = const Value.absent(),
    this.householdId = const Value.absent(),
    this.householdClientReferenceId = const Value.absent(),
    this.individualId = const Value.absent(),
    this.individualClientReferenceId = const Value.absent(),
    this.isHeadOfHousehold = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  HouseholdMemberCompanion.insert({
    this.id = const Value.absent(),
    this.householdId = const Value.absent(),
    this.householdClientReferenceId = const Value.absent(),
    this.individualId = const Value.absent(),
    this.individualClientReferenceId = const Value.absent(),
    required bool isHeadOfHousehold,
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : isHeadOfHousehold = Value(isHeadOfHousehold),
        clientReferenceId = Value(clientReferenceId);
  static Insertable<HouseholdMemberData> custom({
    Expression<String>? id,
    Expression<String>? householdId,
    Expression<String>? householdClientReferenceId,
    Expression<String>? individualId,
    Expression<String>? individualClientReferenceId,
    Expression<bool>? isHeadOfHousehold,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (householdId != null) 'household_id': householdId,
      if (householdClientReferenceId != null)
        'household_client_reference_id': householdClientReferenceId,
      if (individualId != null) 'individual_id': individualId,
      if (individualClientReferenceId != null)
        'individual_client_reference_id': individualClientReferenceId,
      if (isHeadOfHousehold != null) 'is_head_of_household': isHeadOfHousehold,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  HouseholdMemberCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? householdId,
      Value<String?>? householdClientReferenceId,
      Value<String?>? individualId,
      Value<String?>? individualClientReferenceId,
      Value<bool>? isHeadOfHousehold,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return HouseholdMemberCompanion(
      id: id ?? this.id,
      householdId: householdId ?? this.householdId,
      householdClientReferenceId:
          householdClientReferenceId ?? this.householdClientReferenceId,
      individualId: individualId ?? this.individualId,
      individualClientReferenceId:
          individualClientReferenceId ?? this.individualClientReferenceId,
      isHeadOfHousehold: isHeadOfHousehold ?? this.isHeadOfHousehold,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (householdId.present) {
      map['household_id'] = Variable<String>(householdId.value);
    }
    if (householdClientReferenceId.present) {
      map['household_client_reference_id'] =
          Variable<String>(householdClientReferenceId.value);
    }
    if (individualId.present) {
      map['individual_id'] = Variable<String>(individualId.value);
    }
    if (individualClientReferenceId.present) {
      map['individual_client_reference_id'] =
          Variable<String>(individualClientReferenceId.value);
    }
    if (isHeadOfHousehold.present) {
      map['is_head_of_household'] = Variable<bool>(isHeadOfHousehold.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('HouseholdMemberCompanion(')
          ..write('id: $id, ')
          ..write('householdId: $householdId, ')
          ..write('householdClientReferenceId: $householdClientReferenceId, ')
          ..write('individualId: $individualId, ')
          ..write('individualClientReferenceId: $individualClientReferenceId, ')
          ..write('isHeadOfHousehold: $isHeadOfHousehold, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TaskTable extends Task with TableInfo<$TaskTable, TaskData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TaskTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectBeneficiaryIdMeta =
      const VerificationMeta('projectBeneficiaryId');
  @override
  late final GeneratedColumn<String> projectBeneficiaryId =
      GeneratedColumn<String>('project_beneficiary_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectBeneficiaryClientReferenceIdMeta =
      const VerificationMeta('projectBeneficiaryClientReferenceId');
  @override
  late final GeneratedColumn<String> projectBeneficiaryClientReferenceId =
      GeneratedColumn<String>(
          'project_beneficiary_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
      'created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _plannedStartDateMeta =
      const VerificationMeta('plannedStartDate');
  @override
  late final GeneratedColumn<int> plannedStartDate = GeneratedColumn<int>(
      'planned_start_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _plannedEndDateMeta =
      const VerificationMeta('plannedEndDate');
  @override
  late final GeneratedColumn<int> plannedEndDate = GeneratedColumn<int>(
      'planned_end_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _actualStartDateMeta =
      const VerificationMeta('actualStartDate');
  @override
  late final GeneratedColumn<int> actualStartDate = GeneratedColumn<int>(
      'actual_start_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _actualEndDateMeta =
      const VerificationMeta('actualEndDate');
  @override
  late final GeneratedColumn<int> actualEndDate = GeneratedColumn<int>(
      'actual_end_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _createdDateMeta =
      const VerificationMeta('createdDate');
  @override
  late final GeneratedColumn<int> createdDate = GeneratedColumn<int>(
      'created_date', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        projectId,
        projectBeneficiaryId,
        projectBeneficiaryClientReferenceId,
        createdBy,
        status,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        plannedStartDate,
        plannedEndDate,
        actualStartDate,
        actualEndDate,
        createdDate,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'task';
  @override
  VerificationContext validateIntegrity(Insertable<TaskData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('project_beneficiary_id')) {
      context.handle(
          _projectBeneficiaryIdMeta,
          projectBeneficiaryId.isAcceptableOrUnknown(
              data['project_beneficiary_id']!, _projectBeneficiaryIdMeta));
    }
    if (data.containsKey('project_beneficiary_client_reference_id')) {
      context.handle(
          _projectBeneficiaryClientReferenceIdMeta,
          projectBeneficiaryClientReferenceId.isAcceptableOrUnknown(
              data['project_beneficiary_client_reference_id']!,
              _projectBeneficiaryClientReferenceIdMeta));
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('planned_start_date')) {
      context.handle(
          _plannedStartDateMeta,
          plannedStartDate.isAcceptableOrUnknown(
              data['planned_start_date']!, _plannedStartDateMeta));
    }
    if (data.containsKey('planned_end_date')) {
      context.handle(
          _plannedEndDateMeta,
          plannedEndDate.isAcceptableOrUnknown(
              data['planned_end_date']!, _plannedEndDateMeta));
    }
    if (data.containsKey('actual_start_date')) {
      context.handle(
          _actualStartDateMeta,
          actualStartDate.isAcceptableOrUnknown(
              data['actual_start_date']!, _actualStartDateMeta));
    }
    if (data.containsKey('actual_end_date')) {
      context.handle(
          _actualEndDateMeta,
          actualEndDate.isAcceptableOrUnknown(
              data['actual_end_date']!, _actualEndDateMeta));
    }
    if (data.containsKey('created_date')) {
      context.handle(
          _createdDateMeta,
          createdDate.isAcceptableOrUnknown(
              data['created_date']!, _createdDateMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  TaskData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TaskData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      projectBeneficiaryId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}project_beneficiary_id']),
      projectBeneficiaryClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}project_beneficiary_client_reference_id']),
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_by']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      plannedStartDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}planned_start_date']),
      plannedEndDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}planned_end_date']),
      actualStartDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}actual_start_date']),
      actualEndDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}actual_end_date']),
      createdDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_date']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $TaskTable createAlias(String alias) {
    return $TaskTable(attachedDatabase, alias);
  }
}

class TaskData extends DataClass implements Insertable<TaskData> {
  final String? id;
  final String? projectId;
  final String? projectBeneficiaryId;
  final String? projectBeneficiaryClientReferenceId;
  final String? createdBy;
  final String? status;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final int? plannedStartDate;
  final int? plannedEndDate;
  final int? actualStartDate;
  final int? actualEndDate;
  final int? createdDate;
  final String? additionalFields;
  const TaskData(
      {this.id,
      this.projectId,
      this.projectBeneficiaryId,
      this.projectBeneficiaryClientReferenceId,
      this.createdBy,
      this.status,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.plannedStartDate,
      this.plannedEndDate,
      this.actualStartDate,
      this.actualEndDate,
      this.createdDate,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || projectBeneficiaryId != null) {
      map['project_beneficiary_id'] = Variable<String>(projectBeneficiaryId);
    }
    if (!nullToAbsent || projectBeneficiaryClientReferenceId != null) {
      map['project_beneficiary_client_reference_id'] =
          Variable<String>(projectBeneficiaryClientReferenceId);
    }
    if (!nullToAbsent || createdBy != null) {
      map['created_by'] = Variable<String>(createdBy);
    }
    if (!nullToAbsent || status != null) {
      map['status'] = Variable<String>(status);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || plannedStartDate != null) {
      map['planned_start_date'] = Variable<int>(plannedStartDate);
    }
    if (!nullToAbsent || plannedEndDate != null) {
      map['planned_end_date'] = Variable<int>(plannedEndDate);
    }
    if (!nullToAbsent || actualStartDate != null) {
      map['actual_start_date'] = Variable<int>(actualStartDate);
    }
    if (!nullToAbsent || actualEndDate != null) {
      map['actual_end_date'] = Variable<int>(actualEndDate);
    }
    if (!nullToAbsent || createdDate != null) {
      map['created_date'] = Variable<int>(createdDate);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  TaskCompanion toCompanion(bool nullToAbsent) {
    return TaskCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      projectBeneficiaryId: projectBeneficiaryId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectBeneficiaryId),
      projectBeneficiaryClientReferenceId:
          projectBeneficiaryClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(projectBeneficiaryClientReferenceId),
      createdBy: createdBy == null && nullToAbsent
          ? const Value.absent()
          : Value(createdBy),
      status:
          status == null && nullToAbsent ? const Value.absent() : Value(status),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      plannedStartDate: plannedStartDate == null && nullToAbsent
          ? const Value.absent()
          : Value(plannedStartDate),
      plannedEndDate: plannedEndDate == null && nullToAbsent
          ? const Value.absent()
          : Value(plannedEndDate),
      actualStartDate: actualStartDate == null && nullToAbsent
          ? const Value.absent()
          : Value(actualStartDate),
      actualEndDate: actualEndDate == null && nullToAbsent
          ? const Value.absent()
          : Value(actualEndDate),
      createdDate: createdDate == null && nullToAbsent
          ? const Value.absent()
          : Value(createdDate),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory TaskData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TaskData(
      id: serializer.fromJson<String?>(json['id']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      projectBeneficiaryId:
          serializer.fromJson<String?>(json['projectBeneficiaryId']),
      projectBeneficiaryClientReferenceId: serializer
          .fromJson<String?>(json['projectBeneficiaryClientReferenceId']),
      createdBy: serializer.fromJson<String?>(json['createdBy']),
      status: serializer.fromJson<String?>(json['status']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      plannedStartDate: serializer.fromJson<int?>(json['plannedStartDate']),
      plannedEndDate: serializer.fromJson<int?>(json['plannedEndDate']),
      actualStartDate: serializer.fromJson<int?>(json['actualStartDate']),
      actualEndDate: serializer.fromJson<int?>(json['actualEndDate']),
      createdDate: serializer.fromJson<int?>(json['createdDate']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'projectId': serializer.toJson<String?>(projectId),
      'projectBeneficiaryId': serializer.toJson<String?>(projectBeneficiaryId),
      'projectBeneficiaryClientReferenceId':
          serializer.toJson<String?>(projectBeneficiaryClientReferenceId),
      'createdBy': serializer.toJson<String?>(createdBy),
      'status': serializer.toJson<String?>(status),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'plannedStartDate': serializer.toJson<int?>(plannedStartDate),
      'plannedEndDate': serializer.toJson<int?>(plannedEndDate),
      'actualStartDate': serializer.toJson<int?>(actualStartDate),
      'actualEndDate': serializer.toJson<int?>(actualEndDate),
      'createdDate': serializer.toJson<int?>(createdDate),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  TaskData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> projectBeneficiaryId = const Value.absent(),
          Value<String?> projectBeneficiaryClientReferenceId =
              const Value.absent(),
          Value<String?> createdBy = const Value.absent(),
          Value<String?> status = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<int?> plannedStartDate = const Value.absent(),
          Value<int?> plannedEndDate = const Value.absent(),
          Value<int?> actualStartDate = const Value.absent(),
          Value<int?> actualEndDate = const Value.absent(),
          Value<int?> createdDate = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      TaskData(
        id: id.present ? id.value : this.id,
        projectId: projectId.present ? projectId.value : this.projectId,
        projectBeneficiaryId: projectBeneficiaryId.present
            ? projectBeneficiaryId.value
            : this.projectBeneficiaryId,
        projectBeneficiaryClientReferenceId:
            projectBeneficiaryClientReferenceId.present
                ? projectBeneficiaryClientReferenceId.value
                : this.projectBeneficiaryClientReferenceId,
        createdBy: createdBy.present ? createdBy.value : this.createdBy,
        status: status.present ? status.value : this.status,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        plannedStartDate: plannedStartDate.present
            ? plannedStartDate.value
            : this.plannedStartDate,
        plannedEndDate:
            plannedEndDate.present ? plannedEndDate.value : this.plannedEndDate,
        actualStartDate: actualStartDate.present
            ? actualStartDate.value
            : this.actualStartDate,
        actualEndDate:
            actualEndDate.present ? actualEndDate.value : this.actualEndDate,
        createdDate: createdDate.present ? createdDate.value : this.createdDate,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('TaskData(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('projectBeneficiaryId: $projectBeneficiaryId, ')
          ..write(
              'projectBeneficiaryClientReferenceId: $projectBeneficiaryClientReferenceId, ')
          ..write('createdBy: $createdBy, ')
          ..write('status: $status, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('plannedStartDate: $plannedStartDate, ')
          ..write('plannedEndDate: $plannedEndDate, ')
          ..write('actualStartDate: $actualStartDate, ')
          ..write('actualEndDate: $actualEndDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        projectId,
        projectBeneficiaryId,
        projectBeneficiaryClientReferenceId,
        createdBy,
        status,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        plannedStartDate,
        plannedEndDate,
        actualStartDate,
        actualEndDate,
        createdDate,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TaskData &&
          other.id == this.id &&
          other.projectId == this.projectId &&
          other.projectBeneficiaryId == this.projectBeneficiaryId &&
          other.projectBeneficiaryClientReferenceId ==
              this.projectBeneficiaryClientReferenceId &&
          other.createdBy == this.createdBy &&
          other.status == this.status &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.plannedStartDate == this.plannedStartDate &&
          other.plannedEndDate == this.plannedEndDate &&
          other.actualStartDate == this.actualStartDate &&
          other.actualEndDate == this.actualEndDate &&
          other.createdDate == this.createdDate &&
          other.additionalFields == this.additionalFields);
}

class TaskCompanion extends UpdateCompanion<TaskData> {
  final Value<String?> id;
  final Value<String?> projectId;
  final Value<String?> projectBeneficiaryId;
  final Value<String?> projectBeneficiaryClientReferenceId;
  final Value<String?> createdBy;
  final Value<String?> status;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<int?> plannedStartDate;
  final Value<int?> plannedEndDate;
  final Value<int?> actualStartDate;
  final Value<int?> actualEndDate;
  final Value<int?> createdDate;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const TaskCompanion({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.projectBeneficiaryId = const Value.absent(),
    this.projectBeneficiaryClientReferenceId = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.status = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.plannedStartDate = const Value.absent(),
    this.plannedEndDate = const Value.absent(),
    this.actualStartDate = const Value.absent(),
    this.actualEndDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TaskCompanion.insert({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.projectBeneficiaryId = const Value.absent(),
    this.projectBeneficiaryClientReferenceId = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.status = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.plannedStartDate = const Value.absent(),
    this.plannedEndDate = const Value.absent(),
    this.actualStartDate = const Value.absent(),
    this.actualEndDate = const Value.absent(),
    this.createdDate = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<TaskData> custom({
    Expression<String>? id,
    Expression<String>? projectId,
    Expression<String>? projectBeneficiaryId,
    Expression<String>? projectBeneficiaryClientReferenceId,
    Expression<String>? createdBy,
    Expression<String>? status,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<int>? plannedStartDate,
    Expression<int>? plannedEndDate,
    Expression<int>? actualStartDate,
    Expression<int>? actualEndDate,
    Expression<int>? createdDate,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (projectId != null) 'project_id': projectId,
      if (projectBeneficiaryId != null)
        'project_beneficiary_id': projectBeneficiaryId,
      if (projectBeneficiaryClientReferenceId != null)
        'project_beneficiary_client_reference_id':
            projectBeneficiaryClientReferenceId,
      if (createdBy != null) 'created_by': createdBy,
      if (status != null) 'status': status,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (plannedStartDate != null) 'planned_start_date': plannedStartDate,
      if (plannedEndDate != null) 'planned_end_date': plannedEndDate,
      if (actualStartDate != null) 'actual_start_date': actualStartDate,
      if (actualEndDate != null) 'actual_end_date': actualEndDate,
      if (createdDate != null) 'created_date': createdDate,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TaskCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? projectId,
      Value<String?>? projectBeneficiaryId,
      Value<String?>? projectBeneficiaryClientReferenceId,
      Value<String?>? createdBy,
      Value<String?>? status,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<int?>? plannedStartDate,
      Value<int?>? plannedEndDate,
      Value<int?>? actualStartDate,
      Value<int?>? actualEndDate,
      Value<int?>? createdDate,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return TaskCompanion(
      id: id ?? this.id,
      projectId: projectId ?? this.projectId,
      projectBeneficiaryId: projectBeneficiaryId ?? this.projectBeneficiaryId,
      projectBeneficiaryClientReferenceId:
          projectBeneficiaryClientReferenceId ??
              this.projectBeneficiaryClientReferenceId,
      createdBy: createdBy ?? this.createdBy,
      status: status ?? this.status,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      plannedStartDate: plannedStartDate ?? this.plannedStartDate,
      plannedEndDate: plannedEndDate ?? this.plannedEndDate,
      actualStartDate: actualStartDate ?? this.actualStartDate,
      actualEndDate: actualEndDate ?? this.actualEndDate,
      createdDate: createdDate ?? this.createdDate,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (projectBeneficiaryId.present) {
      map['project_beneficiary_id'] =
          Variable<String>(projectBeneficiaryId.value);
    }
    if (projectBeneficiaryClientReferenceId.present) {
      map['project_beneficiary_client_reference_id'] =
          Variable<String>(projectBeneficiaryClientReferenceId.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (plannedStartDate.present) {
      map['planned_start_date'] = Variable<int>(plannedStartDate.value);
    }
    if (plannedEndDate.present) {
      map['planned_end_date'] = Variable<int>(plannedEndDate.value);
    }
    if (actualStartDate.present) {
      map['actual_start_date'] = Variable<int>(actualStartDate.value);
    }
    if (actualEndDate.present) {
      map['actual_end_date'] = Variable<int>(actualEndDate.value);
    }
    if (createdDate.present) {
      map['created_date'] = Variable<int>(createdDate.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TaskCompanion(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('projectBeneficiaryId: $projectBeneficiaryId, ')
          ..write(
              'projectBeneficiaryClientReferenceId: $projectBeneficiaryClientReferenceId, ')
          ..write('createdBy: $createdBy, ')
          ..write('status: $status, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('plannedStartDate: $plannedStartDate, ')
          ..write('plannedEndDate: $plannedEndDate, ')
          ..write('actualStartDate: $actualStartDate, ')
          ..write('actualEndDate: $actualEndDate, ')
          ..write('createdDate: $createdDate, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TaskResourceTable extends TaskResource
    with TableInfo<$TaskResourceTable, TaskResourceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TaskResourceTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _taskclientReferenceIdMeta =
      const VerificationMeta('taskclientReferenceId');
  @override
  late final GeneratedColumn<String> taskclientReferenceId =
      GeneratedColumn<String>('taskclient_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _taskIdMeta = const VerificationMeta('taskId');
  @override
  late final GeneratedColumn<String> taskId = GeneratedColumn<String>(
      'task_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _productVariantIdMeta =
      const VerificationMeta('productVariantId');
  @override
  late final GeneratedColumn<String> productVariantId = GeneratedColumn<String>(
      'product_variant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  @override
  late final GeneratedColumn<String> quantity = GeneratedColumn<String>(
      'quantity', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeliveredMeta =
      const VerificationMeta('isDelivered');
  @override
  late final GeneratedColumn<bool> isDelivered = GeneratedColumn<bool>(
      'is_delivered', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_delivered" IN (0, 1))'));
  static const VerificationMeta _deliveryCommentMeta =
      const VerificationMeta('deliveryComment');
  @override
  late final GeneratedColumn<String> deliveryComment = GeneratedColumn<String>(
      'delivery_comment', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        clientReferenceId,
        taskclientReferenceId,
        taskId,
        id,
        productVariantId,
        quantity,
        isDelivered,
        deliveryComment,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'task_resource';
  @override
  VerificationContext validateIntegrity(Insertable<TaskResourceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('taskclient_reference_id')) {
      context.handle(
          _taskclientReferenceIdMeta,
          taskclientReferenceId.isAcceptableOrUnknown(
              data['taskclient_reference_id']!, _taskclientReferenceIdMeta));
    }
    if (data.containsKey('task_id')) {
      context.handle(_taskIdMeta,
          taskId.isAcceptableOrUnknown(data['task_id']!, _taskIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('product_variant_id')) {
      context.handle(
          _productVariantIdMeta,
          productVariantId.isAcceptableOrUnknown(
              data['product_variant_id']!, _productVariantIdMeta));
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    }
    if (data.containsKey('is_delivered')) {
      context.handle(
          _isDeliveredMeta,
          isDelivered.isAcceptableOrUnknown(
              data['is_delivered']!, _isDeliveredMeta));
    }
    if (data.containsKey('delivery_comment')) {
      context.handle(
          _deliveryCommentMeta,
          deliveryComment.isAcceptableOrUnknown(
              data['delivery_comment']!, _deliveryCommentMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {clientReferenceId, auditCreatedBy};
  @override
  TaskResourceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TaskResourceData(
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      taskclientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}taskclient_reference_id']),
      taskId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}task_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      productVariantId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}product_variant_id']),
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}quantity']),
      isDelivered: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_delivered']),
      deliveryComment: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}delivery_comment']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $TaskResourceTable createAlias(String alias) {
    return $TaskResourceTable(attachedDatabase, alias);
  }
}

class TaskResourceData extends DataClass
    implements Insertable<TaskResourceData> {
  final String clientReferenceId;
  final String? taskclientReferenceId;
  final String? taskId;
  final String? id;
  final String? productVariantId;
  final String? quantity;
  final bool? isDelivered;
  final String? deliveryComment;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const TaskResourceData(
      {required this.clientReferenceId,
      this.taskclientReferenceId,
      this.taskId,
      this.id,
      this.productVariantId,
      this.quantity,
      this.isDelivered,
      this.deliveryComment,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || taskclientReferenceId != null) {
      map['taskclient_reference_id'] = Variable<String>(taskclientReferenceId);
    }
    if (!nullToAbsent || taskId != null) {
      map['task_id'] = Variable<String>(taskId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || productVariantId != null) {
      map['product_variant_id'] = Variable<String>(productVariantId);
    }
    if (!nullToAbsent || quantity != null) {
      map['quantity'] = Variable<String>(quantity);
    }
    if (!nullToAbsent || isDelivered != null) {
      map['is_delivered'] = Variable<bool>(isDelivered);
    }
    if (!nullToAbsent || deliveryComment != null) {
      map['delivery_comment'] = Variable<String>(deliveryComment);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  TaskResourceCompanion toCompanion(bool nullToAbsent) {
    return TaskResourceCompanion(
      clientReferenceId: Value(clientReferenceId),
      taskclientReferenceId: taskclientReferenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(taskclientReferenceId),
      taskId:
          taskId == null && nullToAbsent ? const Value.absent() : Value(taskId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      productVariantId: productVariantId == null && nullToAbsent
          ? const Value.absent()
          : Value(productVariantId),
      quantity: quantity == null && nullToAbsent
          ? const Value.absent()
          : Value(quantity),
      isDelivered: isDelivered == null && nullToAbsent
          ? const Value.absent()
          : Value(isDelivered),
      deliveryComment: deliveryComment == null && nullToAbsent
          ? const Value.absent()
          : Value(deliveryComment),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory TaskResourceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TaskResourceData(
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      taskclientReferenceId:
          serializer.fromJson<String?>(json['taskclientReferenceId']),
      taskId: serializer.fromJson<String?>(json['taskId']),
      id: serializer.fromJson<String?>(json['id']),
      productVariantId: serializer.fromJson<String?>(json['productVariantId']),
      quantity: serializer.fromJson<String?>(json['quantity']),
      isDelivered: serializer.fromJson<bool?>(json['isDelivered']),
      deliveryComment: serializer.fromJson<String?>(json['deliveryComment']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'taskclientReferenceId':
          serializer.toJson<String?>(taskclientReferenceId),
      'taskId': serializer.toJson<String?>(taskId),
      'id': serializer.toJson<String?>(id),
      'productVariantId': serializer.toJson<String?>(productVariantId),
      'quantity': serializer.toJson<String?>(quantity),
      'isDelivered': serializer.toJson<bool?>(isDelivered),
      'deliveryComment': serializer.toJson<String?>(deliveryComment),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  TaskResourceData copyWith(
          {String? clientReferenceId,
          Value<String?> taskclientReferenceId = const Value.absent(),
          Value<String?> taskId = const Value.absent(),
          Value<String?> id = const Value.absent(),
          Value<String?> productVariantId = const Value.absent(),
          Value<String?> quantity = const Value.absent(),
          Value<bool?> isDelivered = const Value.absent(),
          Value<String?> deliveryComment = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      TaskResourceData(
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        taskclientReferenceId: taskclientReferenceId.present
            ? taskclientReferenceId.value
            : this.taskclientReferenceId,
        taskId: taskId.present ? taskId.value : this.taskId,
        id: id.present ? id.value : this.id,
        productVariantId: productVariantId.present
            ? productVariantId.value
            : this.productVariantId,
        quantity: quantity.present ? quantity.value : this.quantity,
        isDelivered: isDelivered.present ? isDelivered.value : this.isDelivered,
        deliveryComment: deliveryComment.present
            ? deliveryComment.value
            : this.deliveryComment,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('TaskResourceData(')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('taskclientReferenceId: $taskclientReferenceId, ')
          ..write('taskId: $taskId, ')
          ..write('id: $id, ')
          ..write('productVariantId: $productVariantId, ')
          ..write('quantity: $quantity, ')
          ..write('isDelivered: $isDelivered, ')
          ..write('deliveryComment: $deliveryComment, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        clientReferenceId,
        taskclientReferenceId,
        taskId,
        id,
        productVariantId,
        quantity,
        isDelivered,
        deliveryComment,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TaskResourceData &&
          other.clientReferenceId == this.clientReferenceId &&
          other.taskclientReferenceId == this.taskclientReferenceId &&
          other.taskId == this.taskId &&
          other.id == this.id &&
          other.productVariantId == this.productVariantId &&
          other.quantity == this.quantity &&
          other.isDelivered == this.isDelivered &&
          other.deliveryComment == this.deliveryComment &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class TaskResourceCompanion extends UpdateCompanion<TaskResourceData> {
  final Value<String> clientReferenceId;
  final Value<String?> taskclientReferenceId;
  final Value<String?> taskId;
  final Value<String?> id;
  final Value<String?> productVariantId;
  final Value<String?> quantity;
  final Value<bool?> isDelivered;
  final Value<String?> deliveryComment;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const TaskResourceCompanion({
    this.clientReferenceId = const Value.absent(),
    this.taskclientReferenceId = const Value.absent(),
    this.taskId = const Value.absent(),
    this.id = const Value.absent(),
    this.productVariantId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.isDelivered = const Value.absent(),
    this.deliveryComment = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TaskResourceCompanion.insert({
    required String clientReferenceId,
    this.taskclientReferenceId = const Value.absent(),
    this.taskId = const Value.absent(),
    this.id = const Value.absent(),
    this.productVariantId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.isDelivered = const Value.absent(),
    this.deliveryComment = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<TaskResourceData> custom({
    Expression<String>? clientReferenceId,
    Expression<String>? taskclientReferenceId,
    Expression<String>? taskId,
    Expression<String>? id,
    Expression<String>? productVariantId,
    Expression<String>? quantity,
    Expression<bool>? isDelivered,
    Expression<String>? deliveryComment,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (taskclientReferenceId != null)
        'taskclient_reference_id': taskclientReferenceId,
      if (taskId != null) 'task_id': taskId,
      if (id != null) 'id': id,
      if (productVariantId != null) 'product_variant_id': productVariantId,
      if (quantity != null) 'quantity': quantity,
      if (isDelivered != null) 'is_delivered': isDelivered,
      if (deliveryComment != null) 'delivery_comment': deliveryComment,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TaskResourceCompanion copyWith(
      {Value<String>? clientReferenceId,
      Value<String?>? taskclientReferenceId,
      Value<String?>? taskId,
      Value<String?>? id,
      Value<String?>? productVariantId,
      Value<String?>? quantity,
      Value<bool?>? isDelivered,
      Value<String?>? deliveryComment,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return TaskResourceCompanion(
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      taskclientReferenceId:
          taskclientReferenceId ?? this.taskclientReferenceId,
      taskId: taskId ?? this.taskId,
      id: id ?? this.id,
      productVariantId: productVariantId ?? this.productVariantId,
      quantity: quantity ?? this.quantity,
      isDelivered: isDelivered ?? this.isDelivered,
      deliveryComment: deliveryComment ?? this.deliveryComment,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (taskclientReferenceId.present) {
      map['taskclient_reference_id'] =
          Variable<String>(taskclientReferenceId.value);
    }
    if (taskId.present) {
      map['task_id'] = Variable<String>(taskId.value);
    }
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (productVariantId.present) {
      map['product_variant_id'] = Variable<String>(productVariantId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<String>(quantity.value);
    }
    if (isDelivered.present) {
      map['is_delivered'] = Variable<bool>(isDelivered.value);
    }
    if (deliveryComment.present) {
      map['delivery_comment'] = Variable<String>(deliveryComment.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TaskResourceCompanion(')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('taskclientReferenceId: $taskclientReferenceId, ')
          ..write('taskId: $taskId, ')
          ..write('id: $id, ')
          ..write('productVariantId: $productVariantId, ')
          ..write('quantity: $quantity, ')
          ..write('isDelivered: $isDelivered, ')
          ..write('deliveryComment: $deliveryComment, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SideEffectTable extends SideEffect
    with TableInfo<$SideEffectTable, SideEffectData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SideEffectTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _taskClientReferenceIdMeta =
      const VerificationMeta('taskClientReferenceId');
  @override
  late final GeneratedColumn<String> taskClientReferenceId =
      GeneratedColumn<String>('task_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _reAttemptsMeta =
      const VerificationMeta('reAttempts');
  @override
  late final GeneratedColumn<int> reAttempts = GeneratedColumn<int>(
      're_attempts', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _symptomsMeta =
      const VerificationMeta('symptoms');
  @override
  late final GeneratedColumn<String> symptoms = GeneratedColumn<String>(
      'symptoms', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        projectId,
        taskClientReferenceId,
        reAttempts,
        symptoms,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'side_effect';
  @override
  VerificationContext validateIntegrity(Insertable<SideEffectData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('task_client_reference_id')) {
      context.handle(
          _taskClientReferenceIdMeta,
          taskClientReferenceId.isAcceptableOrUnknown(
              data['task_client_reference_id']!, _taskClientReferenceIdMeta));
    }
    if (data.containsKey('re_attempts')) {
      context.handle(
          _reAttemptsMeta,
          reAttempts.isAcceptableOrUnknown(
              data['re_attempts']!, _reAttemptsMeta));
    }
    if (data.containsKey('symptoms')) {
      context.handle(_symptomsMeta,
          symptoms.isAcceptableOrUnknown(data['symptoms']!, _symptomsMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  SideEffectData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SideEffectData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      taskClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}task_client_reference_id']),
      reAttempts: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}re_attempts']),
      symptoms: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}symptoms']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $SideEffectTable createAlias(String alias) {
    return $SideEffectTable(attachedDatabase, alias);
  }
}

class SideEffectData extends DataClass implements Insertable<SideEffectData> {
  final String? id;
  final String? projectId;
  final String? taskClientReferenceId;
  final int? reAttempts;
  final String? symptoms;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const SideEffectData(
      {this.id,
      this.projectId,
      this.taskClientReferenceId,
      this.reAttempts,
      this.symptoms,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || taskClientReferenceId != null) {
      map['task_client_reference_id'] = Variable<String>(taskClientReferenceId);
    }
    if (!nullToAbsent || reAttempts != null) {
      map['re_attempts'] = Variable<int>(reAttempts);
    }
    if (!nullToAbsent || symptoms != null) {
      map['symptoms'] = Variable<String>(symptoms);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  SideEffectCompanion toCompanion(bool nullToAbsent) {
    return SideEffectCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      taskClientReferenceId: taskClientReferenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(taskClientReferenceId),
      reAttempts: reAttempts == null && nullToAbsent
          ? const Value.absent()
          : Value(reAttempts),
      symptoms: symptoms == null && nullToAbsent
          ? const Value.absent()
          : Value(symptoms),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory SideEffectData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SideEffectData(
      id: serializer.fromJson<String?>(json['id']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      taskClientReferenceId:
          serializer.fromJson<String?>(json['taskClientReferenceId']),
      reAttempts: serializer.fromJson<int?>(json['reAttempts']),
      symptoms: serializer.fromJson<String?>(json['symptoms']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'projectId': serializer.toJson<String?>(projectId),
      'taskClientReferenceId':
          serializer.toJson<String?>(taskClientReferenceId),
      'reAttempts': serializer.toJson<int?>(reAttempts),
      'symptoms': serializer.toJson<String?>(symptoms),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  SideEffectData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> taskClientReferenceId = const Value.absent(),
          Value<int?> reAttempts = const Value.absent(),
          Value<String?> symptoms = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      SideEffectData(
        id: id.present ? id.value : this.id,
        projectId: projectId.present ? projectId.value : this.projectId,
        taskClientReferenceId: taskClientReferenceId.present
            ? taskClientReferenceId.value
            : this.taskClientReferenceId,
        reAttempts: reAttempts.present ? reAttempts.value : this.reAttempts,
        symptoms: symptoms.present ? symptoms.value : this.symptoms,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('SideEffectData(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('taskClientReferenceId: $taskClientReferenceId, ')
          ..write('reAttempts: $reAttempts, ')
          ..write('symptoms: $symptoms, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      projectId,
      taskClientReferenceId,
      reAttempts,
      symptoms,
      auditCreatedBy,
      nonRecoverableError,
      auditCreatedTime,
      clientCreatedTime,
      clientModifiedBy,
      clientCreatedBy,
      clientModifiedTime,
      auditModifiedBy,
      auditModifiedTime,
      clientReferenceId,
      tenantId,
      isDeleted,
      rowVersion,
      additionalFields);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SideEffectData &&
          other.id == this.id &&
          other.projectId == this.projectId &&
          other.taskClientReferenceId == this.taskClientReferenceId &&
          other.reAttempts == this.reAttempts &&
          other.symptoms == this.symptoms &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class SideEffectCompanion extends UpdateCompanion<SideEffectData> {
  final Value<String?> id;
  final Value<String?> projectId;
  final Value<String?> taskClientReferenceId;
  final Value<int?> reAttempts;
  final Value<String?> symptoms;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const SideEffectCompanion({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.taskClientReferenceId = const Value.absent(),
    this.reAttempts = const Value.absent(),
    this.symptoms = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SideEffectCompanion.insert({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.taskClientReferenceId = const Value.absent(),
    this.reAttempts = const Value.absent(),
    this.symptoms = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<SideEffectData> custom({
    Expression<String>? id,
    Expression<String>? projectId,
    Expression<String>? taskClientReferenceId,
    Expression<int>? reAttempts,
    Expression<String>? symptoms,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (projectId != null) 'project_id': projectId,
      if (taskClientReferenceId != null)
        'task_client_reference_id': taskClientReferenceId,
      if (reAttempts != null) 're_attempts': reAttempts,
      if (symptoms != null) 'symptoms': symptoms,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SideEffectCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? projectId,
      Value<String?>? taskClientReferenceId,
      Value<int?>? reAttempts,
      Value<String?>? symptoms,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return SideEffectCompanion(
      id: id ?? this.id,
      projectId: projectId ?? this.projectId,
      taskClientReferenceId:
          taskClientReferenceId ?? this.taskClientReferenceId,
      reAttempts: reAttempts ?? this.reAttempts,
      symptoms: symptoms ?? this.symptoms,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (taskClientReferenceId.present) {
      map['task_client_reference_id'] =
          Variable<String>(taskClientReferenceId.value);
    }
    if (reAttempts.present) {
      map['re_attempts'] = Variable<int>(reAttempts.value);
    }
    if (symptoms.present) {
      map['symptoms'] = Variable<String>(symptoms.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SideEffectCompanion(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write('taskClientReferenceId: $taskClientReferenceId, ')
          ..write('reAttempts: $reAttempts, ')
          ..write('symptoms: $symptoms, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ReferralTable extends Referral
    with TableInfo<$ReferralTable, ReferralData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ReferralTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectIdMeta =
      const VerificationMeta('projectId');
  @override
  late final GeneratedColumn<String> projectId = GeneratedColumn<String>(
      'project_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _projectBeneficiaryClientReferenceIdMeta =
      const VerificationMeta('projectBeneficiaryClientReferenceId');
  @override
  late final GeneratedColumn<String> projectBeneficiaryClientReferenceId =
      GeneratedColumn<String>(
          'project_beneficiary_client_reference_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referrerIdMeta =
      const VerificationMeta('referrerId');
  @override
  late final GeneratedColumn<String> referrerId = GeneratedColumn<String>(
      'referrer_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _recipientTypeMeta =
      const VerificationMeta('recipientType');
  @override
  late final GeneratedColumn<String> recipientType = GeneratedColumn<String>(
      'recipient_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _recipientIdMeta =
      const VerificationMeta('recipientId');
  @override
  late final GeneratedColumn<String> recipientId = GeneratedColumn<String>(
      'recipient_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _reasonsMeta =
      const VerificationMeta('reasons');
  @override
  late final GeneratedColumn<String> reasons = GeneratedColumn<String>(
      'reasons', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditCreatedByMeta =
      const VerificationMeta('auditCreatedBy');
  @override
  late final GeneratedColumn<String> auditCreatedBy = GeneratedColumn<String>(
      'audit_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nonRecoverableErrorMeta =
      const VerificationMeta('nonRecoverableError');
  @override
  late final GeneratedColumn<bool> nonRecoverableError = GeneratedColumn<bool>(
      'non_recoverable_error', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("non_recoverable_error" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _auditCreatedTimeMeta =
      const VerificationMeta('auditCreatedTime');
  @override
  late final GeneratedColumn<int> auditCreatedTime = GeneratedColumn<int>(
      'audit_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedTimeMeta =
      const VerificationMeta('clientCreatedTime');
  @override
  late final GeneratedColumn<int> clientCreatedTime = GeneratedColumn<int>(
      'client_created_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedByMeta =
      const VerificationMeta('clientModifiedBy');
  @override
  late final GeneratedColumn<String> clientModifiedBy = GeneratedColumn<String>(
      'client_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientCreatedByMeta =
      const VerificationMeta('clientCreatedBy');
  @override
  late final GeneratedColumn<String> clientCreatedBy = GeneratedColumn<String>(
      'client_created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clientModifiedTimeMeta =
      const VerificationMeta('clientModifiedTime');
  @override
  late final GeneratedColumn<int> clientModifiedTime = GeneratedColumn<int>(
      'client_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedByMeta =
      const VerificationMeta('auditModifiedBy');
  @override
  late final GeneratedColumn<String> auditModifiedBy = GeneratedColumn<String>(
      'audit_modified_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _auditModifiedTimeMeta =
      const VerificationMeta('auditModifiedTime');
  @override
  late final GeneratedColumn<int> auditModifiedTime = GeneratedColumn<int>(
      'audit_modified_time', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clientReferenceIdMeta =
      const VerificationMeta('clientReferenceId');
  @override
  late final GeneratedColumn<String> clientReferenceId =
      GeneratedColumn<String>('client_reference_id', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _rowVersionMeta =
      const VerificationMeta('rowVersion');
  @override
  late final GeneratedColumn<int> rowVersion = GeneratedColumn<int>(
      'row_version', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _additionalFieldsMeta =
      const VerificationMeta('additionalFields');
  @override
  late final GeneratedColumn<String> additionalFields = GeneratedColumn<String>(
      'additional_fields', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        projectId,
        projectBeneficiaryClientReferenceId,
        referrerId,
        recipientType,
        recipientId,
        reasons,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'referral';
  @override
  VerificationContext validateIntegrity(Insertable<ReferralData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('project_id')) {
      context.handle(_projectIdMeta,
          projectId.isAcceptableOrUnknown(data['project_id']!, _projectIdMeta));
    }
    if (data.containsKey('project_beneficiary_client_reference_id')) {
      context.handle(
          _projectBeneficiaryClientReferenceIdMeta,
          projectBeneficiaryClientReferenceId.isAcceptableOrUnknown(
              data['project_beneficiary_client_reference_id']!,
              _projectBeneficiaryClientReferenceIdMeta));
    }
    if (data.containsKey('referrer_id')) {
      context.handle(
          _referrerIdMeta,
          referrerId.isAcceptableOrUnknown(
              data['referrer_id']!, _referrerIdMeta));
    }
    if (data.containsKey('recipient_type')) {
      context.handle(
          _recipientTypeMeta,
          recipientType.isAcceptableOrUnknown(
              data['recipient_type']!, _recipientTypeMeta));
    }
    if (data.containsKey('recipient_id')) {
      context.handle(
          _recipientIdMeta,
          recipientId.isAcceptableOrUnknown(
              data['recipient_id']!, _recipientIdMeta));
    }
    if (data.containsKey('reasons')) {
      context.handle(_reasonsMeta,
          reasons.isAcceptableOrUnknown(data['reasons']!, _reasonsMeta));
    }
    if (data.containsKey('audit_created_by')) {
      context.handle(
          _auditCreatedByMeta,
          auditCreatedBy.isAcceptableOrUnknown(
              data['audit_created_by']!, _auditCreatedByMeta));
    }
    if (data.containsKey('non_recoverable_error')) {
      context.handle(
          _nonRecoverableErrorMeta,
          nonRecoverableError.isAcceptableOrUnknown(
              data['non_recoverable_error']!, _nonRecoverableErrorMeta));
    }
    if (data.containsKey('audit_created_time')) {
      context.handle(
          _auditCreatedTimeMeta,
          auditCreatedTime.isAcceptableOrUnknown(
              data['audit_created_time']!, _auditCreatedTimeMeta));
    }
    if (data.containsKey('client_created_time')) {
      context.handle(
          _clientCreatedTimeMeta,
          clientCreatedTime.isAcceptableOrUnknown(
              data['client_created_time']!, _clientCreatedTimeMeta));
    }
    if (data.containsKey('client_modified_by')) {
      context.handle(
          _clientModifiedByMeta,
          clientModifiedBy.isAcceptableOrUnknown(
              data['client_modified_by']!, _clientModifiedByMeta));
    }
    if (data.containsKey('client_created_by')) {
      context.handle(
          _clientCreatedByMeta,
          clientCreatedBy.isAcceptableOrUnknown(
              data['client_created_by']!, _clientCreatedByMeta));
    }
    if (data.containsKey('client_modified_time')) {
      context.handle(
          _clientModifiedTimeMeta,
          clientModifiedTime.isAcceptableOrUnknown(
              data['client_modified_time']!, _clientModifiedTimeMeta));
    }
    if (data.containsKey('audit_modified_by')) {
      context.handle(
          _auditModifiedByMeta,
          auditModifiedBy.isAcceptableOrUnknown(
              data['audit_modified_by']!, _auditModifiedByMeta));
    }
    if (data.containsKey('audit_modified_time')) {
      context.handle(
          _auditModifiedTimeMeta,
          auditModifiedTime.isAcceptableOrUnknown(
              data['audit_modified_time']!, _auditModifiedTimeMeta));
    }
    if (data.containsKey('client_reference_id')) {
      context.handle(
          _clientReferenceIdMeta,
          clientReferenceId.isAcceptableOrUnknown(
              data['client_reference_id']!, _clientReferenceIdMeta));
    } else if (isInserting) {
      context.missing(_clientReferenceIdMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('row_version')) {
      context.handle(
          _rowVersionMeta,
          rowVersion.isAcceptableOrUnknown(
              data['row_version']!, _rowVersionMeta));
    }
    if (data.containsKey('additional_fields')) {
      context.handle(
          _additionalFieldsMeta,
          additionalFields.isAcceptableOrUnknown(
              data['additional_fields']!, _additionalFieldsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {auditCreatedBy, clientReferenceId};
  @override
  ReferralData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ReferralData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id']),
      projectId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_id']),
      projectBeneficiaryClientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}project_beneficiary_client_reference_id']),
      referrerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}referrer_id']),
      recipientType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}recipient_type']),
      recipientId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}recipient_id']),
      reasons: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reasons']),
      auditCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_created_by']),
      nonRecoverableError: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}non_recoverable_error']),
      auditCreatedTime: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}audit_created_time']),
      clientCreatedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_created_time']),
      clientModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_modified_by']),
      clientCreatedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_created_by']),
      clientModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}client_modified_time']),
      auditModifiedBy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}audit_modified_by']),
      auditModifiedTime: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}audit_modified_time']),
      clientReferenceId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}client_reference_id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
      rowVersion: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}row_version']),
      additionalFields: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}additional_fields']),
    );
  }

  @override
  $ReferralTable createAlias(String alias) {
    return $ReferralTable(attachedDatabase, alias);
  }
}

class ReferralData extends DataClass implements Insertable<ReferralData> {
  final String? id;
  final String? projectId;
  final String? projectBeneficiaryClientReferenceId;
  final String? referrerId;
  final String? recipientType;
  final String? recipientId;
  final String? reasons;
  final String? auditCreatedBy;
  final bool? nonRecoverableError;
  final int? auditCreatedTime;
  final int? clientCreatedTime;
  final String? clientModifiedBy;
  final String? clientCreatedBy;
  final int? clientModifiedTime;
  final String? auditModifiedBy;
  final int? auditModifiedTime;
  final String clientReferenceId;
  final String? tenantId;
  final bool? isDeleted;
  final int? rowVersion;
  final String? additionalFields;
  const ReferralData(
      {this.id,
      this.projectId,
      this.projectBeneficiaryClientReferenceId,
      this.referrerId,
      this.recipientType,
      this.recipientId,
      this.reasons,
      this.auditCreatedBy,
      this.nonRecoverableError,
      this.auditCreatedTime,
      this.clientCreatedTime,
      this.clientModifiedBy,
      this.clientCreatedBy,
      this.clientModifiedTime,
      this.auditModifiedBy,
      this.auditModifiedTime,
      required this.clientReferenceId,
      this.tenantId,
      this.isDeleted,
      this.rowVersion,
      this.additionalFields});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<String>(id);
    }
    if (!nullToAbsent || projectId != null) {
      map['project_id'] = Variable<String>(projectId);
    }
    if (!nullToAbsent || projectBeneficiaryClientReferenceId != null) {
      map['project_beneficiary_client_reference_id'] =
          Variable<String>(projectBeneficiaryClientReferenceId);
    }
    if (!nullToAbsent || referrerId != null) {
      map['referrer_id'] = Variable<String>(referrerId);
    }
    if (!nullToAbsent || recipientType != null) {
      map['recipient_type'] = Variable<String>(recipientType);
    }
    if (!nullToAbsent || recipientId != null) {
      map['recipient_id'] = Variable<String>(recipientId);
    }
    if (!nullToAbsent || reasons != null) {
      map['reasons'] = Variable<String>(reasons);
    }
    if (!nullToAbsent || auditCreatedBy != null) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy);
    }
    if (!nullToAbsent || nonRecoverableError != null) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError);
    }
    if (!nullToAbsent || auditCreatedTime != null) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime);
    }
    if (!nullToAbsent || clientCreatedTime != null) {
      map['client_created_time'] = Variable<int>(clientCreatedTime);
    }
    if (!nullToAbsent || clientModifiedBy != null) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy);
    }
    if (!nullToAbsent || clientCreatedBy != null) {
      map['client_created_by'] = Variable<String>(clientCreatedBy);
    }
    if (!nullToAbsent || clientModifiedTime != null) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime);
    }
    if (!nullToAbsent || auditModifiedBy != null) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy);
    }
    if (!nullToAbsent || auditModifiedTime != null) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime);
    }
    map['client_reference_id'] = Variable<String>(clientReferenceId);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || rowVersion != null) {
      map['row_version'] = Variable<int>(rowVersion);
    }
    if (!nullToAbsent || additionalFields != null) {
      map['additional_fields'] = Variable<String>(additionalFields);
    }
    return map;
  }

  ReferralCompanion toCompanion(bool nullToAbsent) {
    return ReferralCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      projectId: projectId == null && nullToAbsent
          ? const Value.absent()
          : Value(projectId),
      projectBeneficiaryClientReferenceId:
          projectBeneficiaryClientReferenceId == null && nullToAbsent
              ? const Value.absent()
              : Value(projectBeneficiaryClientReferenceId),
      referrerId: referrerId == null && nullToAbsent
          ? const Value.absent()
          : Value(referrerId),
      recipientType: recipientType == null && nullToAbsent
          ? const Value.absent()
          : Value(recipientType),
      recipientId: recipientId == null && nullToAbsent
          ? const Value.absent()
          : Value(recipientId),
      reasons: reasons == null && nullToAbsent
          ? const Value.absent()
          : Value(reasons),
      auditCreatedBy: auditCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedBy),
      nonRecoverableError: nonRecoverableError == null && nullToAbsent
          ? const Value.absent()
          : Value(nonRecoverableError),
      auditCreatedTime: auditCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditCreatedTime),
      clientCreatedTime: clientCreatedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedTime),
      clientModifiedBy: clientModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedBy),
      clientCreatedBy: clientCreatedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(clientCreatedBy),
      clientModifiedTime: clientModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(clientModifiedTime),
      auditModifiedBy: auditModifiedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedBy),
      auditModifiedTime: auditModifiedTime == null && nullToAbsent
          ? const Value.absent()
          : Value(auditModifiedTime),
      clientReferenceId: Value(clientReferenceId),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      rowVersion: rowVersion == null && nullToAbsent
          ? const Value.absent()
          : Value(rowVersion),
      additionalFields: additionalFields == null && nullToAbsent
          ? const Value.absent()
          : Value(additionalFields),
    );
  }

  factory ReferralData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ReferralData(
      id: serializer.fromJson<String?>(json['id']),
      projectId: serializer.fromJson<String?>(json['projectId']),
      projectBeneficiaryClientReferenceId: serializer
          .fromJson<String?>(json['projectBeneficiaryClientReferenceId']),
      referrerId: serializer.fromJson<String?>(json['referrerId']),
      recipientType: serializer.fromJson<String?>(json['recipientType']),
      recipientId: serializer.fromJson<String?>(json['recipientId']),
      reasons: serializer.fromJson<String?>(json['reasons']),
      auditCreatedBy: serializer.fromJson<String?>(json['auditCreatedBy']),
      nonRecoverableError:
          serializer.fromJson<bool?>(json['nonRecoverableError']),
      auditCreatedTime: serializer.fromJson<int?>(json['auditCreatedTime']),
      clientCreatedTime: serializer.fromJson<int?>(json['clientCreatedTime']),
      clientModifiedBy: serializer.fromJson<String?>(json['clientModifiedBy']),
      clientCreatedBy: serializer.fromJson<String?>(json['clientCreatedBy']),
      clientModifiedTime: serializer.fromJson<int?>(json['clientModifiedTime']),
      auditModifiedBy: serializer.fromJson<String?>(json['auditModifiedBy']),
      auditModifiedTime: serializer.fromJson<int?>(json['auditModifiedTime']),
      clientReferenceId: serializer.fromJson<String>(json['clientReferenceId']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
      rowVersion: serializer.fromJson<int?>(json['rowVersion']),
      additionalFields: serializer.fromJson<String?>(json['additionalFields']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String?>(id),
      'projectId': serializer.toJson<String?>(projectId),
      'projectBeneficiaryClientReferenceId':
          serializer.toJson<String?>(projectBeneficiaryClientReferenceId),
      'referrerId': serializer.toJson<String?>(referrerId),
      'recipientType': serializer.toJson<String?>(recipientType),
      'recipientId': serializer.toJson<String?>(recipientId),
      'reasons': serializer.toJson<String?>(reasons),
      'auditCreatedBy': serializer.toJson<String?>(auditCreatedBy),
      'nonRecoverableError': serializer.toJson<bool?>(nonRecoverableError),
      'auditCreatedTime': serializer.toJson<int?>(auditCreatedTime),
      'clientCreatedTime': serializer.toJson<int?>(clientCreatedTime),
      'clientModifiedBy': serializer.toJson<String?>(clientModifiedBy),
      'clientCreatedBy': serializer.toJson<String?>(clientCreatedBy),
      'clientModifiedTime': serializer.toJson<int?>(clientModifiedTime),
      'auditModifiedBy': serializer.toJson<String?>(auditModifiedBy),
      'auditModifiedTime': serializer.toJson<int?>(auditModifiedTime),
      'clientReferenceId': serializer.toJson<String>(clientReferenceId),
      'tenantId': serializer.toJson<String?>(tenantId),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
      'rowVersion': serializer.toJson<int?>(rowVersion),
      'additionalFields': serializer.toJson<String?>(additionalFields),
    };
  }

  ReferralData copyWith(
          {Value<String?> id = const Value.absent(),
          Value<String?> projectId = const Value.absent(),
          Value<String?> projectBeneficiaryClientReferenceId =
              const Value.absent(),
          Value<String?> referrerId = const Value.absent(),
          Value<String?> recipientType = const Value.absent(),
          Value<String?> recipientId = const Value.absent(),
          Value<String?> reasons = const Value.absent(),
          Value<String?> auditCreatedBy = const Value.absent(),
          Value<bool?> nonRecoverableError = const Value.absent(),
          Value<int?> auditCreatedTime = const Value.absent(),
          Value<int?> clientCreatedTime = const Value.absent(),
          Value<String?> clientModifiedBy = const Value.absent(),
          Value<String?> clientCreatedBy = const Value.absent(),
          Value<int?> clientModifiedTime = const Value.absent(),
          Value<String?> auditModifiedBy = const Value.absent(),
          Value<int?> auditModifiedTime = const Value.absent(),
          String? clientReferenceId,
          Value<String?> tenantId = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent(),
          Value<int?> rowVersion = const Value.absent(),
          Value<String?> additionalFields = const Value.absent()}) =>
      ReferralData(
        id: id.present ? id.value : this.id,
        projectId: projectId.present ? projectId.value : this.projectId,
        projectBeneficiaryClientReferenceId:
            projectBeneficiaryClientReferenceId.present
                ? projectBeneficiaryClientReferenceId.value
                : this.projectBeneficiaryClientReferenceId,
        referrerId: referrerId.present ? referrerId.value : this.referrerId,
        recipientType:
            recipientType.present ? recipientType.value : this.recipientType,
        recipientId: recipientId.present ? recipientId.value : this.recipientId,
        reasons: reasons.present ? reasons.value : this.reasons,
        auditCreatedBy:
            auditCreatedBy.present ? auditCreatedBy.value : this.auditCreatedBy,
        nonRecoverableError: nonRecoverableError.present
            ? nonRecoverableError.value
            : this.nonRecoverableError,
        auditCreatedTime: auditCreatedTime.present
            ? auditCreatedTime.value
            : this.auditCreatedTime,
        clientCreatedTime: clientCreatedTime.present
            ? clientCreatedTime.value
            : this.clientCreatedTime,
        clientModifiedBy: clientModifiedBy.present
            ? clientModifiedBy.value
            : this.clientModifiedBy,
        clientCreatedBy: clientCreatedBy.present
            ? clientCreatedBy.value
            : this.clientCreatedBy,
        clientModifiedTime: clientModifiedTime.present
            ? clientModifiedTime.value
            : this.clientModifiedTime,
        auditModifiedBy: auditModifiedBy.present
            ? auditModifiedBy.value
            : this.auditModifiedBy,
        auditModifiedTime: auditModifiedTime.present
            ? auditModifiedTime.value
            : this.auditModifiedTime,
        clientReferenceId: clientReferenceId ?? this.clientReferenceId,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
        rowVersion: rowVersion.present ? rowVersion.value : this.rowVersion,
        additionalFields: additionalFields.present
            ? additionalFields.value
            : this.additionalFields,
      );
  @override
  String toString() {
    return (StringBuffer('ReferralData(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write(
              'projectBeneficiaryClientReferenceId: $projectBeneficiaryClientReferenceId, ')
          ..write('referrerId: $referrerId, ')
          ..write('recipientType: $recipientType, ')
          ..write('recipientId: $recipientId, ')
          ..write('reasons: $reasons, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        projectId,
        projectBeneficiaryClientReferenceId,
        referrerId,
        recipientType,
        recipientId,
        reasons,
        auditCreatedBy,
        nonRecoverableError,
        auditCreatedTime,
        clientCreatedTime,
        clientModifiedBy,
        clientCreatedBy,
        clientModifiedTime,
        auditModifiedBy,
        auditModifiedTime,
        clientReferenceId,
        tenantId,
        isDeleted,
        rowVersion,
        additionalFields
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ReferralData &&
          other.id == this.id &&
          other.projectId == this.projectId &&
          other.projectBeneficiaryClientReferenceId ==
              this.projectBeneficiaryClientReferenceId &&
          other.referrerId == this.referrerId &&
          other.recipientType == this.recipientType &&
          other.recipientId == this.recipientId &&
          other.reasons == this.reasons &&
          other.auditCreatedBy == this.auditCreatedBy &&
          other.nonRecoverableError == this.nonRecoverableError &&
          other.auditCreatedTime == this.auditCreatedTime &&
          other.clientCreatedTime == this.clientCreatedTime &&
          other.clientModifiedBy == this.clientModifiedBy &&
          other.clientCreatedBy == this.clientCreatedBy &&
          other.clientModifiedTime == this.clientModifiedTime &&
          other.auditModifiedBy == this.auditModifiedBy &&
          other.auditModifiedTime == this.auditModifiedTime &&
          other.clientReferenceId == this.clientReferenceId &&
          other.tenantId == this.tenantId &&
          other.isDeleted == this.isDeleted &&
          other.rowVersion == this.rowVersion &&
          other.additionalFields == this.additionalFields);
}

class ReferralCompanion extends UpdateCompanion<ReferralData> {
  final Value<String?> id;
  final Value<String?> projectId;
  final Value<String?> projectBeneficiaryClientReferenceId;
  final Value<String?> referrerId;
  final Value<String?> recipientType;
  final Value<String?> recipientId;
  final Value<String?> reasons;
  final Value<String?> auditCreatedBy;
  final Value<bool?> nonRecoverableError;
  final Value<int?> auditCreatedTime;
  final Value<int?> clientCreatedTime;
  final Value<String?> clientModifiedBy;
  final Value<String?> clientCreatedBy;
  final Value<int?> clientModifiedTime;
  final Value<String?> auditModifiedBy;
  final Value<int?> auditModifiedTime;
  final Value<String> clientReferenceId;
  final Value<String?> tenantId;
  final Value<bool?> isDeleted;
  final Value<int?> rowVersion;
  final Value<String?> additionalFields;
  final Value<int> rowid;
  const ReferralCompanion({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.projectBeneficiaryClientReferenceId = const Value.absent(),
    this.referrerId = const Value.absent(),
    this.recipientType = const Value.absent(),
    this.recipientId = const Value.absent(),
    this.reasons = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    this.clientReferenceId = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ReferralCompanion.insert({
    this.id = const Value.absent(),
    this.projectId = const Value.absent(),
    this.projectBeneficiaryClientReferenceId = const Value.absent(),
    this.referrerId = const Value.absent(),
    this.recipientType = const Value.absent(),
    this.recipientId = const Value.absent(),
    this.reasons = const Value.absent(),
    this.auditCreatedBy = const Value.absent(),
    this.nonRecoverableError = const Value.absent(),
    this.auditCreatedTime = const Value.absent(),
    this.clientCreatedTime = const Value.absent(),
    this.clientModifiedBy = const Value.absent(),
    this.clientCreatedBy = const Value.absent(),
    this.clientModifiedTime = const Value.absent(),
    this.auditModifiedBy = const Value.absent(),
    this.auditModifiedTime = const Value.absent(),
    required String clientReferenceId,
    this.tenantId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowVersion = const Value.absent(),
    this.additionalFields = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : clientReferenceId = Value(clientReferenceId);
  static Insertable<ReferralData> custom({
    Expression<String>? id,
    Expression<String>? projectId,
    Expression<String>? projectBeneficiaryClientReferenceId,
    Expression<String>? referrerId,
    Expression<String>? recipientType,
    Expression<String>? recipientId,
    Expression<String>? reasons,
    Expression<String>? auditCreatedBy,
    Expression<bool>? nonRecoverableError,
    Expression<int>? auditCreatedTime,
    Expression<int>? clientCreatedTime,
    Expression<String>? clientModifiedBy,
    Expression<String>? clientCreatedBy,
    Expression<int>? clientModifiedTime,
    Expression<String>? auditModifiedBy,
    Expression<int>? auditModifiedTime,
    Expression<String>? clientReferenceId,
    Expression<String>? tenantId,
    Expression<bool>? isDeleted,
    Expression<int>? rowVersion,
    Expression<String>? additionalFields,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (projectId != null) 'project_id': projectId,
      if (projectBeneficiaryClientReferenceId != null)
        'project_beneficiary_client_reference_id':
            projectBeneficiaryClientReferenceId,
      if (referrerId != null) 'referrer_id': referrerId,
      if (recipientType != null) 'recipient_type': recipientType,
      if (recipientId != null) 'recipient_id': recipientId,
      if (reasons != null) 'reasons': reasons,
      if (auditCreatedBy != null) 'audit_created_by': auditCreatedBy,
      if (nonRecoverableError != null)
        'non_recoverable_error': nonRecoverableError,
      if (auditCreatedTime != null) 'audit_created_time': auditCreatedTime,
      if (clientCreatedTime != null) 'client_created_time': clientCreatedTime,
      if (clientModifiedBy != null) 'client_modified_by': clientModifiedBy,
      if (clientCreatedBy != null) 'client_created_by': clientCreatedBy,
      if (clientModifiedTime != null)
        'client_modified_time': clientModifiedTime,
      if (auditModifiedBy != null) 'audit_modified_by': auditModifiedBy,
      if (auditModifiedTime != null) 'audit_modified_time': auditModifiedTime,
      if (clientReferenceId != null) 'client_reference_id': clientReferenceId,
      if (tenantId != null) 'tenant_id': tenantId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowVersion != null) 'row_version': rowVersion,
      if (additionalFields != null) 'additional_fields': additionalFields,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ReferralCompanion copyWith(
      {Value<String?>? id,
      Value<String?>? projectId,
      Value<String?>? projectBeneficiaryClientReferenceId,
      Value<String?>? referrerId,
      Value<String?>? recipientType,
      Value<String?>? recipientId,
      Value<String?>? reasons,
      Value<String?>? auditCreatedBy,
      Value<bool?>? nonRecoverableError,
      Value<int?>? auditCreatedTime,
      Value<int?>? clientCreatedTime,
      Value<String?>? clientModifiedBy,
      Value<String?>? clientCreatedBy,
      Value<int?>? clientModifiedTime,
      Value<String?>? auditModifiedBy,
      Value<int?>? auditModifiedTime,
      Value<String>? clientReferenceId,
      Value<String?>? tenantId,
      Value<bool?>? isDeleted,
      Value<int?>? rowVersion,
      Value<String?>? additionalFields,
      Value<int>? rowid}) {
    return ReferralCompanion(
      id: id ?? this.id,
      projectId: projectId ?? this.projectId,
      projectBeneficiaryClientReferenceId:
          projectBeneficiaryClientReferenceId ??
              this.projectBeneficiaryClientReferenceId,
      referrerId: referrerId ?? this.referrerId,
      recipientType: recipientType ?? this.recipientType,
      recipientId: recipientId ?? this.recipientId,
      reasons: reasons ?? this.reasons,
      auditCreatedBy: auditCreatedBy ?? this.auditCreatedBy,
      nonRecoverableError: nonRecoverableError ?? this.nonRecoverableError,
      auditCreatedTime: auditCreatedTime ?? this.auditCreatedTime,
      clientCreatedTime: clientCreatedTime ?? this.clientCreatedTime,
      clientModifiedBy: clientModifiedBy ?? this.clientModifiedBy,
      clientCreatedBy: clientCreatedBy ?? this.clientCreatedBy,
      clientModifiedTime: clientModifiedTime ?? this.clientModifiedTime,
      auditModifiedBy: auditModifiedBy ?? this.auditModifiedBy,
      auditModifiedTime: auditModifiedTime ?? this.auditModifiedTime,
      clientReferenceId: clientReferenceId ?? this.clientReferenceId,
      tenantId: tenantId ?? this.tenantId,
      isDeleted: isDeleted ?? this.isDeleted,
      rowVersion: rowVersion ?? this.rowVersion,
      additionalFields: additionalFields ?? this.additionalFields,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (projectId.present) {
      map['project_id'] = Variable<String>(projectId.value);
    }
    if (projectBeneficiaryClientReferenceId.present) {
      map['project_beneficiary_client_reference_id'] =
          Variable<String>(projectBeneficiaryClientReferenceId.value);
    }
    if (referrerId.present) {
      map['referrer_id'] = Variable<String>(referrerId.value);
    }
    if (recipientType.present) {
      map['recipient_type'] = Variable<String>(recipientType.value);
    }
    if (recipientId.present) {
      map['recipient_id'] = Variable<String>(recipientId.value);
    }
    if (reasons.present) {
      map['reasons'] = Variable<String>(reasons.value);
    }
    if (auditCreatedBy.present) {
      map['audit_created_by'] = Variable<String>(auditCreatedBy.value);
    }
    if (nonRecoverableError.present) {
      map['non_recoverable_error'] = Variable<bool>(nonRecoverableError.value);
    }
    if (auditCreatedTime.present) {
      map['audit_created_time'] = Variable<int>(auditCreatedTime.value);
    }
    if (clientCreatedTime.present) {
      map['client_created_time'] = Variable<int>(clientCreatedTime.value);
    }
    if (clientModifiedBy.present) {
      map['client_modified_by'] = Variable<String>(clientModifiedBy.value);
    }
    if (clientCreatedBy.present) {
      map['client_created_by'] = Variable<String>(clientCreatedBy.value);
    }
    if (clientModifiedTime.present) {
      map['client_modified_time'] = Variable<int>(clientModifiedTime.value);
    }
    if (auditModifiedBy.present) {
      map['audit_modified_by'] = Variable<String>(auditModifiedBy.value);
    }
    if (auditModifiedTime.present) {
      map['audit_modified_time'] = Variable<int>(auditModifiedTime.value);
    }
    if (clientReferenceId.present) {
      map['client_reference_id'] = Variable<String>(clientReferenceId.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowVersion.present) {
      map['row_version'] = Variable<int>(rowVersion.value);
    }
    if (additionalFields.present) {
      map['additional_fields'] = Variable<String>(additionalFields.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ReferralCompanion(')
          ..write('id: $id, ')
          ..write('projectId: $projectId, ')
          ..write(
              'projectBeneficiaryClientReferenceId: $projectBeneficiaryClientReferenceId, ')
          ..write('referrerId: $referrerId, ')
          ..write('recipientType: $recipientType, ')
          ..write('recipientId: $recipientId, ')
          ..write('reasons: $reasons, ')
          ..write('auditCreatedBy: $auditCreatedBy, ')
          ..write('nonRecoverableError: $nonRecoverableError, ')
          ..write('auditCreatedTime: $auditCreatedTime, ')
          ..write('clientCreatedTime: $clientCreatedTime, ')
          ..write('clientModifiedBy: $clientModifiedBy, ')
          ..write('clientCreatedBy: $clientCreatedBy, ')
          ..write('clientModifiedTime: $clientModifiedTime, ')
          ..write('auditModifiedBy: $auditModifiedBy, ')
          ..write('auditModifiedTime: $auditModifiedTime, ')
          ..write('clientReferenceId: $clientReferenceId, ')
          ..write('tenantId: $tenantId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowVersion: $rowVersion, ')
          ..write('additionalFields: $additionalFields, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$LocalSqlDataStore extends GeneratedDatabase {
  _$LocalSqlDataStore(QueryExecutor e) : super(e);
  late final $AttendanceRegisterTable attendanceRegister =
      $AttendanceRegisterTable(this);
  late final $AttendanceTable attendance = $AttendanceTable(this);
  late final $AttendeeTable attendee = $AttendeeTable(this);
  late final $AddressTable address = $AddressTable(this);
  late final $NameTable name = $NameTable(this);
  late final $BoundaryTable boundary = $BoundaryTable(this);
  late final $DocumentTable document = $DocumentTable(this);
  late final $FacilityTable facility = $FacilityTable(this);
  late final $ProductTable product = $ProductTable(this);
  late final $ProductVariantTable productVariant = $ProductVariantTable(this);
  late final $ProjectTable project = $ProjectTable(this);
  late final $ProjectBeneficiaryTable projectBeneficiary =
      $ProjectBeneficiaryTable(this);
  late final $ProjectFacilityTable projectFacility =
      $ProjectFacilityTable(this);
  late final $ProjectProductVariantTable projectProductVariant =
      $ProjectProductVariantTable(this);
  late final $ProjectResourceTable projectResource =
      $ProjectResourceTable(this);
  late final $ProjectStaffTable projectStaff = $ProjectStaffTable(this);
  late final $ProjectTypeTable projectType = $ProjectTypeTable(this);
  late final $IndividualTable individual = $IndividualTable(this);
  late final $IdentifierTable identifier = $IdentifierTable(this);
  late final $StockTable stock = $StockTable(this);
  late final $StockReconciliationTable stockReconciliation =
      $StockReconciliationTable(this);
  late final $TargetTable target = $TargetTable(this);
  late final $ServiceTable service = $ServiceTable(this);
  late final $ServiceAttributesTable serviceAttributes =
      $ServiceAttributesTable(this);
  late final $ServiceDefinitionTable serviceDefinition =
      $ServiceDefinitionTable(this);
  late final $LocalityTable locality = $LocalityTable(this);
  late final $StaffTable staff = $StaffTable(this);
  late final $AttributesTable attributes = $AttributesTable(this);
  late final $PgrServiceTable pgrService = $PgrServiceTable(this);
  late final $PgrComplainantTable pgrComplainant = $PgrComplainantTable(this);
  late final $UserTable user = $UserTable(this);
  late final $DownsyncTable downsync = $DownsyncTable(this);
  late final $DownsyncCriteriaTable downsyncCriteria =
      $DownsyncCriteriaTable(this);
  late final $HFReferralTable hFReferral = $HFReferralTable(this);
  late final $HouseholdTable household = $HouseholdTable(this);
  late final $HouseholdMemberTable householdMember =
      $HouseholdMemberTable(this);
  late final $TaskTable task = $TaskTable(this);
  late final $TaskResourceTable taskResource = $TaskResourceTable(this);
  late final $SideEffectTable sideEffect = $SideEffectTable(this);
  late final $ReferralTable referral = $ReferralTable(this);
  late final Index attendanceClientref = Index('attendance_clientref',
      'CREATE INDEX attendance_clientref ON attendance (client_reference_id)');
  late final Index attendanceIndividualid = Index('attendance_individualid',
      'CREATE INDEX attendance_individualid ON attendance (individual_id)');
  late final Index projectClinetref = Index('project_clinetref',
      'CREATE INDEX project_clinetref ON project_beneficiary (client_reference_id)');
  late final Index projectProjectid = Index('project_projectid',
      'CREATE INDEX project_projectid ON project_beneficiary (project_id)');
  late final Index projectProjectbeneficiaryclientref = Index(
      'project_projectbeneficiaryclientref',
      'CREATE INDEX project_projectbeneficiaryclientref ON project_beneficiary (beneficiary_client_reference_id)');
  late final Index stockClientref = Index('stock_clientref',
      'CREATE INDEX stock_clientref ON stock (client_reference_id)');
  late final Index stockProductvariantid = Index('stock_productvariantid',
      'CREATE INDEX stock_productvariantid ON stock (product_variant_id)');
  late final Index stockFacilityid = Index('stock_facilityid',
      'CREATE INDEX stock_facilityid ON stock (facility_id)');
  late final Index stockreconClientref = Index('stockrecon_clientref',
      'CREATE INDEX stockrecon_clientref ON stock_reconciliation (client_reference_id)');
  late final Index stockreconFacilityid = Index('stockrecon_facilityid',
      'CREATE INDEX stockrecon_facilityid ON stock_reconciliation (facility_id)');
  late final Index stockreconProductvariantid = Index(
      'stockrecon_productvariantid',
      'CREATE INDEX stockrecon_productvariantid ON stock_reconciliation (product_variant_id)');
  late final Index hfreferralClientref = Index('hfreferral_clientref',
      'CREATE INDEX hfreferral_clientref ON h_f_referral (client_reference_id)');
  late final Index hfreferralProjectid = Index('hfreferral_projectid',
      'CREATE INDEX hfreferral_projectid ON h_f_referral (project_id)');
  late final Index householdmemberClinetref = Index('householdmember_clinetref',
      'CREATE INDEX householdmember_clinetref ON household_member (client_reference_id)');
  late final Index householdClientref = Index('household_clientref',
      'CREATE INDEX household_clientref ON household_member (household_client_reference_id)');
  late final Index householdmemberIndividualid = Index(
      'householdmember_individualid',
      'CREATE INDEX householdmember_individualid ON household_member (individual_client_reference_id)');
  late final Index taskClinetref = Index('task_clinetref',
      'CREATE INDEX task_clinetref ON task (client_reference_id)');
  late final Index taskProjectid = Index(
      'task_projectid', 'CREATE INDEX task_projectid ON task (project_id)');
  late final Index taskProjectbeneficiaryid = Index('task_projectbeneficiaryid',
      'CREATE INDEX task_projectbeneficiaryid ON task (project_beneficiary_id)');
  late final Index taskProjectbeneficiaryclientref = Index(
      'task_projectbeneficiaryclientref',
      'CREATE INDEX task_projectbeneficiaryclientref ON task (project_beneficiary_client_reference_id)');
  late final Index taskresourceclinetref = Index('taskresourceclinetref',
      'CREATE INDEX taskresourceclinetref ON task_resource (client_reference_id)');
  late final Index taskresourceTaskclientref = Index(
      'taskresource_taskclientref',
      'CREATE INDEX taskresource_taskclientref ON task_resource (taskclient_reference_id)');
  late final Index taskresourceProductvariantid = Index(
      'taskresource_productvariantid',
      'CREATE INDEX taskresource_productvariantid ON task_resource (product_variant_id)');
  late final Index sideeffectClinetref = Index('sideeffect_clinetref',
      'CREATE INDEX sideeffect_clinetref ON side_effect (client_reference_id)');
  late final Index sideeffectProjectid = Index('sideeffect_projectid',
      'CREATE INDEX sideeffect_projectid ON side_effect (project_id)');
  late final Index sideeffectTaskclientref = Index('sideeffect_taskclientref',
      'CREATE INDEX sideeffect_taskclientref ON side_effect (task_client_reference_id)');
  late final Index referralClinetref = Index('referral_clinetref',
      'CREATE INDEX referral_clinetref ON referral (client_reference_id)');
  late final Index referralProjectid = Index('referral_projectid',
      'CREATE INDEX referral_projectid ON referral (project_id)');
  late final Index referralProjectbeneficiaryclientref = Index(
      'referral_projectbeneficiaryclientref',
      'CREATE INDEX referral_projectbeneficiaryclientref ON referral (project_beneficiary_client_reference_id)');
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        attendanceRegister,
        attendance,
        attendee,
        address,
        name,
        boundary,
        document,
        facility,
        product,
        productVariant,
        project,
        projectBeneficiary,
        projectFacility,
        projectProductVariant,
        projectResource,
        projectStaff,
        projectType,
        individual,
        identifier,
        stock,
        stockReconciliation,
        target,
        service,
        serviceAttributes,
        serviceDefinition,
        locality,
        staff,
        attributes,
        pgrService,
        pgrComplainant,
        user,
        downsync,
        downsyncCriteria,
        hFReferral,
        household,
        householdMember,
        task,
        taskResource,
        sideEffect,
        referral,
        attendanceClientref,
        attendanceIndividualid,
        projectClinetref,
        projectProjectid,
        projectProjectbeneficiaryclientref,
        stockClientref,
        stockProductvariantid,
        stockFacilityid,
        stockreconClientref,
        stockreconFacilityid,
        stockreconProductvariantid,
        hfreferralClientref,
        hfreferralProjectid,
        householdmemberClinetref,
        householdClientref,
        householdmemberIndividualid,
        taskClinetref,
        taskProjectid,
        taskProjectbeneficiaryid,
        taskProjectbeneficiaryclientref,
        taskresourceclinetref,
        taskresourceTaskclientref,
        taskresourceProductvariantid,
        sideeffectClinetref,
        sideeffectProjectid,
        sideeffectTaskclientref,
        referralClinetref,
        referralProjectid,
        referralProjectbeneficiaryclientref
      ];
}
