// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'search_households.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SearchHouseholdsEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(String projectId, HouseholdModel householdModel)
        searchByHousehold,
    required TResult Function(String searchText, String projectId)
        searchByHouseholdHead,
    required TResult Function() clear,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialize,
    TResult? Function(String projectId, HouseholdModel householdModel)?
        searchByHousehold,
    TResult? Function(String searchText, String projectId)?
        searchByHouseholdHead,
    TResult? Function()? clear,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(String projectId, HouseholdModel householdModel)?
        searchByHousehold,
    TResult Function(String searchText, String projectId)?
        searchByHouseholdHead,
    TResult Function()? clear,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SearchHouseholdsInitializedEvent value)
        initialize,
    required TResult Function(SearchHouseholdsByHouseholdsEvent value)
        searchByHousehold,
    required TResult Function(SearchHouseholdsSearchByHouseholdHeadEvent value)
        searchByHouseholdHead,
    required TResult Function(SearchHouseholdsClearEvent value) clear,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SearchHouseholdsInitializedEvent value)? initialize,
    TResult? Function(SearchHouseholdsByHouseholdsEvent value)?
        searchByHousehold,
    TResult? Function(SearchHouseholdsSearchByHouseholdHeadEvent value)?
        searchByHouseholdHead,
    TResult? Function(SearchHouseholdsClearEvent value)? clear,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SearchHouseholdsInitializedEvent value)? initialize,
    TResult Function(SearchHouseholdsByHouseholdsEvent value)?
        searchByHousehold,
    TResult Function(SearchHouseholdsSearchByHouseholdHeadEvent value)?
        searchByHouseholdHead,
    TResult Function(SearchHouseholdsClearEvent value)? clear,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SearchHouseholdsEventCopyWith<$Res> {
  factory $SearchHouseholdsEventCopyWith(SearchHouseholdsEvent value,
          $Res Function(SearchHouseholdsEvent) then) =
      _$SearchHouseholdsEventCopyWithImpl<$Res, SearchHouseholdsEvent>;
}

/// @nodoc
class _$SearchHouseholdsEventCopyWithImpl<$Res,
        $Val extends SearchHouseholdsEvent>
    implements $SearchHouseholdsEventCopyWith<$Res> {
  _$SearchHouseholdsEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SearchHouseholdsInitializedEventCopyWith<$Res> {
  factory _$$SearchHouseholdsInitializedEventCopyWith(
          _$SearchHouseholdsInitializedEvent value,
          $Res Function(_$SearchHouseholdsInitializedEvent) then) =
      __$$SearchHouseholdsInitializedEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SearchHouseholdsInitializedEventCopyWithImpl<$Res>
    extends _$SearchHouseholdsEventCopyWithImpl<$Res,
        _$SearchHouseholdsInitializedEvent>
    implements _$$SearchHouseholdsInitializedEventCopyWith<$Res> {
  __$$SearchHouseholdsInitializedEventCopyWithImpl(
      _$SearchHouseholdsInitializedEvent _value,
      $Res Function(_$SearchHouseholdsInitializedEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SearchHouseholdsInitializedEvent
    implements SearchHouseholdsInitializedEvent {
  const _$SearchHouseholdsInitializedEvent();

  @override
  String toString() {
    return 'SearchHouseholdsEvent.initialize()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchHouseholdsInitializedEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(String projectId, HouseholdModel householdModel)
        searchByHousehold,
    required TResult Function(String searchText, String projectId)
        searchByHouseholdHead,
    required TResult Function() clear,
  }) {
    return initialize();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialize,
    TResult? Function(String projectId, HouseholdModel householdModel)?
        searchByHousehold,
    TResult? Function(String searchText, String projectId)?
        searchByHouseholdHead,
    TResult? Function()? clear,
  }) {
    return initialize?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(String projectId, HouseholdModel householdModel)?
        searchByHousehold,
    TResult Function(String searchText, String projectId)?
        searchByHouseholdHead,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (initialize != null) {
      return initialize();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SearchHouseholdsInitializedEvent value)
        initialize,
    required TResult Function(SearchHouseholdsByHouseholdsEvent value)
        searchByHousehold,
    required TResult Function(SearchHouseholdsSearchByHouseholdHeadEvent value)
        searchByHouseholdHead,
    required TResult Function(SearchHouseholdsClearEvent value) clear,
  }) {
    return initialize(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SearchHouseholdsInitializedEvent value)? initialize,
    TResult? Function(SearchHouseholdsByHouseholdsEvent value)?
        searchByHousehold,
    TResult? Function(SearchHouseholdsSearchByHouseholdHeadEvent value)?
        searchByHouseholdHead,
    TResult? Function(SearchHouseholdsClearEvent value)? clear,
  }) {
    return initialize?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SearchHouseholdsInitializedEvent value)? initialize,
    TResult Function(SearchHouseholdsByHouseholdsEvent value)?
        searchByHousehold,
    TResult Function(SearchHouseholdsSearchByHouseholdHeadEvent value)?
        searchByHouseholdHead,
    TResult Function(SearchHouseholdsClearEvent value)? clear,
    required TResult orElse(),
  }) {
    if (initialize != null) {
      return initialize(this);
    }
    return orElse();
  }
}

abstract class SearchHouseholdsInitializedEvent
    implements SearchHouseholdsEvent {
  const factory SearchHouseholdsInitializedEvent() =
      _$SearchHouseholdsInitializedEvent;
}

/// @nodoc
abstract class _$$SearchHouseholdsByHouseholdsEventCopyWith<$Res> {
  factory _$$SearchHouseholdsByHouseholdsEventCopyWith(
          _$SearchHouseholdsByHouseholdsEvent value,
          $Res Function(_$SearchHouseholdsByHouseholdsEvent) then) =
      __$$SearchHouseholdsByHouseholdsEventCopyWithImpl<$Res>;
  @useResult
  $Res call({String projectId, HouseholdModel householdModel});
}

/// @nodoc
class __$$SearchHouseholdsByHouseholdsEventCopyWithImpl<$Res>
    extends _$SearchHouseholdsEventCopyWithImpl<$Res,
        _$SearchHouseholdsByHouseholdsEvent>
    implements _$$SearchHouseholdsByHouseholdsEventCopyWith<$Res> {
  __$$SearchHouseholdsByHouseholdsEventCopyWithImpl(
      _$SearchHouseholdsByHouseholdsEvent _value,
      $Res Function(_$SearchHouseholdsByHouseholdsEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? projectId = null,
    Object? householdModel = null,
  }) {
    return _then(_$SearchHouseholdsByHouseholdsEvent(
      projectId: null == projectId
          ? _value.projectId
          : projectId // ignore: cast_nullable_to_non_nullable
              as String,
      householdModel: null == householdModel
          ? _value.householdModel
          : householdModel // ignore: cast_nullable_to_non_nullable
              as HouseholdModel,
    ));
  }
}

/// @nodoc

class _$SearchHouseholdsByHouseholdsEvent
    implements SearchHouseholdsByHouseholdsEvent {
  const _$SearchHouseholdsByHouseholdsEvent(
      {required this.projectId, required this.householdModel});

  @override
  final String projectId;
  @override
  final HouseholdModel householdModel;

  @override
  String toString() {
    return 'SearchHouseholdsEvent.searchByHousehold(projectId: $projectId, householdModel: $householdModel)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchHouseholdsByHouseholdsEvent &&
            (identical(other.projectId, projectId) ||
                other.projectId == projectId) &&
            (identical(other.householdModel, householdModel) ||
                other.householdModel == householdModel));
  }

  @override
  int get hashCode => Object.hash(runtimeType, projectId, householdModel);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SearchHouseholdsByHouseholdsEventCopyWith<
          _$SearchHouseholdsByHouseholdsEvent>
      get copyWith => __$$SearchHouseholdsByHouseholdsEventCopyWithImpl<
          _$SearchHouseholdsByHouseholdsEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(String projectId, HouseholdModel householdModel)
        searchByHousehold,
    required TResult Function(String searchText, String projectId)
        searchByHouseholdHead,
    required TResult Function() clear,
  }) {
    return searchByHousehold(projectId, householdModel);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialize,
    TResult? Function(String projectId, HouseholdModel householdModel)?
        searchByHousehold,
    TResult? Function(String searchText, String projectId)?
        searchByHouseholdHead,
    TResult? Function()? clear,
  }) {
    return searchByHousehold?.call(projectId, householdModel);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(String projectId, HouseholdModel householdModel)?
        searchByHousehold,
    TResult Function(String searchText, String projectId)?
        searchByHouseholdHead,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (searchByHousehold != null) {
      return searchByHousehold(projectId, householdModel);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SearchHouseholdsInitializedEvent value)
        initialize,
    required TResult Function(SearchHouseholdsByHouseholdsEvent value)
        searchByHousehold,
    required TResult Function(SearchHouseholdsSearchByHouseholdHeadEvent value)
        searchByHouseholdHead,
    required TResult Function(SearchHouseholdsClearEvent value) clear,
  }) {
    return searchByHousehold(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SearchHouseholdsInitializedEvent value)? initialize,
    TResult? Function(SearchHouseholdsByHouseholdsEvent value)?
        searchByHousehold,
    TResult? Function(SearchHouseholdsSearchByHouseholdHeadEvent value)?
        searchByHouseholdHead,
    TResult? Function(SearchHouseholdsClearEvent value)? clear,
  }) {
    return searchByHousehold?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SearchHouseholdsInitializedEvent value)? initialize,
    TResult Function(SearchHouseholdsByHouseholdsEvent value)?
        searchByHousehold,
    TResult Function(SearchHouseholdsSearchByHouseholdHeadEvent value)?
        searchByHouseholdHead,
    TResult Function(SearchHouseholdsClearEvent value)? clear,
    required TResult orElse(),
  }) {
    if (searchByHousehold != null) {
      return searchByHousehold(this);
    }
    return orElse();
  }
}

abstract class SearchHouseholdsByHouseholdsEvent
    implements SearchHouseholdsEvent {
  const factory SearchHouseholdsByHouseholdsEvent(
          {required final String projectId,
          required final HouseholdModel householdModel}) =
      _$SearchHouseholdsByHouseholdsEvent;

  String get projectId;
  HouseholdModel get householdModel;
  @JsonKey(ignore: true)
  _$$SearchHouseholdsByHouseholdsEventCopyWith<
          _$SearchHouseholdsByHouseholdsEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SearchHouseholdsSearchByHouseholdHeadEventCopyWith<$Res> {
  factory _$$SearchHouseholdsSearchByHouseholdHeadEventCopyWith(
          _$SearchHouseholdsSearchByHouseholdHeadEvent value,
          $Res Function(_$SearchHouseholdsSearchByHouseholdHeadEvent) then) =
      __$$SearchHouseholdsSearchByHouseholdHeadEventCopyWithImpl<$Res>;
  @useResult
  $Res call({String searchText, String projectId});
}

/// @nodoc
class __$$SearchHouseholdsSearchByHouseholdHeadEventCopyWithImpl<$Res>
    extends _$SearchHouseholdsEventCopyWithImpl<$Res,
        _$SearchHouseholdsSearchByHouseholdHeadEvent>
    implements _$$SearchHouseholdsSearchByHouseholdHeadEventCopyWith<$Res> {
  __$$SearchHouseholdsSearchByHouseholdHeadEventCopyWithImpl(
      _$SearchHouseholdsSearchByHouseholdHeadEvent _value,
      $Res Function(_$SearchHouseholdsSearchByHouseholdHeadEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? searchText = null,
    Object? projectId = null,
  }) {
    return _then(_$SearchHouseholdsSearchByHouseholdHeadEvent(
      searchText: null == searchText
          ? _value.searchText
          : searchText // ignore: cast_nullable_to_non_nullable
              as String,
      projectId: null == projectId
          ? _value.projectId
          : projectId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SearchHouseholdsSearchByHouseholdHeadEvent
    implements SearchHouseholdsSearchByHouseholdHeadEvent {
  const _$SearchHouseholdsSearchByHouseholdHeadEvent(
      {required this.searchText, required this.projectId});

  @override
  final String searchText;
  @override
  final String projectId;

  @override
  String toString() {
    return 'SearchHouseholdsEvent.searchByHouseholdHead(searchText: $searchText, projectId: $projectId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchHouseholdsSearchByHouseholdHeadEvent &&
            (identical(other.searchText, searchText) ||
                other.searchText == searchText) &&
            (identical(other.projectId, projectId) ||
                other.projectId == projectId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, searchText, projectId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SearchHouseholdsSearchByHouseholdHeadEventCopyWith<
          _$SearchHouseholdsSearchByHouseholdHeadEvent>
      get copyWith =>
          __$$SearchHouseholdsSearchByHouseholdHeadEventCopyWithImpl<
              _$SearchHouseholdsSearchByHouseholdHeadEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(String projectId, HouseholdModel householdModel)
        searchByHousehold,
    required TResult Function(String searchText, String projectId)
        searchByHouseholdHead,
    required TResult Function() clear,
  }) {
    return searchByHouseholdHead(searchText, projectId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialize,
    TResult? Function(String projectId, HouseholdModel householdModel)?
        searchByHousehold,
    TResult? Function(String searchText, String projectId)?
        searchByHouseholdHead,
    TResult? Function()? clear,
  }) {
    return searchByHouseholdHead?.call(searchText, projectId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(String projectId, HouseholdModel householdModel)?
        searchByHousehold,
    TResult Function(String searchText, String projectId)?
        searchByHouseholdHead,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (searchByHouseholdHead != null) {
      return searchByHouseholdHead(searchText, projectId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SearchHouseholdsInitializedEvent value)
        initialize,
    required TResult Function(SearchHouseholdsByHouseholdsEvent value)
        searchByHousehold,
    required TResult Function(SearchHouseholdsSearchByHouseholdHeadEvent value)
        searchByHouseholdHead,
    required TResult Function(SearchHouseholdsClearEvent value) clear,
  }) {
    return searchByHouseholdHead(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SearchHouseholdsInitializedEvent value)? initialize,
    TResult? Function(SearchHouseholdsByHouseholdsEvent value)?
        searchByHousehold,
    TResult? Function(SearchHouseholdsSearchByHouseholdHeadEvent value)?
        searchByHouseholdHead,
    TResult? Function(SearchHouseholdsClearEvent value)? clear,
  }) {
    return searchByHouseholdHead?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SearchHouseholdsInitializedEvent value)? initialize,
    TResult Function(SearchHouseholdsByHouseholdsEvent value)?
        searchByHousehold,
    TResult Function(SearchHouseholdsSearchByHouseholdHeadEvent value)?
        searchByHouseholdHead,
    TResult Function(SearchHouseholdsClearEvent value)? clear,
    required TResult orElse(),
  }) {
    if (searchByHouseholdHead != null) {
      return searchByHouseholdHead(this);
    }
    return orElse();
  }
}

abstract class SearchHouseholdsSearchByHouseholdHeadEvent
    implements SearchHouseholdsEvent {
  const factory SearchHouseholdsSearchByHouseholdHeadEvent(
          {required final String searchText, required final String projectId}) =
      _$SearchHouseholdsSearchByHouseholdHeadEvent;

  String get searchText;
  String get projectId;
  @JsonKey(ignore: true)
  _$$SearchHouseholdsSearchByHouseholdHeadEventCopyWith<
          _$SearchHouseholdsSearchByHouseholdHeadEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SearchHouseholdsClearEventCopyWith<$Res> {
  factory _$$SearchHouseholdsClearEventCopyWith(
          _$SearchHouseholdsClearEvent value,
          $Res Function(_$SearchHouseholdsClearEvent) then) =
      __$$SearchHouseholdsClearEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SearchHouseholdsClearEventCopyWithImpl<$Res>
    extends _$SearchHouseholdsEventCopyWithImpl<$Res,
        _$SearchHouseholdsClearEvent>
    implements _$$SearchHouseholdsClearEventCopyWith<$Res> {
  __$$SearchHouseholdsClearEventCopyWithImpl(
      _$SearchHouseholdsClearEvent _value,
      $Res Function(_$SearchHouseholdsClearEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SearchHouseholdsClearEvent implements SearchHouseholdsClearEvent {
  const _$SearchHouseholdsClearEvent();

  @override
  String toString() {
    return 'SearchHouseholdsEvent.clear()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchHouseholdsClearEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(String projectId, HouseholdModel householdModel)
        searchByHousehold,
    required TResult Function(String searchText, String projectId)
        searchByHouseholdHead,
    required TResult Function() clear,
  }) {
    return clear();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialize,
    TResult? Function(String projectId, HouseholdModel householdModel)?
        searchByHousehold,
    TResult? Function(String searchText, String projectId)?
        searchByHouseholdHead,
    TResult? Function()? clear,
  }) {
    return clear?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(String projectId, HouseholdModel householdModel)?
        searchByHousehold,
    TResult Function(String searchText, String projectId)?
        searchByHouseholdHead,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SearchHouseholdsInitializedEvent value)
        initialize,
    required TResult Function(SearchHouseholdsByHouseholdsEvent value)
        searchByHousehold,
    required TResult Function(SearchHouseholdsSearchByHouseholdHeadEvent value)
        searchByHouseholdHead,
    required TResult Function(SearchHouseholdsClearEvent value) clear,
  }) {
    return clear(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SearchHouseholdsInitializedEvent value)? initialize,
    TResult? Function(SearchHouseholdsByHouseholdsEvent value)?
        searchByHousehold,
    TResult? Function(SearchHouseholdsSearchByHouseholdHeadEvent value)?
        searchByHouseholdHead,
    TResult? Function(SearchHouseholdsClearEvent value)? clear,
  }) {
    return clear?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SearchHouseholdsInitializedEvent value)? initialize,
    TResult Function(SearchHouseholdsByHouseholdsEvent value)?
        searchByHousehold,
    TResult Function(SearchHouseholdsSearchByHouseholdHeadEvent value)?
        searchByHouseholdHead,
    TResult Function(SearchHouseholdsClearEvent value)? clear,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear(this);
    }
    return orElse();
  }
}

abstract class SearchHouseholdsClearEvent implements SearchHouseholdsEvent {
  const factory SearchHouseholdsClearEvent() = _$SearchHouseholdsClearEvent;
}

/// @nodoc
mixin _$SearchHouseholdsState {
  bool get loading => throw _privateConstructorUsedError;
  String? get searchQuery => throw _privateConstructorUsedError;
  List<HouseholdMemberWrapper> get householdMembers =>
      throw _privateConstructorUsedError;
  int get registeredHouseholds => throw _privateConstructorUsedError;
  int get deliveredInterventions => throw _privateConstructorUsedError;
  int get adverseEventsObserved => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SearchHouseholdsStateCopyWith<SearchHouseholdsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SearchHouseholdsStateCopyWith<$Res> {
  factory $SearchHouseholdsStateCopyWith(SearchHouseholdsState value,
          $Res Function(SearchHouseholdsState) then) =
      _$SearchHouseholdsStateCopyWithImpl<$Res, SearchHouseholdsState>;
  @useResult
  $Res call(
      {bool loading,
      String? searchQuery,
      List<HouseholdMemberWrapper> householdMembers,
      int registeredHouseholds,
      int deliveredInterventions,
      int adverseEventsObserved});
}

/// @nodoc
class _$SearchHouseholdsStateCopyWithImpl<$Res,
        $Val extends SearchHouseholdsState>
    implements $SearchHouseholdsStateCopyWith<$Res> {
  _$SearchHouseholdsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? loading = null,
    Object? searchQuery = freezed,
    Object? householdMembers = null,
    Object? registeredHouseholds = null,
    Object? deliveredInterventions = null,
    Object? adverseEventsObserved = null,
  }) {
    return _then(_value.copyWith(
      loading: null == loading
          ? _value.loading
          : loading // ignore: cast_nullable_to_non_nullable
              as bool,
      searchQuery: freezed == searchQuery
          ? _value.searchQuery
          : searchQuery // ignore: cast_nullable_to_non_nullable
              as String?,
      householdMembers: null == householdMembers
          ? _value.householdMembers
          : householdMembers // ignore: cast_nullable_to_non_nullable
              as List<HouseholdMemberWrapper>,
      registeredHouseholds: null == registeredHouseholds
          ? _value.registeredHouseholds
          : registeredHouseholds // ignore: cast_nullable_to_non_nullable
              as int,
      deliveredInterventions: null == deliveredInterventions
          ? _value.deliveredInterventions
          : deliveredInterventions // ignore: cast_nullable_to_non_nullable
              as int,
      adverseEventsObserved: null == adverseEventsObserved
          ? _value.adverseEventsObserved
          : adverseEventsObserved // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SearchHouseholdsStateCopyWith<$Res>
    implements $SearchHouseholdsStateCopyWith<$Res> {
  factory _$$_SearchHouseholdsStateCopyWith(_$_SearchHouseholdsState value,
          $Res Function(_$_SearchHouseholdsState) then) =
      __$$_SearchHouseholdsStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool loading,
      String? searchQuery,
      List<HouseholdMemberWrapper> householdMembers,
      int registeredHouseholds,
      int deliveredInterventions,
      int adverseEventsObserved});
}

/// @nodoc
class __$$_SearchHouseholdsStateCopyWithImpl<$Res>
    extends _$SearchHouseholdsStateCopyWithImpl<$Res, _$_SearchHouseholdsState>
    implements _$$_SearchHouseholdsStateCopyWith<$Res> {
  __$$_SearchHouseholdsStateCopyWithImpl(_$_SearchHouseholdsState _value,
      $Res Function(_$_SearchHouseholdsState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? loading = null,
    Object? searchQuery = freezed,
    Object? householdMembers = null,
    Object? registeredHouseholds = null,
    Object? deliveredInterventions = null,
    Object? adverseEventsObserved = null,
  }) {
    return _then(_$_SearchHouseholdsState(
      loading: null == loading
          ? _value.loading
          : loading // ignore: cast_nullable_to_non_nullable
              as bool,
      searchQuery: freezed == searchQuery
          ? _value.searchQuery
          : searchQuery // ignore: cast_nullable_to_non_nullable
              as String?,
      householdMembers: null == householdMembers
          ? _value._householdMembers
          : householdMembers // ignore: cast_nullable_to_non_nullable
              as List<HouseholdMemberWrapper>,
      registeredHouseholds: null == registeredHouseholds
          ? _value.registeredHouseholds
          : registeredHouseholds // ignore: cast_nullable_to_non_nullable
              as int,
      deliveredInterventions: null == deliveredInterventions
          ? _value.deliveredInterventions
          : deliveredInterventions // ignore: cast_nullable_to_non_nullable
              as int,
      adverseEventsObserved: null == adverseEventsObserved
          ? _value.adverseEventsObserved
          : adverseEventsObserved // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_SearchHouseholdsState extends _SearchHouseholdsState {
  const _$_SearchHouseholdsState(
      {this.loading = false,
      this.searchQuery,
      final List<HouseholdMemberWrapper> householdMembers = const [],
      this.registeredHouseholds = 0,
      this.deliveredInterventions = 0,
      this.adverseEventsObserved = 0})
      : _householdMembers = householdMembers,
        super._();

  @override
  @JsonKey()
  final bool loading;
  @override
  final String? searchQuery;
  final List<HouseholdMemberWrapper> _householdMembers;
  @override
  @JsonKey()
  List<HouseholdMemberWrapper> get householdMembers {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_householdMembers);
  }

  @override
  @JsonKey()
  final int registeredHouseholds;
  @override
  @JsonKey()
  final int deliveredInterventions;
  @override
  @JsonKey()
  final int adverseEventsObserved;

  @override
  String toString() {
    return 'SearchHouseholdsState(loading: $loading, searchQuery: $searchQuery, householdMembers: $householdMembers, registeredHouseholds: $registeredHouseholds, deliveredInterventions: $deliveredInterventions, adverseEventsObserved: $adverseEventsObserved)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SearchHouseholdsState &&
            (identical(other.loading, loading) || other.loading == loading) &&
            (identical(other.searchQuery, searchQuery) ||
                other.searchQuery == searchQuery) &&
            const DeepCollectionEquality()
                .equals(other._householdMembers, _householdMembers) &&
            (identical(other.registeredHouseholds, registeredHouseholds) ||
                other.registeredHouseholds == registeredHouseholds) &&
            (identical(other.deliveredInterventions, deliveredInterventions) ||
                other.deliveredInterventions == deliveredInterventions) &&
            (identical(other.adverseEventsObserved, adverseEventsObserved) ||
                other.adverseEventsObserved == adverseEventsObserved));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      loading,
      searchQuery,
      const DeepCollectionEquality().hash(_householdMembers),
      registeredHouseholds,
      deliveredInterventions,
      adverseEventsObserved);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SearchHouseholdsStateCopyWith<_$_SearchHouseholdsState> get copyWith =>
      __$$_SearchHouseholdsStateCopyWithImpl<_$_SearchHouseholdsState>(
          this, _$identity);
}

abstract class _SearchHouseholdsState extends SearchHouseholdsState {
  const factory _SearchHouseholdsState(
      {final bool loading,
      final String? searchQuery,
      final List<HouseholdMemberWrapper> householdMembers,
      final int registeredHouseholds,
      final int deliveredInterventions,
      final int adverseEventsObserved}) = _$_SearchHouseholdsState;
  const _SearchHouseholdsState._() : super._();

  @override
  bool get loading;
  @override
  String? get searchQuery;
  @override
  List<HouseholdMemberWrapper> get householdMembers;
  @override
  int get registeredHouseholds;
  @override
  int get deliveredInterventions;
  @override
  int get adverseEventsObserved;
  @override
  @JsonKey(ignore: true)
  _$$_SearchHouseholdsStateCopyWith<_$_SearchHouseholdsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$HouseholdMemberWrapper {
  HouseholdModel get household => throw _privateConstructorUsedError;
  IndividualModel get headOfHousehold => throw _privateConstructorUsedError;
  List<IndividualModel> get members => throw _privateConstructorUsedError;
  List<ProjectBeneficiaryModel> get projectBeneficiaries =>
      throw _privateConstructorUsedError;
  List<TaskModel>? get tasks => throw _privateConstructorUsedError;
  List<AdverseEventModel>? get adverseEvents =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $HouseholdMemberWrapperCopyWith<HouseholdMemberWrapper> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HouseholdMemberWrapperCopyWith<$Res> {
  factory $HouseholdMemberWrapperCopyWith(HouseholdMemberWrapper value,
          $Res Function(HouseholdMemberWrapper) then) =
      _$HouseholdMemberWrapperCopyWithImpl<$Res, HouseholdMemberWrapper>;
  @useResult
  $Res call(
      {HouseholdModel household,
      IndividualModel headOfHousehold,
      List<IndividualModel> members,
      List<ProjectBeneficiaryModel> projectBeneficiaries,
      List<TaskModel>? tasks,
      List<AdverseEventModel>? adverseEvents});
}

/// @nodoc
class _$HouseholdMemberWrapperCopyWithImpl<$Res,
        $Val extends HouseholdMemberWrapper>
    implements $HouseholdMemberWrapperCopyWith<$Res> {
  _$HouseholdMemberWrapperCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? household = null,
    Object? headOfHousehold = null,
    Object? members = null,
    Object? projectBeneficiaries = null,
    Object? tasks = freezed,
    Object? adverseEvents = freezed,
  }) {
    return _then(_value.copyWith(
      household: null == household
          ? _value.household
          : household // ignore: cast_nullable_to_non_nullable
              as HouseholdModel,
      headOfHousehold: null == headOfHousehold
          ? _value.headOfHousehold
          : headOfHousehold // ignore: cast_nullable_to_non_nullable
              as IndividualModel,
      members: null == members
          ? _value.members
          : members // ignore: cast_nullable_to_non_nullable
              as List<IndividualModel>,
      projectBeneficiaries: null == projectBeneficiaries
          ? _value.projectBeneficiaries
          : projectBeneficiaries // ignore: cast_nullable_to_non_nullable
              as List<ProjectBeneficiaryModel>,
      tasks: freezed == tasks
          ? _value.tasks
          : tasks // ignore: cast_nullable_to_non_nullable
              as List<TaskModel>?,
      adverseEvents: freezed == adverseEvents
          ? _value.adverseEvents
          : adverseEvents // ignore: cast_nullable_to_non_nullable
              as List<AdverseEventModel>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_HouseholdMemberWrapperCopyWith<$Res>
    implements $HouseholdMemberWrapperCopyWith<$Res> {
  factory _$$_HouseholdMemberWrapperCopyWith(_$_HouseholdMemberWrapper value,
          $Res Function(_$_HouseholdMemberWrapper) then) =
      __$$_HouseholdMemberWrapperCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {HouseholdModel household,
      IndividualModel headOfHousehold,
      List<IndividualModel> members,
      List<ProjectBeneficiaryModel> projectBeneficiaries,
      List<TaskModel>? tasks,
      List<AdverseEventModel>? adverseEvents});
}

/// @nodoc
class __$$_HouseholdMemberWrapperCopyWithImpl<$Res>
    extends _$HouseholdMemberWrapperCopyWithImpl<$Res,
        _$_HouseholdMemberWrapper>
    implements _$$_HouseholdMemberWrapperCopyWith<$Res> {
  __$$_HouseholdMemberWrapperCopyWithImpl(_$_HouseholdMemberWrapper _value,
      $Res Function(_$_HouseholdMemberWrapper) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? household = null,
    Object? headOfHousehold = null,
    Object? members = null,
    Object? projectBeneficiaries = null,
    Object? tasks = freezed,
    Object? adverseEvents = freezed,
  }) {
    return _then(_$_HouseholdMemberWrapper(
      household: null == household
          ? _value.household
          : household // ignore: cast_nullable_to_non_nullable
              as HouseholdModel,
      headOfHousehold: null == headOfHousehold
          ? _value.headOfHousehold
          : headOfHousehold // ignore: cast_nullable_to_non_nullable
              as IndividualModel,
      members: null == members
          ? _value._members
          : members // ignore: cast_nullable_to_non_nullable
              as List<IndividualModel>,
      projectBeneficiaries: null == projectBeneficiaries
          ? _value._projectBeneficiaries
          : projectBeneficiaries // ignore: cast_nullable_to_non_nullable
              as List<ProjectBeneficiaryModel>,
      tasks: freezed == tasks
          ? _value._tasks
          : tasks // ignore: cast_nullable_to_non_nullable
              as List<TaskModel>?,
      adverseEvents: freezed == adverseEvents
          ? _value._adverseEvents
          : adverseEvents // ignore: cast_nullable_to_non_nullable
              as List<AdverseEventModel>?,
    ));
  }
}

/// @nodoc

class _$_HouseholdMemberWrapper implements _HouseholdMemberWrapper {
  const _$_HouseholdMemberWrapper(
      {required this.household,
      required this.headOfHousehold,
      required final List<IndividualModel> members,
      required final List<ProjectBeneficiaryModel> projectBeneficiaries,
      final List<TaskModel>? tasks,
      final List<AdverseEventModel>? adverseEvents})
      : _members = members,
        _projectBeneficiaries = projectBeneficiaries,
        _tasks = tasks,
        _adverseEvents = adverseEvents;

  @override
  final HouseholdModel household;
  @override
  final IndividualModel headOfHousehold;
  final List<IndividualModel> _members;
  @override
  List<IndividualModel> get members {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_members);
  }

  final List<ProjectBeneficiaryModel> _projectBeneficiaries;
  @override
  List<ProjectBeneficiaryModel> get projectBeneficiaries {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_projectBeneficiaries);
  }

  final List<TaskModel>? _tasks;
  @override
  List<TaskModel>? get tasks {
    final value = _tasks;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<AdverseEventModel>? _adverseEvents;
  @override
  List<AdverseEventModel>? get adverseEvents {
    final value = _adverseEvents;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'HouseholdMemberWrapper(household: $household, headOfHousehold: $headOfHousehold, members: $members, projectBeneficiaries: $projectBeneficiaries, tasks: $tasks, adverseEvents: $adverseEvents)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_HouseholdMemberWrapper &&
            (identical(other.household, household) ||
                other.household == household) &&
            (identical(other.headOfHousehold, headOfHousehold) ||
                other.headOfHousehold == headOfHousehold) &&
            const DeepCollectionEquality().equals(other._members, _members) &&
            const DeepCollectionEquality()
                .equals(other._projectBeneficiaries, _projectBeneficiaries) &&
            const DeepCollectionEquality().equals(other._tasks, _tasks) &&
            const DeepCollectionEquality()
                .equals(other._adverseEvents, _adverseEvents));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      household,
      headOfHousehold,
      const DeepCollectionEquality().hash(_members),
      const DeepCollectionEquality().hash(_projectBeneficiaries),
      const DeepCollectionEquality().hash(_tasks),
      const DeepCollectionEquality().hash(_adverseEvents));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_HouseholdMemberWrapperCopyWith<_$_HouseholdMemberWrapper> get copyWith =>
      __$$_HouseholdMemberWrapperCopyWithImpl<_$_HouseholdMemberWrapper>(
          this, _$identity);
}

abstract class _HouseholdMemberWrapper implements HouseholdMemberWrapper {
  const factory _HouseholdMemberWrapper(
          {required final HouseholdModel household,
          required final IndividualModel headOfHousehold,
          required final List<IndividualModel> members,
          required final List<ProjectBeneficiaryModel> projectBeneficiaries,
          final List<TaskModel>? tasks,
          final List<AdverseEventModel>? adverseEvents}) =
      _$_HouseholdMemberWrapper;

  @override
  HouseholdModel get household;
  @override
  IndividualModel get headOfHousehold;
  @override
  List<IndividualModel> get members;
  @override
  List<ProjectBeneficiaryModel> get projectBeneficiaries;
  @override
  List<TaskModel>? get tasks;
  @override
  List<AdverseEventModel>? get adverseEvents;
  @override
  @JsonKey(ignore: true)
  _$$_HouseholdMemberWrapperCopyWith<_$_HouseholdMemberWrapper> get copyWith =>
      throw _privateConstructorUsedError;
}
